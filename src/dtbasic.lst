0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             ;
0022   0000             ;==================================================================================
0023   0000             
0024   0000             #include "cpm.inc"
0001+  0000             
0002+  0000             #define		BDOS		0005H
0003+  0000             
0004+  0000             #define cpm.pTerm()        	RST     00
0005+  0000             
0006+  0000             
0007+  0000             #define cpm.cReadChr()       	LD      C, 01H
0008+  0000             #defcont \                      CALL    BDOS
0009+  0000             
0010+  0000             #define cpm.cRead()       	LD      C, 01H
0011+  0000             #defcont \                      CALL    BDOS
0012+  0000             
0013+  0000             #define cpm.cWriteChr(chr)   	LD      E, chr
0014+  0000             #defcont \			LD      C, 02H
0015+  0000             #defcont \                      CALL    BDOS
0016+  0000             
0017+  0000             #define cpm.cWrite()		LD      C, 02H
0018+  0000             #defcont \                      CALL    BDOS
0019+  0000             
0020+  0000             #define cpm.aReadChr()       	LD      C, 03H
0021+  0000             #defcont \                      CALL    BDOS
0022+  0000             
0023+  0000             #define cpm.aWriteChr(chr)   	LD      E, chr
0024+  0000             #defcont \                      LD      C, 04H
0025+  0000             #defcont \                      CALL    BDOS
0026+  0000             
0027+  0000             #define cpm.cWriteStr(str)	LD      DE, str
0028+  0000             #defcont \			LD      C, 09H
0029+  0000             #defcont \                      CALL    BDOS
0030+  0000             
0031+  0000             #define cpm.cStat()   		LD      C, 0BH
0032+  0000             #defcont \                      CALL    BDOS
0033+  0000             
0025   0000             #include "std.asm"
0001+  0000             ; The purpose of this file is to define generic symbols and to include
0002+  0000             ; the requested build configuraton file to bring in platform specifics.
0003+  0000             
0004+  0000             ; There are several hardware platforms supported by SBC.
0005+  0000             ; 1.  SBC 	Z80 SBC (v1 or v2) w/ ECB interface
0006+  0000             ; 2.  ZETA	Standalone Z80 SBC w/ SBC compatibility
0007+  0000             ; 3.  ZETA2	Second version of ZETA with enhanced memory bank switching
0008+  0000             ; 4.  N8	MSX-ish Z180 SBC w/ onboard video and sound
0009+  0000             ; 5.  MK4	Mark IV Z180 based SBC w/ ECB interface
0010+  0000             ; 6.  UNA	Any Z80/Z180 computer with UNA BIOS
0011+  0000             ; 7.  RCZ80	RC2014 based system with 512K banked RAM/ROM card
0012+  0000             ; 8.  RCZ180	RC2014 based system with Z180 CPU
0013+  0000             ; 9.  EZZ80	Easy Z80, Z80 SBC w/ RC2014 bus and CTC
0014+  0000             ; 10. SCZ180	Steve Cousins Z180 based system
0015+  0000             ; 11. DYNO	Steve Garcia's Dyno Micro-ATX Motherboard
0016+  0000             
0017+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0018+  0000             ;
0019+  0000             ; INCLUDE VERSION
0020+  0000             ;
0021+  0000             #INCLUDE "ver.inc"			; ADD BIOSVER
0001++ 0000             #DEFINE	RMJ	2
0002++ 0000             #DEFINE	RMN	9
0003++ 0000             #DEFINE	RUP	2
0004++ 0000             #DEFINE	RTP	0
0005++ 0000             #DEFINE BIOSVER	"2.9.2-pre.32"
0022+  0000             ;
0023+  0000             FALSE		.EQU 	0
0024+  0000             TRUE		.EQU 	~FALSE
0025+  0000             ;
0026+  0000             ; DEBUGGING OPTIONS
0027+  0000             ;
0028+  0000             USENONE		.EQU	0		; NO DEBUG
0029+  0000             USEXIO		.EQU	1		; BASIC SERIAL DRIVER
0030+  0000             USEMIO		.EQU	2		; MEMORY BUFFER DRIVER
0031+  0000             WBWDEBUG	.EQU	USENONE
0032+  0000             ;
0033+  0000             ; PRIMARY HARDWARE PLATFORMS
0034+  0000             ;
0035+  0000             PLT_SBC		.EQU	1		; SBC ECB Z80 SBC
0036+  0000             PLT_ZETA	.EQU	2		; ZETA Z80 SBC
0037+  0000             PLT_ZETA2	.EQU	3		; ZETA Z80 V2 SBC
0038+  0000             PLT_N8		.EQU	4		; N8 (HOME COMPUTER) Z180 SBC
0039+  0000             PLT_MK4		.EQU	5		; MARK IV
0040+  0000             PLT_UNA		.EQU	6		; UNA BIOS
0041+  0000             PLT_RCZ80	.EQU	7		; RC2014 W Z80
0042+  0000             PLT_RCZ180	.EQU	8		; RC2014 W/ Z180
0043+  0000             PLT_EZZ80	.EQU	9		; EASY Z80
0044+  0000             PLT_SCZ180	.EQU	10		; SCZ180
0045+  0000             PLT_DYNO	.EQU	11		; DYNO MICRO-ATX MOTHERBOARD
0046+  0000             ;
0047+  0000             ;
0048+  0000             ; CPU TYPES
0049+  0000             ;
0050+  0000             CPU_NONE	.EQU	0		; NO CPU TYPE DEFINED
0051+  0000             CPU_Z80		.EQU	1		; Z80 FAMILY
0052+  0000             CPU_Z180	.EQU	2		; Z180 FAMILY
0053+  0000             CPU_Z280	.EQU	3		; Z280 FAMILY
0054+  0000             ;
0055+  0000             ; BIOS MODE
0056+  0000             ;
0057+  0000             BIOS_NONE	.EQU	0		; NO BIOS TYPE DEFINED
0058+  0000             BIOS_WBW	.EQU	1		; ROMWBW HBIOS
0059+  0000             BIOS_UNA	.EQU	2		; UNA UBIOS
0060+  0000             ;
0061+  0000             ; MEMORY MANAGERS
0062+  0000             ;
0063+  0000             MM_NONE		.EQU	0
0064+  0000             MM_SBC		.EQU	1		; ORIGINAL N8VEM/RBC Z80 SBC BANKED MEMORY
0065+  0000             MM_Z2		.EQU	2		; 16K X 4 BANKED MEMORY INTRODUCED ON ZETA2
0066+  0000             MM_N8		.EQU	3		; Z180 CUSTOMIZED FOR N8 MEMORY EXTENSIONS
0067+  0000             MM_Z180		.EQU	4		; Z180 NATIVE MEMORY MANAGER
0068+  0000             ;
0069+  0000             ; BOOT STYLE
0070+  0000             ;
0071+  0000             BT_MENU		.EQU	1		; WAIT FOR MENU SELECTION AT LOADER PROMPT
0072+  0000             BT_AUTO		.EQU	2		; AUTO SELECT BOOT_DEFAULT AFTER BOOT_TIMEOUT
0073+  0000             ;
0074+  0000             ; BOOT RECOVERY METHODS
0075+  0000             ;
0076+  0000             BT_REC_NONE	.EQU	0		; NO RECOVERY MODE
0077+  0000             BT_REC_FORCE	.EQU	1		; FORCE BOOT RECOVERY MODE
0078+  0000             BT_REC_SBC01	.EQU	2		; ECB-SBCV2 - BIT 1 RTC HIGH
0079+  0000             BT_REC_SBC1B	.EQU	3		; ECB-SBCV2 - 1-BIT IO PORT
0080+  0000             BT_REC_SBCRI	.EQU	4		; ECB-SBCV2 - 16550 UART RING INDICATOR LINE
0081+  0000             ;
0082+  0000             BT_REC_TYPE	.EQU	BT_REC_NONE	; BOOT RECOVERY METHOD TO USE
0083+  0000             ;
0084+  0000             ; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
0085+  0000             ;
0086+  0000             FDM720		.EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
0087+  0000             FDM144		.EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
0088+  0000             FDM360		.EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
0089+  0000             FDM120		.EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
0090+  0000             FDM111		.EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
0091+  0000             ;
0092+  0000             ; MEDIA ID VALUES
0093+  0000             ;
0094+  0000             MID_NONE	.EQU	0
0095+  0000             MID_MDROM	.EQU	1
0096+  0000             MID_MDRAM	.EQU	2
0097+  0000             MID_RF		.EQU	3
0098+  0000             MID_HD		.EQU	4
0099+  0000             MID_FD720	.EQU	5
0100+  0000             MID_FD144	.EQU	6
0101+  0000             MID_FD360	.EQU	7
0102+  0000             MID_FD120	.EQU	8
0103+  0000             MID_FD111	.EQU	9
0104+  0000             ;
0105+  0000             ; ZILOG CTC MODE SELECTIONS
0106+  0000             ;
0107+  0000             CTCMODE_NONE	.EQU	0		; NO CTC
0108+  0000             CTCMODE_ZP	.EQU	1		; ZILOG PERIPHERALS ECB CTC
0109+  0000             CTCMODE_Z2	.EQU	2		; ZETA2 ONBOARD CTC
0110+  0000             CTCMODE_EZ	.EQU	3		; EASY Z80 ONBOARD CTC
0111+  0000             CTCMODE_RC	.EQU	4		; RC2014 CTC MODULE (ALSO KIO)
0112+  0000             ;
0113+  0000             ; DS RTC MODE SELECTIONS
0114+  0000             ;
0115+  0000             DSRTCMODE_NONE	.EQU	0		; NO DSRTC
0116+  0000             DSRTCMODE_STD	.EQU	1		; ORIGINAL DSRTC CIRCUIT (SBC, ZETA, MK4)
0117+  0000             DSRTCMODE_MFPIC	.EQU	2		; MF/PIC VARIANT
0118+  0000             ;
0119+  0000             ; SIO MODE SELECTIONS
0120+  0000             ;
0121+  0000             SIOMODE_NONE	.EQU	0
0122+  0000             SIOMODE_RC	.EQU	1		; RC2014 SIO MODULE (SPENCER OWEN)
0123+  0000             SIOMODE_SMB	.EQU	2		; RC2014 SIO MODULE (SCOTT BAKER)
0124+  0000             SIOMODE_ZP	.EQU	3		; ECB-ZILOG PERIPHERALS BOARD
0125+  0000             SIOMODE_EZZ80	.EQU	4		; EASY Z80 ON-BOARD SIO/0
0126+  0000             ;
0127+  0000             ; TYPE OF CONSOLE BELL TO USE
0128+  0000             ;
0129+  0000             CONBELL_NONE	.EQU	0
0130+  0000             CONBELL_PSG	.EQU	1
0131+  0000             CONBELL_IOBIT	.EQU	2
0132+  0000             ;
0133+  0000             ; FD MODE SELECTIONS
0134+  0000             ;
0135+  0000             FDMODE_NONE	.EQU	0
0136+  0000             FDMODE_DIO	.EQU	1		; DISKIO V1
0137+  0000             FDMODE_ZETA	.EQU	2		; ZETA
0138+  0000             FDMODE_ZETA2	.EQU	3		; ZETA V2
0139+  0000             FDMODE_DIDE	.EQU	4		; DUAL IDE
0140+  0000             FDMODE_N8	.EQU	5		; N8
0141+  0000             FDMODE_DIO3	.EQU	6		; DISKIO V3
0142+  0000             FDMODE_RCSMC	.EQU	7		; RC2014 SMC 9266 @ $40 (SCOTT BAKER)
0143+  0000             FDMODE_RCWDC	.EQU	8		; RC2014 WDC 37C65 @ $40 (SCOTT BAKER)
0144+  0000             FDMODE_DYNO	.EQU	9		; DYNO WDC 37C65 @ $84
0145+  0000             ;
0146+  0000             ; IDE MODE SELECTIONS
0147+  0000             ;
0148+  0000             IDEMODE_NONE	.EQU	0
0149+  0000             IDEMODE_DIO	.EQU	1		; DISKIO V1
0150+  0000             IDEMODE_DIDE	.EQU	2		; DUAL IDE
0151+  0000             IDEMODE_MK4	.EQU	3		; MARK IV ONBOARD IDE (8 BIT ONLY)
0152+  0000             IDEMODE_RC	.EQU	4		; RC2014 CF MODULE (8 BIT ONLY)
0153+  0000             ;
0154+  0000             ; PPIDE MODE SELECTIONS
0155+  0000             ;
0156+  0000             PPIDEMODE_NONE	.EQU	0
0157+  0000             PPIDEMODE_SBC	.EQU	1		; STANDARD SBC PARALLEL PORT
0158+  0000             PPIDEMODE_DIO3	.EQU	2		; DISKIO V3 PARALLEL PORT
0159+  0000             PPIDEMODE_MFP	.EQU	3		; MULTIFUNCTION / PIC
0160+  0000             PPIDEMODE_N8	.EQU	4		; MULTIFUNCTION / PIC
0161+  0000             PPIDEMODE_RC	.EQU	5		; RC2014 PPIDE MODULE @ $20 (ED BRINDLEY)
0162+  0000             PPIDEMODE_DYNO	.EQU	6		; DYNO PPIDE @ $4C
0163+  0000             ;
0164+  0000             ; SD MODE SELECTIONS
0165+  0000             ;
0166+  0000             SDMODE_NONE	.EQU	0
0167+  0000             SDMODE_JUHA	.EQU	1		; JUHA MINI BOARD
0168+  0000             SDMODE_N8	.EQU	2		; N8-2511, UNMODIFIED
0169+  0000             SDMODE_CSIO	.EQU	3		; N8-2312 OR N8-2511 MODIFIED
0170+  0000             SDMODE_PPI	.EQU	4		; PPISD MINI BOARD
0171+  0000             SDMODE_UART	.EQU	5		; SD INTERFACE VIA UART
0172+  0000             SDMODE_DSD	.EQU	6		; DUAL SD
0173+  0000             SDMODE_MK4	.EQU	7		; MARK IV
0174+  0000             SDMODE_SC	.EQU	8		; SC (Steve Cousins)
0175+  0000             SDMODE_MT	.EQU	9		; MT (Shift register SPI WIZNET for RC2014)
0176+  0000             ;
0177+  0000             ; SOUND CHIP MODE SELECTIONS
0178+  0000             ;
0179+  0000             AYMODE_NONE	.EQU	0
0180+  0000             AYMODE_N8	.EQU	1		; N8 BUILT-IN SOUND
0181+  0000             AYMODE_SCG	.EQU	2		; SCG ECB BOARD
0182+  0000             AYMODE_RCZ80	.EQU	3		; RC2014 SOUND MODULE BY ED BRINDLEY ON Z80
0183+  0000             AYMODE_RCZ180	.EQU	4		; RC2014 SOUND MODULE BY ED BRINDLEY ON Z180
0184+  0000             ;
0185+  0000             ; TMS VIDEO MODE SELECTIONS
0186+  0000             ;
0187+  0000             TMSMODE_NONE	.EQU	0
0188+  0000             TMSMODE_SCG	.EQU	1		; SCG ECB BOARD
0189+  0000             TMSMODE_N8	.EQU	2		; N8 BUILT-IN VIDEO
0190+  0000             ;
0191+  0000             ; SERIAL DEVICE CONFIGURATION CONSTANTS
0192+  0000             ;
0193+  0000             SER_DATA5	.EQU	0 << 0
0194+  0000             SER_DATA6	.EQU	1 << 0
0195+  0000             SER_DATA7	.EQU	2 << 0
0196+  0000             SER_DATA8	.EQU	3 << 0
0197+  0000             ;
0198+  0000             SER_PARNONE	.EQU	0 << 3
0199+  0000             SER_PARODD	.EQU	1 << 3
0200+  0000             SER_PAREVEN	.EQU	3 << 3
0201+  0000             SER_PARMARK	.EQU	5 << 3
0202+  0000             SER_PARSPACE	.EQU	7 << 3
0203+  0000             ;
0204+  0000             SER_STOP1	.EQU	0 << 2
0205+  0000             SER_STOP2	.EQU	1 << 2
0206+  0000             ;
0207+  0000             ; SERIAL BAUD RATES ENCODED AS V = 75 * 2^X * 3^Y
0208+  0000             ; AND STORED AS 5 BITS: YXXXX
0209+  0000             ;
0210+  0000             SER_BAUD75	.EQU	$00 << 8
0211+  0000             SER_BAUD150	.EQU	$01 << 8
0212+  0000             SER_BAUD300	.EQU	$02 << 8
0213+  0000             SER_BAUD600	.EQU	$03 << 8
0214+  0000             SER_BAUD1200	.EQU	$04 << 8
0215+  0000             SER_BAUD2400	.EQU	$05 << 8
0216+  0000             SER_BAUD4800	.EQU	$06 << 8
0217+  0000             SER_BAUD9600	.EQU	$07 << 8
0218+  0000             SER_BAUD19200	.EQU	$08 << 8
0219+  0000             SER_BAUD38400	.EQU	$09 << 8
0220+  0000             SER_BAUD76800	.EQU	$0A << 8
0221+  0000             SER_BAUD153600	.EQU	$0B << 8
0222+  0000             SER_BAUD307200	.EQU	$0C << 8
0223+  0000             SER_BAUD614400	.EQU	$0D << 8
0224+  0000             SER_BAUD1228800	.EQU	$0E << 8
0225+  0000             SER_BAUD2457600	.EQU	$0F << 8
0226+  0000             SER_BAUD225	.EQU	$10 << 8
0227+  0000             SER_BAUD450	.EQU	$11 << 8
0228+  0000             SER_BAUD900	.EQU	$12 << 8
0229+  0000             SER_BAUD1800	.EQU	$13 << 8
0230+  0000             SER_BAUD3600	.EQU	$14 << 8
0231+  0000             SER_BAUD7200	.EQU	$15 << 8
0232+  0000             SER_BAUD14400	.EQU	$16 << 8
0233+  0000             SER_BAUD28800	.EQU	$17 << 8
0234+  0000             SER_BAUD57600	.EQU	$18 << 8
0235+  0000             SER_BAUD115200	.EQU	$19 << 8
0236+  0000             SER_BAUD230400	.EQU	$1A << 8
0237+  0000             SER_BAUD460800	.EQU	$1B << 8
0238+  0000             SER_BAUD921600	.EQU	$1C << 8
0239+  0000             SER_BAUD1843200	.EQU	$1D << 8
0240+  0000             SER_BAUD3686400	.EQU	$1E << 8
0241+  0000             SER_BAUD7372800	.EQU	$1F << 8
0242+  0000             ;
0243+  0000             SER_XON		.EQU	1 << 6
0244+  0000             SER_DTR		.EQU	1 << 7
0245+  0000             SER_RTS		.EQU	1 << 13
0246+  0000             ;
0247+  0000             SER_75_8N1	.EQU	SER_BAUD75 | SER_DATA8 | SER_PARNONE | SER_STOP1
0248+  0000             SER_150_8N1	.EQU	SER_BAUD150 | SER_DATA8 | SER_PARNONE | SER_STOP1
0249+  0000             SER_300_8N1	.EQU	SER_BAUD300 | SER_DATA8 | SER_PARNONE | SER_STOP1
0250+  0000             SER_600_8N1	.EQU	SER_BAUD600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0251+  0000             SER_1200_8N1	.EQU	SER_BAUD1200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0252+  0000             SER_2400_8N1	.EQU	SER_BAUD2400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0253+  0000             SER_4800_8N1	.EQU	SER_BAUD4800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0254+  0000             SER_9600_8N1	.EQU	SER_BAUD9600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0255+  0000             SER_19200_8N1	.EQU	SER_BAUD19200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0256+  0000             SER_38400_8N1	.EQU	SER_BAUD38400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0257+  0000             SER_76800_8N1	.EQU	SER_BAUD76800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0258+  0000             SER_153600_8N1	.EQU	SER_BAUD153600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0259+  0000             SER_307200_8N1	.EQU	SER_BAUD307200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0260+  0000             SER_614400_8N1	.EQU	SER_BAUD614400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0261+  0000             SER_1228800_8N1	.EQU	SER_BAUD1228800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0262+  0000             SER_2457600_8N1	.EQU	SER_BAUD2457600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0263+  0000             SER_225_8N1	.EQU	SER_BAUD225 | SER_DATA8 | SER_PARNONE | SER_STOP1
0264+  0000             SER_450_8N1	.EQU	SER_BAUD450 | SER_DATA8 | SER_PARNONE | SER_STOP1
0265+  0000             SER_900_8N1	.EQU	SER_BAUD900 | SER_DATA8 | SER_PARNONE | SER_STOP1
0266+  0000             SER_1800_8N1	.EQU	SER_BAUD1800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0267+  0000             SER_3600_8N1	.EQU	SER_BAUD3600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0268+  0000             SER_7200_8N1	.EQU	SER_BAUD7200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0269+  0000             SER_14400_8N1	.EQU	SER_BAUD14400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0270+  0000             SER_28800_8N1	.EQU	SER_BAUD28800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0271+  0000             SER_57600_8N1	.EQU	SER_BAUD57600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0272+  0000             SER_115200_8N1	.EQU	SER_BAUD115200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0273+  0000             SER_230400_8N1	.EQU	SER_BAUD230400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0274+  0000             SER_460800_8N1	.EQU	SER_BAUD460800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0275+  0000             SER_921600_8N1	.EQU	SER_BAUD921600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0276+  0000             SER_1843200_8N1	.EQU	SER_BAUD1843200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0277+  0000             SER_3686400_8N1	.EQU	SER_BAUD3686400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0278+  0000             SER_7372800_8N1	.EQU	SER_BAUD7372800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0279+  0000             ;
0280+  0000             ; TERMENABLE CONTROLS INCLUSION OF TERMINAL PSEUDO-DEVICE DRIVER
0281+  0000             ; IT IS SET TO TRUE BY THE INCLUSION OF ANY VDA DRIVER.
0282+  0000             ;
0283+  0000             TERMENABLE	.EQU	FALSE		; TERM PSEUDO DEVICE, WILL AUTO-ENABLE IF A VDA IS ENABLED
0284+  0000             ;
0285+  0000             ; VIDEO MODES
0286+  0000             ;
0287+  0000             V80X24		.EQU	0	; ECB-VDU
0288+  0000             V80X25		.EQU	1	; ECB-VDU, ECB-VGA3
0289+  0000             V80X30		.EQU	2	; ECB-VDU, ECB-VGA3
0290+  0000             V80X25B		.EQU	3	; ECB-VDU
0291+  0000             V80X24B		.EQU	4	; ECB-VDU
0292+  0000             V80X43		.EQU	5	; ECB-VGA3
0293+  0000             V80X60		.EQU	6	; ECB-VGA3
0294+  0000             ;
0295+  0000             ; FONTS
0296+  0000             ;
0297+  0000             USELZSA2	.EQU	FALSE	; USE COMPRESSED FONTS.
0298+  0000             ;
0299+  0000             ; KEYBOARD LAYOUTS
0300+  0000             ;
0301+  0000             KBD_US		.EQU	0	; US ENGLISH
0302+  0000             KBD_DE		.EQU	1	; GERMAN
0303+  0000             ;
0304+  0000             ; EMULATION TYPES
0305+  0000             ;
0306+  0000             EMUTYP_NONE     .EQU    0               ; NONE
0307+  0000             EMUTYP_TTY      .EQU    1               ; TTY
0308+  0000             EMUTYP_ANSI     .EQU    2               ; ANSI
0309+  0000             ;
0310+  0000             ; DEVICE DRIVER TO BE INITIALIZED FIRST. FIRST CIO DRIVER, UNIT 0 INITIALIZED BECOMES PRIMARY CONSOLE.
0311+  0000             ; IS AN INDEX INTO THE ENABLED INITIALIZATION DRIVER LIST i.e. ASCI, UART, SIO, ACIA, PIO, UF ETC.
0312+  0000             ; EXAMPLE: IF ONLY UART, SIO AND PIO ARE ENABLE AND THE SIO IS DESIRED AS THE PRIMARY CONSOLE,
0313+  0000             ; SET FORCECON TO 2 IN YOUR CUSTOM CONFIGURATION FILE i.e. "FORCECON: .SET 2"
0314+  0000             ;
0315+  0000             FORCECON	.EQU	0	; DEFAULT IS TO FOLLOW NORMAL SEQUENCE
0316+  0000             ;
0317+  0000             #INCLUDE "build.inc"		; INCLUDE USER CONFIG, ADD VARIANT, TIMESTAMP, & ROMSIZE
0001++ 0000             ; RomWBW Configured for RCZ80 std 2020-02-26
0002++ 0000             ;
0003++ 0000             #DEFINE	TIMESTAMP	"2020-02-26"
0004++ 0000             ;
0005++ 0000             ROMSIZE		.EQU	512
0006++ 0000             ;
0007++ 0000             #INCLUDE "RCZ80_std.asm"
0001+++0000             ;
0002+++0000             ;==================================================================================================
0003+++0000             ;   RC2014 Z80 STANDARD CONFIGURATION
0004+++0000             ;==================================================================================================
0005+++0000             ;
0006+++0000             ; THE COMPLETE SET OF DEFAULT CONFIGURATION SETTINGS FOR THIS PLATFORM ARE FOUND IN THE
0007+++0000             ; CFG_<PLT>.ASM INCLUDED FILE WHICH IS FOUND IN THE PARENT DIRECTORY.  THIS FILE CONTAINS
0008+++0000             ; COMMON CONFIGURATION SETTINGS THAT OVERRIDE THE DEFAULTS.  IT IS INTENDED THAT YOU MAKE
0009+++0000             ; YOUR CUSTOMIZATIONS IN THIS FILE AND JUST INHERIT ALL OTHER SETTINGS FROM THE DEFAULTS.
0010+++0000             ; EVEN BETTER, YOU CAN MAKE A COPY OF THIS FILE WITH A NAME LIKE <PLT>_XXX.ASM AND SPECIFY
0011+++0000             ; YOUR FILE IN THE BUILD PROCESS.
0012+++0000             ;
0013+++0000             ; THE SETTINGS BELOW ARE THE SETTINGS THAT ARE MOST COMMONLY MODIFIED FOR THIS PLATFORM.
0014+++0000             ; MANY OF THEM ARE EQUAL TO THE SETTINGS IN THE INCLUDED FILE, SO THEY DON'T REALLY DO
0015+++0000             ; ANYTHING AS IS.  THEY ARE LISTED HERE TO MAKE IT EASY FOR YOU TO ADJUST THE MOST COMMON
0016+++0000             ; SETTINGS.
0017+++0000             ;
0018+++0000             ; N.B., SINCE THE SETTINGS BELOW ARE REDEFINING VALUES ALREADY SET IN THE INCLUDED FILE,
0019+++0000             ; TASM INSISTS THAT YOU USE THE .SET OPERATOR AND NOT THE .EQU OPERATOR BELOW. ATTEMPTING
0020+++0000             ; TO REDEFINE A VALUE WITH .EQU BELOW WILL CAUSE TASM ERRORS!
0021+++0000             ;
0022+++0000             ; PLEASE REFER TO THE CUSTOM BUILD INSTRUCTIONS (README.TXT) IN THE SOURCE DIRECTORY (TWO
0023+++0000             ; DIRECTORIES ABOVE THIS ONE).
0024+++0000             ;
0025+++0000             #include "cfg_rcz80.asm"
0001+++0000             ;
0002+++0000             ;==================================================================================================
0003+++0000             ;   ROMWBW 2.X CONFIGURATION DEFAULTS FOR RC2014 Z80
0004+++0000             ;==================================================================================================
0005+++0000             ;
0006+++0000             ; THIS FILE CONTAINS THE FULL SET OF DEFAULT CONFIGURATION SETTINGS FOR THE PLATFORM
0007+++0000             ; INDICATED ABOVE. THIS FILE SHOULD *NOT* NORMALLY BE CHANGED.	INSTEAD, YOU SHOULD
0008+++0000             ; OVERRIDE ANY SETTINGS YOU WANT USING A CONFIGURATION FILE IN THE CONFIG DIRECTORY
0009+++0000             ; UNDER THIS DIRECTORY.
0010+++0000             ;
0011+++0000             ; THIS FILE CAN BE CONSIDERED A REFERENCE THAT LISTS ALL POSSIBLE CONFIGURATION SETTINGS
0012+++0000             ; FOR THE PLATFORM.
0013+++0000             ;
0014+++0000             #DEFINE PLATFORM_NAME "RC2014"
0015+++0000             ;
0016+++0000             PLATFORM	.EQU	PLT_RCZ80	; PLT_[SBC|ZETA|ZETA2|N8|MK4|UNA|RCZ80|RCZ180|EZZ80|SCZ180|DYNO]
0017+++0000             CPUFAM		.EQU	CPU_Z80		; CPU FAMILY: CPU_[Z80|Z180]
0018+++0000             BIOS		.EQU	BIOS_WBW	; HARDWARE BIOS: BIOS_[WBW|UNA]
0019+++0000             BATCOND		.EQU	FALSE		; ENABLE LOW BATTERY WARNING MESSAGE
0020+++0000             ;
0021+++0000             BOOTTYPE	.EQU	BT_AUTO		; BT_[MENU|AUTO], IF AUTO, BOOT DEFAULT AFTER TIMEOUT
0022+++0000             BOOT_TIMEOUT	.EQU	0		; AUTO BOOT TIMEOUT IN SECONDS, 0 FOR IMMEDIATE BOOT
0023+++0000             BOOT_DEFAULT	.EQU	'C'		; AUTO BOOT SELECTION TO INVOKE AT TIMEOUT
0024+++0000             ;
0025+++0000             ;CPUOSC		.EQU	7372800		; CPU OSC FREQ IN MHZ
0026+++0000             INTMODE		.EQU	1		; INTERRUPTS: 0=NONE, 1=MODE 1, 2=MODE 2
0027+++0000             DEFSERCFG	.EQU	SER_115200_8N1	; DEFAULT SERIAL LINE CONFIG (SEE STD.ASM)
0028+++0000             ;
0029+++0000             RAMSIZE		.EQU	512		; SIZE OF RAM IN KB (MUST MATCH YOUR HARDWARE!!!)
0030+++0000             MEMMGR		.EQU	MM_Z2		; MEMORY MANAGER: MM_[SBC|Z2|N8|Z180]
0031+++0000             MPGSEL_0	.EQU	$78		; Z2 MEM MGR BANK 0 PAGE SELECT REG (WRITE ONLY)
0032+++0000             MPGSEL_1	.EQU	$79		; Z2 MEM MGR BANK 1 PAGE SELECT REG (WRITE ONLY)
0033+++0000             MPGSEL_2	.EQU	$7A		; Z2 MEM MGR BANK 2 PAGE SELECT REG (WRITE ONLY)
0034+++0000             MPGSEL_3	.EQU	$7B		; Z2 MEM MGR BANK 3 PAGE SELECT REG (WRITE ONLY)
0035+++0000             MPGENA		.EQU	$7C		; Z2 MEM MGR PAGING ENABLE REGISTER (BIT 0, WRITE ONLY)
0036+++0000             ;
0037+++0000             RTCIO		.EQU	$C0		; RTC LATCH REGISTER ADR
0038+++0000             ;
0039+++0000             KIOENABLE	.EQU	FALSE		; ENABLE ZILOG KIO SUPPORT
0040+++0000             KIOBASE		.EQU	$80		; KIO BASE I/O ADDRESS
0041+++0000             ;
0042+++0000             CTCENABLE	.EQU	FALSE		; ENABLE ZILOG CTC SUPPORT
0043+++0000             CTCMODE		.EQU	CTCMODE_RC	; CTC MODE: CTCMODE_[ZP|Z2|EZ|RC]
0044+++0000             CTCBASE		.EQU	$88		; CTC BASE I/O ADDRESS
0045+++0000             ;
0046+++0000             DIAGENABLE	.EQU	TRUE		; ENABLES OUTPUT TO 8 BIT LED DIAGNOSTIC PORT
0047+++0000             DIAGPORT	.EQU	$00		; DIAGNOSTIC PORT ADDRESS
0048+++0000             DIAGDISKIO	.EQU	TRUE		; ENABLES DISK I/O ACTIVITY ON DIAGNOSTIC LEDS
0049+++0000             ;
0050+++0000             LEDENABLE	.EQU	FALSE		; ENABLES STATUS LED (SINGLE LED)
0051+++0000             LEDPORT		.EQU	$0E		; STATUS LED PORT ADDRESS
0052+++0000             LEDDISKIO	.EQU	TRUE		; ENABLES DISK I/O ACTIVITY ON STATUS LED
0053+++0000             ;
0054+++0000             DSKYENABLE	.EQU	FALSE		; ENABLES DSKY (DO NOT COMBINE WITH PPIDE)
0055+++0000             ;
0056+++0000             CRTACT		.EQU	FALSE		; ACTIVATE CRT (VDU,CVDU,PROPIO,ETC) AT STARTUP
0057+++0000             VDAEMU		.EQU	EMUTYP_ANSI	; VDA EMULATION: EMUTYP_[TTY|ANSI]
0058+++0000             ANSITRACE	.EQU	1		; ANSI DRIVER TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0059+++0000             ;
0060+++0000             HTIMENABLE	.EQU	FALSE		; ENABLE SIMH TIMER SUPPORT
0061+++0000             SIMRTCENABLE	.EQU	FALSE		; ENABLE SIMH CLOCK DRIVER (SIMRTC.ASM)
0062+++0000             ;
0063+++0000             DSRTCENABLE	.EQU	TRUE		; DSRTC: ENABLE DS-1302 CLOCK DRIVER (DSRTC.ASM)
0064+++0000             DSRTCMODE	.EQU	DSRTCMODE_STD	; DSRTC: OPERATING MODE: DSRTC_[STD|MFPIC]
0065+++0000             DSRTCCHG	.EQU	FALSE		; DSRTC: FORCE BATTERY CHARGE ON (USE WITH CAUTION!!!)
0066+++0000             ;
0067+++0000             BQRTCENABLE	.EQU	FALSE		; BQRTC: ENABLE BQ4845 CLOCK DRIVER (BQRTC.ASM)
0068+++0000             BQRTC_BASE	.EQU	$50		; BQRTC: I/O BASE ADDRESS
0069+++0000             ;
0070+++0000             UARTENABLE	.EQU	FALSE		; UART: ENABLE 8250/16550-LIKE SERIAL DRIVER (UART.ASM)
0071+++0000             ;
0072+++0000             ASCIENABLE	.EQU	FALSE		; ASCI: ENABLE Z180 ASCI SERIAL DRIVER (ASCI.ASM)
0073+++0000             ;
0074+++0000             ACIAENABLE	.EQU	TRUE		; ACIA: ENABLE MOTOROLA 6850 ACIA DRIVER (ACIA.ASM)
0075+++0000             ACIADEBUG	.EQU	FALSE		; ACIA: ENABLE DEBUG OUTPUT
0076+++0000             ACIACNT		.EQU	1		; ACIA: NUMBER OF CHIPS TO DETECT (1-2)
0077+++0000             ACIA0BASE	.EQU	$80		; ACIA 0: REGISTERS BASE ADR
0078+++0000             ACIA0DIV	.EQU	1		; ACIA 0: SERIAL CLOCK DIVIDER
0079+++0000             ACIA0CFG	.EQU	DEFSERCFG	; ACIA 0: SERIAL LINE CONFIG  (SEE STD.ASM)
0080+++0000             ACIA1BASE	.EQU	$40		; ACIA 1: REGISTERS BASE ADR
0081+++0000             ACIA1DIV	.EQU	1		; ACIA 1: SERIAL CLOCK DIVIDER
0082+++0000             ACIA1CFG	.EQU	DEFSERCFG	; ACIA 1: SERIAL LINE CONFIG  (SEE STD.ASM)
0083+++0000             ;
0084+++0000             SIOENABLE	.EQU	TRUE		; SIO: ENABLE ZILOG SIO SERIAL DRIVER (SIO.ASM)
0085+++0000             SIODEBUG	.EQU	FALSE		; SIO: ENABLE DEBUG OUTPUT
0086+++0000             SIOCNT		.EQU	2		; SIO: NUMBER OF CHIPS TO DETECT (1-2), 2 CHANNELS PER CHIP
0087+++0000             SIO0MODE	.EQU	SIOMODE_RC	; SIO 0: CHIP TYPE: SIOMODE_[RC|SMB|ZP|EZZ80]
0088+++0000             SIO0CTCC	.EQU	-1		; SIO 0: CTC CHANNEL CLOCK SCALER, (0-3), -1 FOR NONE
0089+++0000             SIO0BASE	.EQU	$80		; SIO 0: REGISTERS BASE ADR
0090+++0000             SIO0ADIV	.EQU	1		; SIO 0A: SERIAL CLOCK DIVIDER, RC2014/SMB=1, ZP=2/4/8/16/32/64/128/256 (X5)
0091+++0000             SIO0ACFG	.EQU	DEFSERCFG	; SIO 0A: SERIAL LINE CONFIG
0092+++0000             SIO0BDIV	.EQU	1		; SIO 0B: SERIAL CLOCK DIVIDER, RC2014/SMB=1, ZP=2/4/8/16/32/64/128/256 (X5)
0093+++0000             SIO0BCFG	.EQU	DEFSERCFG	; SIO 0B: SERIAL LINE CONFIG
0094+++0000             SIO1MODE	.EQU	SIOMODE_RC	; SIO 1: CHIP TYPE: SIOMODE_[RC|SMB|ZP|EZZ80]
0095+++0000             SIO1CTCC	.EQU	-1		; SIO 1: CTC CHANNEL CLOCK SCALER, (0-3), -1 FOR NONE
0096+++0000             SIO1BASE	.EQU	$84		; SIO 1: REGISTERS BASE ADR
0097+++0000             SIO1ADIV	.EQU	1		; SIO 1A: SERIAL CLOCK DIVIDER, RC2014/SMB=1, ZP=2/4/8/16/32/64/128/256 (X5)
0098+++0000             SIO1ACFG	.EQU	DEFSERCFG	; SIO 1A: SERIAL LINE CONFIG
0099+++0000             SIO1BDIV	.EQU	1		; SIO 1B: SERIAL CLOCK DIVIDER, RC2014/SMB=1, ZP=2/4/8/16/32/64/128/256 (X5)
0100+++0000             SIO1BCFG	.EQU	DEFSERCFG	; SIO 1B: SERIAL LINE CONFIG
0101+++0000             ;
0102+++0000             VDUENABLE	.EQU	FALSE		; VDU: ENABLE VDU VIDEO/KBD DRIVER (VDU.ASM)
0103+++0000             CVDUENABLE	.EQU	FALSE		; CVDU: ENABLE CVDU VIDEO/KBD DRIVER (CVDU.ASM)
0104+++0000             NECENABLE	.EQU	FALSE		; NEC: ENABLE NEC UPD7220 VIDEO/KBD DRIVER (NEC.ASM)
0105+++0000             TMSENABLE	.EQU	FALSE		; TMS: ENABLE TMS9918 VIDEO/KBD DRIVER (TMS.ASM)
0106+++0000             VGAENABLE	.EQU	FALSE		; VGA: ENABLE VGA VIDEO/KBD DRIVER (VGA.ASM)
0107+++0000             ;
0108+++0000             SPKENABLE	.EQU	FALSE		; SPK: ENABLE RTC LATCH IOBIT SOUND DRIVER (SPK.ASM)
0109+++0000             ;
0110+++0000             AYENABLE	.EQU	FALSE		; AY: ENABLE AY PSG SOUND DRIVER
0111+++0000             AYMODE		.EQU	AYMODE_RCZ80	; AY: DRIVER MODE: AYMODE_[SCG/N8/RCZ80/RCZ180]
0112+++0000             ;
0113+++0000             MDENABLE	.EQU	TRUE		; MD: ENABLE MEMORY (ROM/RAM) DISK DRIVER (MD.ASM)
0114+++0000             MDTRACE		.EQU	1		; MD: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0115+++0000             ;
0116+++0000             FDENABLE	.EQU	FALSE		; FD: ENABLE FLOPPY DISK DRIVER (FD.ASM)
0117+++0000             FDMODE		.EQU	FDMODE_RCWDC	; FD: DRIVER MODE: FDMODE_[DIO|ZETA|DIDE|N8|DIO3|DYNO]
0118+++0000             FDTRACE		.EQU	1		; FD: TRACE LEVEL (0=NO,1=FATAL,2=ERRORS,3=ALL)
0119+++0000             FDMEDIA		.EQU	FDM144		; FD: DEFAULT MEDIA FORMAT FDM[720|144|360|120|111]
0120+++0000             FDMEDIAALT	.EQU	FDM720		; FD: ALTERNATE MEDIA FORMAT FDM[720|144|360|120|111]
0121+++0000             FDMAUTO		.EQU	TRUE		; FD: AUTO SELECT DEFAULT/ALTERNATE MEDIA FORMATS
0122+++0000             ;
0123+++0000             RFENABLE	.EQU	FALSE		; RF: ENABLE RAM FLOPPY DRIVER
0124+++0000             ;
0125+++0000             IDEENABLE	.EQU	FALSE		; IDE: ENABLE IDE DISK DRIVER (IDE.ASM)
0126+++0000             IDETRACE	.EQU	1		; IDE: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0127+++0000             IDECNT		.EQU	1		; IDE: NUMBER OF IDE INTERFACES TO DETECT (1-3), 2 DRIVES EACH
0128+++0000             IDE0MODE	.EQU	IDEMODE_RC	; IDE 0: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0129+++0000             IDE0BASE	.EQU	$10		; IDE 0: IO BASE ADDRESS
0130+++0000             IDE0DATLO	.EQU	$00		; IDE 0: DATA LO PORT FOR 16-BIT I/O
0131+++0000             IDE0DATHI	.EQU	$00		; IDE 0: DATA HI PORT FOR 16-BIT I/O
0132+++0000             IDE0A8BIT	.EQU	TRUE		; IDE 0A (MASTER): 8 BIT XFER
0133+++0000             IDE0B8BIT	.EQU	TRUE		; IDE 0B (MASTER): 8 BIT XFER
0134+++0000             IDE1MODE	.EQU	IDEMODE_NONE	; IDE 1: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0135+++0000             IDE1BASE	.EQU	$00		; IDE 1: IO BASE ADDRESS
0136+++0000             IDE1DATLO	.EQU	$00		; IDE 1: DATA LO PORT FOR 16-BIT I/O
0137+++0000             IDE1DATHI	.EQU	$00		; IDE 1: DATA HI PORT FOR 16-BIT I/O
0138+++0000             IDE1A8BIT	.EQU	TRUE		; IDE 1A (MASTER): 8 BIT XFER
0139+++0000             IDE1B8BIT	.EQU	TRUE		; IDE 1B (MASTER): 8 BIT XFER
0140+++0000             IDE2MODE	.EQU	IDEMODE_NONE	; IDE 2: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0141+++0000             IDE2BASE	.EQU	$00		; IDE 2: IO BASE ADDRESS
0142+++0000             IDE2DATLO	.EQU	$00		; IDE 2: DATA LO PORT FOR 16-BIT I/O
0143+++0000             IDE2DATHI	.EQU	$00		; IDE 2: DATA HI PORT FOR 16-BIT I/O
0144+++0000             IDE2A8BIT	.EQU	TRUE		; IDE 2A (MASTER): 8 BIT XFER
0145+++0000             IDE2B8BIT	.EQU	TRUE		; IDE 2B (MASTER): 8 BIT XFER
0146+++0000             ;
0147+++0000             PPIDEENABLE	.EQU	FALSE		; PPIDE: ENABLE PARALLEL PORT IDE DISK DRIVER (PPIDE.ASM)
0148+++0000             PPIDETRACE	.EQU	1		; PPIDE: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0149+++0000             PPIDECNT	.EQU	1		; PPIDE: NUMBER OF PPI CHIPS TO DETECT (1-3), 2 DRIVES PER CHIP
0150+++0000             PPIDE0BASE	.EQU	$20		; PPIDE 0: PPI REGISTERS BASE ADR
0151+++0000             PPIDE0A8BIT	.EQU	FALSE		; PPIDE 0A (MASTER): 8 BIT XFER
0152+++0000             PPIDE0B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0153+++0000             PPIDE1BASE	.EQU	$00		; PPIDE 1: PPI REGISTERS BASE ADR
0154+++0000             PPIDE1A8BIT	.EQU	FALSE		; PPIDE 1A (MASTER): 8 BIT XFER
0155+++0000             PPIDE1B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0156+++0000             PPIDE2BASE	.EQU	$00		; PPIDE 2: PPI REGISTERS BASE ADR
0157+++0000             PPIDE2A8BIT	.EQU	FALSE		; PPIDE 2A (MASTER): 8 BIT XFER
0158+++0000             PPIDE2B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0159+++0000             ;
0160+++0000             SDENABLE	.EQU	FALSE		; SD: ENABLE SD CARD DISK DRIVER (SD.ASM)
0161+++0000             SDMODE		.EQU	SDMODE_PPI	; SD: DRIVER MODE: SDMODE_[JUHA|N8|CSIO|PPI|UART|DSD|MK4|SC|MT]
0162+++0000             SDCNT		.EQU	1		; SD: NUMBER OF SD CARD DEVICES (1-2), FOR DSD & SC ONLY
0163+++0000             SDTRACE		.EQU	1		; SD: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0164+++0000             SDCSIOFAST	.EQU	FALSE		; SD: ENABLE TABLE-DRIVEN BIT INVERTER IN CSIO MODE
0165+++0000             ;
0166+++0000             PRPENABLE	.EQU	FALSE		; PRP: ENABLE ECB PROPELLER IO BOARD DRIVER (PRP.ASM)
0167+++0000             ;
0168+++0000             PPPENABLE	.EQU	FALSE		; PPP: ENABLE ZETA PARALLEL PORT PROPELLER BOARD DRIVER (PPP.ASM)
0169+++0000             ;
0170+++0000             HDSKENABLE	.EQU	FALSE		; HDSK: ENABLE SIMH HDSK DISK DRIVER (HDSK.ASM)
0171+++0000             ;
0172+++0000             PIO_4P		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR ECB 4P BOARD
0173+++0000             PIO_ZP		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR ECB ZILOG PERIPHERALS BOARD (PIO.ASM)
0174+++0000             PPI_SBC		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR 8255 CHIP
0175+++0000             ;
0176+++0000             UFENABLE	.EQU	FALSE		; UF: ENABLE ECB USB FIFO DRIVER (UF.ASM)
0026+++0000             ;
0027+++0000             ;CPUOSC		.SET	7372800		; CPU OSC FREQ IN MHZ
0028+++0000             ;
0029+++0000             ACIAENABLE	.SET	TRUE		; ACIA: ENABLE MOTOROLA 6850 ACIA DRIVER (ACIA.ASM)
0030+++0000             ;
0031+++0000             SIOENABLE	.SET	TRUE		; SIO: ENABLE ZILOG SIO SERIAL DRIVER (SIO.ASM)
0032+++0000             ;
0033+++0000             FDENABLE	.SET	FALSE		; FD: ENABLE FLOPPY DISK DRIVER (FD.ASM)
0034+++0000             FDMODE		.SET	FDMODE_RCWDC	; FD: DRIVER MODE: FDMODE_[DIO|ZETA|DIDE|N8|DIO3]
0035+++0000             ;
0036+++0000             IDEENABLE	.SET	TRUE		; IDE: ENABLE IDE DISK DRIVER (IDE.ASM)
0037+++0000             ;
0038+++0000             PPIDEENABLE	.SET	FALSE		; PPIDE: ENABLE PARALLEL PORT IDE DISK DRIVER (PPIDE.ASM)
0008++ 0000             ;
0009++ 0000             
0010++ 0000             ;CPUOSC    .SET  7372800   ; CPU OSC FREQ IN MHZ
0011++ 0000             BID_ROM0        .EQU    $00
0012++ 0000             BID_RAM0        .EQU    $80
0013++ 0000             RAMSIZE         .EQU    512             ; SIZE OF RAM IN KB (MUST MATCH YOUR HARDWARE!!!)
0014++ 0000             
0318+  0000             ;
0319+  0000             #INCLUDE "hbios.inc"
0001++ 0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0000             ;
0003++ 0000             ; HBIOS FUNCTIONS
0004++ 0000             ;
0005++ 0000             BF_CIO		.EQU	$00
0006++ 0000             BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
0007++ 0000             BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
0008++ 0000             BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
0009++ 0000             BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
0010++ 0000             BF_CIOINIT	.EQU	BF_CIO + 4	; INIT/RESET DEVICE/LINE CONFIG
0011++ 0000             BF_CIOQUERY	.EQU	BF_CIO + 5	; REPORT DEVICE/LINE CONFIG
0012++ 0000             BF_CIODEVICE	.EQU	BF_CIO + 6	; REPORT DEVICE INFO
0013++ 0000             ;
0014++ 0000             BF_DIO		.EQU	$10
0015++ 0000             BF_DIOSTATUS	.EQU	BF_DIO + 0	; DISK STATUS
0016++ 0000             BF_DIORESET	.EQU	BF_DIO + 1	; DISK RESET
0017++ 0000             BF_DIOSEEK	.EQU	BF_DIO + 2	; DISK SEEK
0018++ 0000             BF_DIOREAD	.EQU	BF_DIO + 3	; DISK READ SECTORS
0019++ 0000             BF_DIOWRITE	.EQU	BF_DIO + 4	; DISK WRITE SECTORS
0020++ 0000             BF_DIOVERIFY	.EQU	BF_DIO + 5	; DISK VERIFY SECTORS
0021++ 0000             BF_DIOFORMAT	.EQU	BF_DIO + 6	; DISK FORMAT TRACK
0022++ 0000             BF_DIODEVICE	.EQU	BF_DIO + 7	; DISK DEVICE INFO REPORT
0023++ 0000             BF_DIOMEDIA	.EQU	BF_DIO + 8	; DISK MEDIA REPORT
0024++ 0000             BF_DIODEFMED	.EQU	BF_DIO + 9	; DEFINE DISK MEDIA
0025++ 0000             BF_DIOCAP	.EQU	BF_DIO + 10	; DISK CAPACITY REPORT
0026++ 0000             BF_DIOGEOM	.EQU	BF_DIO + 11	; DISK GEOMETRY REPORT
0027++ 0000             ;
0028++ 0000             BF_RTC		.EQU	$20
0029++ 0000             BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
0030++ 0000             BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
0031++ 0000             BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
0032++ 0000             BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
0033++ 0000             BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
0034++ 0000             BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
0035++ 0000             ;
0036++ 0000             BF_EMU		.EQU	$30		; DEPRECATED
0037++ 0000             ;
0038++ 0000             BF_VDA		.EQU	$40
0039++ 0000             BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
0040++ 0000             BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
0041++ 0000             BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
0042++ 0000             BF_VDADEV	.EQU	BF_VDA + 3	; DEVICE INFO
0043++ 0000             BF_VDASCS	.EQU	BF_VDA + 4	; SET CURSOR STYLE
0044++ 0000             BF_VDASCP	.EQU	BF_VDA + 5	; SET CURSOR POSITION
0045++ 0000             BF_VDASAT	.EQU	BF_VDA + 6	; SET CHARACTER ATTRIBUTE
0046++ 0000             BF_VDASCO	.EQU	BF_VDA + 7	; SET CHARACTER COLOR
0047++ 0000             BF_VDAWRC	.EQU	BF_VDA + 8	; WRITE CHARACTER
0048++ 0000             BF_VDAFIL	.EQU	BF_VDA + 9	; FILL
0049++ 0000             BF_VDACPY	.EQU	BF_VDA + 10	; COPY
0050++ 0000             BF_VDASCR	.EQU	BF_VDA + 11	; SCROLL
0051++ 0000             BF_VDAKST	.EQU	BF_VDA + 12	; GET KEYBOARD STATUS
0052++ 0000             BF_VDAKFL	.EQU	BF_VDA + 13	; FLUSH KEYBOARD BUFFER
0053++ 0000             BF_VDAKRD	.EQU	BF_VDA + 14	; READ KEYBOARD
0054++ 0000             ;
0055++ 0000             BF_SYS		.EQU	$F0
0056++ 0000             BF_SYSRESET	.EQU	BF_SYS + 0	; SOFT RESET HBIOS
0057++ 0000             BF_SYSVER	.EQU	BF_SYS + 1	; GET HBIOS VERSION
0058++ 0000             BF_SYSSETBNK	.EQU	BF_SYS + 2	; SET CURRENT BANK
0059++ 0000             BF_SYSGETBNK	.EQU	BF_SYS + 3	; GET CURRENT BANK
0060++ 0000             BF_SYSSETCPY	.EQU	BF_SYS + 4	; BANK MEMORY COPY SETUP
0061++ 0000             BF_SYSBNKCPY	.EQU	BF_SYS + 5	; BANK MEMORY COPY
0062++ 0000             BF_SYSALLOC	.EQU	BF_SYS + 6	; ALLOC HBIOS HEAP MEMORY
0063++ 0000             BF_SYSFREE	.EQU	BF_SYS + 7	; FREE HBIOS HEAP MEMORY
0064++ 0000             BF_SYSGET	.EQU	BF_SYS + 8	; GET HBIOS INFO
0065++ 0000             BF_SYSSET	.EQU	BF_SYS + 9	; SET HBIOS PARAMETERS
0066++ 0000             BF_SYSPEEK	.EQU	BF_SYS + 10	; GET A BYTE VALUE FROM ALT BANK
0067++ 0000             BF_SYSPOKE	.EQU	BF_SYS + 11	; SET A BYTE VALUE IN ALT BANK
0068++ 0000             BF_SYSINT	.EQU	BF_SYS + 12	; MANAGE INTERRUPT VECTORS
0069++ 0000             ;
0070++ 0000             BF_SYSGET_CIOCNT	.EQU	$00	; GET CHAR UNIT COUNT
0071++ 0000             BF_SYSGET_DIOCNT	.EQU	$10	; GET DISK UNIT COUNT
0072++ 0000             BF_SYSGET_VDACNT	.EQU	$40	; GET VDA UNIT COUNT
0073++ 0000             BF_SYSGET_TIMER		.EQU	$D0	; GET CURRENT TIMER VALUE
0074++ 0000             BF_SYSGET_SECS		.EQU	$D1	; GET CURRENT SECONDS VALUE
0075++ 0000             BF_SYSGET_BOOTINFO	.EQU	$E0	; GET BOOT INFORMATION
0076++ 0000             BF_SYSGET_CPUINFO	.EQU	$F0	; GET CPU INFORMATION
0077++ 0000             BF_SYSGET_MEMINFO	.EQU	$F1	; GET MEMORY CAPACTITY INFO
0078++ 0000             BF_SYSGET_BNKINFO	.EQU	$F2	; GET BANK ASSIGNMENT INFO
0079++ 0000             ;
0080++ 0000             BF_SYSSET_TIMER		.EQU	$D0	; SET TIMER VALUE
0081++ 0000             BF_SYSSET_SECS		.EQU	$D1	; SET SECONDS VALUE
0082++ 0000             BF_SYSSET_BOOTINFO	.EQU	$E0	; SET BOOT INFORMATION
0083++ 0000             ;
0084++ 0000             BF_SYSINT_INFO		.EQU	$00	; GET INTERRUPT SYSTEM INFO
0085++ 0000             BF_SYSINT_GET		.EQU	$10	; GET INT VECTOR ADDRESS
0086++ 0000             BF_SYSINT_SET		.EQU	$20	; SET INT VECTOR ADDRESS
0087++ 0000             ;
0088++ 0000             ; CHAR DEVICE IDS
0089++ 0000             ;
0090++ 0000             CIODEV_UART	.EQU	$00
0091++ 0000             CIODEV_ASCI	.EQU	$10
0092++ 0000             CIODEV_TERM	.EQU	$20
0093++ 0000             CIODEV_PRPCON	.EQU	$30
0094++ 0000             CIODEV_PPPCON	.EQU	$40
0095++ 0000             CIODEV_SIO	.EQU	$50
0096++ 0000             CIODEV_ACIA	.EQU	$60
0097++ 0000             CIODEV_PIO	.EQU	$70
0098++ 0000             CIODEV_UF	.EQU	$80
0099++ 0000             CIODEV_CONSOLE	.EQU	$D0
0100++ 0000             ;
0101++ 0000             ; SUB TYPES OF CHAR DEVICES
0102++ 0000             ;
0103++ 0000             ;00 RS-232
0104++ 0000             ;01 TERMINAL
0105++ 0000             ;02 PARALLEL PORT
0106++ 0000             ;03 UNUSED
0107++ 0000             ;
0108++ 0000             ; DISK DEVICE IDS
0109++ 0000             ;
0110++ 0000             DIODEV_MD	.EQU	$00
0111++ 0000             DIODEV_FD	.EQU	$10
0112++ 0000             DIODEV_RF	.EQU	$20
0113++ 0000             DIODEV_IDE	.EQU	$30
0114++ 0000             DIODEV_ATAPI	.EQU	$40
0115++ 0000             DIODEV_PPIDE	.EQU	$50
0116++ 0000             DIODEV_SD	.EQU	$60
0117++ 0000             DIODEV_PRPSD	.EQU	$70
0118++ 0000             DIODEV_PPPSD	.EQU	$80
0119++ 0000             DIODEV_HDSK	.EQU	$90
0120++ 0000             ;
0121++ 0000             ; VIDEO DEVICE IDS
0122++ 0000             ;
0123++ 0000             VDADEV_VDU	.EQU	$00		; ECB VDU - MOTOROLA 6545
0124++ 0000             VDADEV_CVDU	.EQU	$10		; ECB COLOR VDU - MOS 8563
0125++ 0000             VDADEV_NEC	.EQU	$20		; ECB UPD7220 - NEC UPD7220
0126++ 0000             VDADEV_TMS	.EQU	$30		; N8 ONBOARD VDA SUBSYSTEM - TMS 9918
0127++ 0000             VDADEV_VGA	.EQU	$40		; ECB VGA3 - HITACHI HD6445
0128++ 0000             ;;
0129++ 0000             ;; EMULATION TYPES - moved to std.asm
0130++ 0000             ;;
0131++ 0000             ;EMUTYP_NONE	.EQU	0		; NONE
0132++ 0000             ;EMUTYP_TTY	.EQU	1		; TTY
0133++ 0000             ;EMUTYP_ANSI	.EQU	2		; ANSI
0134++ 0000             ;	
0135++ 0000             ; HBIOS CONTROL BLOCK OFFSETS
0136++ 0000             ; WARNING: THESE OFFSETS WILL CHANGE SIGNIFICANTLY BETWEEN RELEASES
0137++ 0000             ;          IT IS STRONGLY RECOMMENDED THAT YOU DO NOT USE THEM!
0138++ 0000             ;
0139++ 0000             HCB_LOC		.EQU	$100		; LOCATION OF HCB IN HBIOS BANK
0140++ 0000             HCB_SIZ		.EQU	$100		; SIZE OF HCB DATA BLOCK
0141++ 0000             ;
0142++ 0000             HCB_MARKER	.EQU	$03		; MARKER ('W',~'W') (WORD)
0143++ 0000             HCB_VERSION	.EQU	$05		; HBIOS VERSION NUM
0144++ 0000             HCB_PLATFORM	.EQU	$07		; PLATFORM ID
0145++ 0000             HCB_CPUMHZ	.EQU	$08		; CPU SPEED IN MHZ (BYTE)
0146++ 0000             HCB_CPUKHZ	.EQU	$09		; CPU SPEED IN KHZ (WORD)
0147++ 0000             HCB_RAMBANKS	.EQU	$0B		; TOTAL SIZE OF RAM IN 32K BANKS (BYTE)
0148++ 0000             HCB_ROMBANKS	.EQU	$0C		; TOTAL SIZE OF ROM IN 32K BANKS (BYTE)
0149++ 0000             HCB_BOOTVOL	.EQU	$0D		; BOOT VOLUME, MSB=DEV/UNIT, LSB=LU (WORD)
0150++ 0000             HCB_BOOTBID	.EQU	$0F		; BANK ID OF ROM PAGE BOOTED (BYTE)
0151++ 0000             HCB_SERDEV	.EQU	$10		; PRIMARY SERIAL DEVICE/UNIT (BYTE)
0152++ 0000             HCB_CRTDEV	.EQU	$11		; CRT DISPLAY DEVICE/UNIT (BYTE)
0153++ 0000             HCB_CONDEV	.EQU	$12		; ACTIVE CONSOLE DEVICE/UNIT (BYTE)
0154++ 0000             ;HCB_CUREMU	.EQU	$13		; CURRENT VDA TERMINAL EMULATION (DEPRECATED)
0155++ 0000             ;HCB_CURVDA	.EQU	$14		; CURRENT VDA TARGET FOR EMULATION (DEPRECATED)
0156++ 0000             ;
0157++ 0000             HCB_HEAP	.EQU	$20		; DWORD ADDRESS OF START OF HEAP
0158++ 0000             HCB_HEAPTOP	.EQU	$22		; DWORD ADDRESS OF TOP OF HEAP
0159++ 0000             ;
0160++ 0000             ; MEMORY BANK IDS (ONE BYTE EACH)
0161++ 0000             HCB_BIDCOM	.EQU	$D8		; COMMON BANK (UPPER 32K)
0162++ 0000             HCB_BIDUSR	.EQU	$D9		; USER BANK (TPA)
0163++ 0000             HCB_BIDBIOS	.EQU	$DA		; BIOS BANK (HBIOS, UBIOS)
0164++ 0000             HCB_BIDAUX	.EQU	$DB		; AUX BANK (BPBIOS)
0165++ 0000             HCB_BIDRAMD0	.EQU	$DC		; FIRST BANK OF RAM DRIVE
0166++ 0000             HCB_BIDRAMDN	.EQU	$DD		; LAST BANK OF RAM DRIVE
0167++ 0000             HCB_BIDROMD0	.EQU	$DE		; FIRST BANK OF ROM DRIVE
0168++ 0000             HCB_BIDROMDN	.EQU	$DF		; LAST BANK OF ROM DRIVE
0169++ 0000             ;
0170++ 0000             ; HBIOS PROXY COMMON DATA BLOCK
0171++ 0000             ; EXACTLY 32 BYTES AT $FFE0-$FFFF
0172++ 0000             ;
0173++ 0000             HBX_XFC		.EQU	$10000 - $20		; HBIOS PROXY INTERFACE AREA, 32 BYTES FIXED
0174++ 0000             ;
0175++ 0000             HBX_XFCDAT	.EQU	HBX_XFC			; DATA PORTION OF HBIOS PROXY INTERFACE AREA
0176++ 0000             HB_CURBNK	.EQU	HBX_XFCDAT + 0		; CURRENTLY ACTIVE LOW MEMORY BANK ID
0177++ 0000             HB_INVBNK	.EQU	HBX_XFCDAT + 1		; BANK ACTIVE AT TIME OF HBIOS CALL INVOCATION
0178++ 0000             HB_SRCADR	.EQU	HBX_XFCDAT + 2		; BNKCPY: DESTINATION BANK ID
0179++ 0000             HB_SRCBNK	.EQU	HBX_XFCDAT + 4		; BNKCPY: SOURCE BANK ID
0180++ 0000             HB_DSTADR	.EQU	HBX_XFCDAT + 5		; BNKCPY: DESTINATION ADDRESS
0181++ 0000             HB_DSTBNK	.EQU	HBX_XFCDAT + 7		; BNKCPY: SOURCE ADDRESS
0182++ 0000             HB_CPYLEN	.EQU	HBX_XFCDAT + 8		; BNKCPY: COPY LENGTH
0183++ 0000             ;
0184++ 0000             HBX_XFCFNS	.EQU	HBX_XFC + $10		; JUMP TABLE PORTION OF HBIOS PROXY INTERFACE AREA
0185++ 0000             HB_INVOKE	.EQU	HBX_XFCFNS + (0 * 3)	; INVOKE HBIOS FUNCTION
0186++ 0000             HB_BNKSEL	.EQU	HBX_XFCFNS + (1 * 3)	; SELECT LOW MEMORY BANK ID
0187++ 0000             HB_BNKCPY	.EQU	HBX_XFCFNS + (2 * 3)	; INTERBANK MEMORY COPY
0188++ 0000             HB_BNKCALL	.EQU	HBX_XFCFNS + (3 * 3)	; INTERBANK FUNCTION CALL
0189++ 0000             ;HB_LOC		.EQU	HBX_XFCFNS + 12		; ADDRESS OF HBIOS PROXY START (DEPRECATED)
0190++ 0000             HB_IDENT	.EQU	HBX_XFCFNS + 14		; POINTER TO HBIOS IDENT DATA BLOCK
0320+  0000             
0321+  0000             TICKSPERSEC	.EQU	50
0322+  0000             ;
0323+  0000             ; MEMORY BANK CONFIGURATION
0324+  0000             ;
0325+  0000             BID_ROM0	.EQU	$00
0326+  0000             BID_RAM0	.EQU	$80
0327+  0000             
0328+  0000             BID_ROMN	.EQU	(BID_ROM0 + ((ROMSIZE / 32) - 1))
0329+  0000             BID_RAMN	.EQU	(BID_RAM0 + ((RAMSIZE / 32) - 1))
0330+  0000             
0331+  0000             BID_BOOT	.EQU	BID_ROM0	; BOOT BANK
0332+  0000             ;BID_BIOSIMG	.EQU	BID_ROM0 + 1	; BIOS IMAGE BANK
0333+  0000             ;BID_OSIMG	.EQU	BID_ROM0 + 2	; ROM LOADER AND IMAGES BANK
0334+  0000             BID_IMG0	.EQU	BID_ROM0 + 1	; ROM LOADER AND FIRST IMAGES BANK
0335+  0000             BID_IMG1	.EQU	BID_ROM0 + 2	; SECOND IMAGES BANK
0336+  0000             BID_FSFAT	.EQU	BID_ROM0 + 3	; FAT FILESYSTEM DRIVER BANK
0337+  0000             BID_ROMD0	.EQU	BID_ROM0 + 4	; FIRST ROM DRIVE BANK
0338+  0000             BID_ROMDN	.EQU	BID_ROMN	; LAST ROM DRIVE BANK
0339+  0000             
0340+  0000             BID_RAMD0	.EQU	BID_RAM0	; FIRST RAM DRIVE BANK
0341+  0000             BID_RAMDN	.EQU	BID_RAMN - 4	; LAST RAM DRIVE BANK
0342+  0000             BID_AUX		.EQU	BID_RAMN - 3	; AUX BANK (BPBIOS, ETC.)
0343+  0000             BID_BIOS	.EQU	BID_RAMN - 2	; BIOS BANK
0344+  0000             BID_USR		.EQU	BID_RAMN - 1	; USER BANK (CP/M TPA, ETC.)
0345+  0000             BID_COM		.EQU	BID_RAMN	; COMMON BANK, UPPER 32K
0346+  0000             ;
0347+  0000             ; MEMORY LAYOUT
0348+  0000             ;
0349+  0000             SYS_SIZ		.EQU	$3000			; COMBINED SIZE OF SYSTEM AREA (OS + HBIOS PROXY)
0350+  0000             HBBUF_SIZ	.EQU	1024			; INVARIANT HBIOS PHYSICAL DISK BUFFER, 1K
0351+  0000             HBX_SIZ		.EQU	$200			; HBIOS PROXY SIZE (SUBJECT TO CHANGE)
0352+  0000             CPM_SIZ		.EQU	SYS_SIZ - HBX_SIZ	; NET SIZE OF ALL OS COMPONENTS (EXCLUDING HBIOS PROXY)
0353+  0000             CCP_SIZ		.EQU	$800			; INVARIANT SIZE OF CCP
0354+  0000             BDOS_SIZ	.EQU	$E00			; INVARIANT SIZE OF BDOS
0355+  0000             CBIOS_SIZ	.EQU	CPM_SIZ - CCP_SIZ - BDOS_SIZ	; CBIOS IS THE REMAINDER
0356+  0000             
0357+  0000             MEMTOP		.EQU	$10000			; INVARIANT TOP OF Z80 ADDRESSABLE MEMORY
0358+  0000             BNKTOP		.EQU	$8000			; BANK MEMORY BARRIER
0359+  0000             
0360+  0000             HBX_IMG		.EQU	$200			; LOC OF HBX IMAGE IN HBIOS IMAGE BANK
0361+  0000             
0362+  0000             HBBUF_END	.EQU	BNKTOP			; END OF PHYSICAL DISK BUFFER IN HBIOS
0363+  0000             HBBUF_LOC	.EQU	HBBUF_END - HBBUF_SIZ	; START OF PHYSICAL DISK BUFFER
0364+  0000             HBX_END		.EQU	MEMTOP			; END OF HBIOS PROXY
0365+  0000             HBX_LOC		.EQU	HBX_END - HBX_SIZ	; START OF HBIOS PROXY
0366+  0000             CPM_END		.EQU	HBX_LOC			; END OF CPM COMPONENTS (INCLUDING CBIOS)
0367+  0000             CPM_LOC		.EQU	CPM_END - CPM_SIZ	; START OF CPM COMPONENTS
0368+  0000             CBIOS_END	.EQU	HBX_LOC			; END OF CBIOS
0369+  0000             CBIOS_LOC	.EQU	CBIOS_END - CBIOS_SIZ	; START OF CBIOS
0370+  0000             
0371+  0000             CPM_ENT		.EQU	CBIOS_LOC		; CPM ENTRY POINT (IN CBIOS)
0372+  0000             
0373+  0000             LDR_SIZ		.EQU	$0E00
0374+  0000             
0375+  0000             MON_LOC		.EQU	$F000			; LOCATION OF MONITOR FOR RUNNING SYSTEM
0376+  0000             MON_SIZ		.EQU	$0E00			; SIZE OF MONITOR BINARY IMAGE
0377+  0000             MON_END		.EQU	MON_LOC + MON_SIZ	; END OF MONITOR
0378+  0000             
0379+  0000             BAS_LOC		.EQU	$0200			; NASCOM BASIC
0380+  0000             BAS_SIZ		.EQU	$2000
0381+  0000             BAS_END		.EQU	BAS_LOC + BAS_SIZ
0382+  0000             
0383+  0000             TBC_LOC		.EQU	$0A00			; TASTYBASIC
0384+  0000             TBC_SIZ		.EQU	$0900
0385+  0000             TBC_END		.EQU	TBC_LOC + TBC_SIZ
0386+  0000             
0387+  0000             EGG_LOC		.EQU	$0A00			; EASTER EGG
0388+  0000             EGG_SIZ		.EQU	$0200
0389+  0000             EGG_END		.EQU	EGG_LOC + EGG_SIZ
0390+  0000             
0391+  0000             FTH_LOC		.EQU	$0200			; CAMEL FORTH
0392+  0000             FTH_SIZ		.EQU	$1700
0393+  0000             FTH_END		.EQU	FTH_LOC + FTH_SIZ
0394+  0000             
0395+  0000             GAM_LOC		.EQU	$0200			; GAME 2048
0396+  0000             GAM_SIZ		.EQU	$0900
0397+  0000             GAM_END		.EQU	GAM_LOC + GAM_SIZ
0398+  0000             
0399+  0000             USR_LOC		.EQU	$0200			; USER
0400+  0000             USR_SIZ		.EQU	$1000
0401+  0000             USR_END		.EQU	USR_LOC + USR_SIZ
0402+  0000             
0403+  0000             MON_DSKY	.EQU	MON_LOC + (0 * 3)	; MONITOR ENTRY (DSKY)
0404+  0000             MON_SERIAL	.EQU	MON_LOC + (1 * 3)	; MONITOR ENTRY (SERIAL PORT)
0405+  0000             ;
0406+  0000             ;
0407+  0000             #DEFINE	PRTC(C)	CALL PRTCH \ .DB C			; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0408+  0000             #DEFINE	PRTS(S)	CALL PRTSTRD \ .TEXT S			; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0409+  0000             #DEFINE	PRTX(X) CALL PRTSTRI \ .DW X			; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0410+  0000             ;
0411+  0000             #DEFINE	XIO_PRTC(C)	CALL XIO_PRTCH \ .DB C		; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0412+  0000             #DEFINE	XIO_PRTS(S)	CALL XIO_PRTSTRD \ .DB S	; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0413+  0000             #DEFINE	XIO_PRTX(X)	CALL XIO_PRTSTRI \ .DW X	; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0026   0000             #include "tracing.inc"
0001+  0000             
0002+  0000             #define pushAll() 	PUSH	BC
0003+  0000             #defcont \		PUSH 	DE
0004+  0000             #defcont \		PUSH 	AF
0005+  0000             #defcont \		PUSH 	HL
0006+  0000             
0007+  0000             #define popAll() 	POP	HL
0008+  0000             #defcont \		POP 	AF
0009+  0000             #defcont \		POP 	DE
0010+  0000             #defcont \		POP 	BC
0011+  0000             
0012+  0000             #define trace(marker) 	pushAll()
0013+  0000             #defcont \		cpm.cWriteStr(marker)
0014+  0000             #defcont \ 		popAll()
0015+  0000             
0027   0000             
0028   0000             ABBRERR .EQU    FALSE           ; Choose between long error message and abbreviated error messages.
0029   0000             VT100   .EQU    TRUE            ; Use VT100 escape codes for CLS
0030   0000             ;
0031   0000             ; GENERAL EQUATES
0032   0000             ;
0033   0000             CTRLC   .EQU    03H             ; Control "C"
0034   0000             CTRLG   .EQU    07H             ; Control "G"
0035   0000             BKSP    .EQU    08H             ; Back space
0036   0000             LF      .EQU    0AH             ; Line feed
0037   0000             CS      .EQU    0CH             ; Clear screen
0038   0000             CR      .EQU    0DH             ; Carriage return
0039   0000             CTRLO   .EQU    0FH             ; Control "O"
0040   0000             CTRLQ   .EQU    11H             ; Control "Q"
0041   0000             CTRLR   .EQU    12H             ; Control "R"
0042   0000             CTRLS   .EQU    13H             ; Control "S"
0043   0000             CTRLU   .EQU    15H             ; Control "U"
0044   0000             ESC     .EQU    1BH             ; Escape
0045   0000             DEL     .EQU    7FH             ; Delete
0046   0000             
0047   0000             ;
0048   0000             ; BASIC WORK SPACE LOCATIONS
0049   0000             ;
0050   0000             ; 0200H - 2000H BASIC EXECUTABLE
0051   0000             ; 2000H - 2090H STACK
0052   0000             ; 2090H - 20F8H BASIC EXECUTABLE VARAIABLES / WORKSPACE
0053   0000             ; 20F9H -       BASIC PROGRAM START
0054   0000             
0055   0000             WRKSPC  .EQU    BAS_END+90H                     ; WAS 4090H             ; BASIC Work space
0056   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0057   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0058   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0059   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0060   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0061   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0062   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0063   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0064   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0065   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0066   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0067   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0068   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0069   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0070   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0071   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0072   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0073   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0074   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0075   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0076   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0077   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0078   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0079   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0080   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0081   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0082   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0083   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0084   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0085   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0086   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0087   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0088   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0089   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0090   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0091   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0092   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0093   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0094   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0095   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0096   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0097   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0098   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0099   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0100   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0101   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0102   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0103   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0104   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0105   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0106   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0107   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0108   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0109   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0110   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0111   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0112   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0113   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0114   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0115   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0116   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0117   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0118   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0119   0000             
0120   0000             
0121   0000             ; BASIC ERROR CODE VALUES
0122   0000             
0123   0000             NF      .EQU    00H             ; NEXT without FOR
0124   0000             SN      .EQU    02H             ; Syntax error
0125   0000             RG      .EQU    04H             ; RETURN without GOSUB
0126   0000             OD      .EQU    06H             ; Out of DATA
0127   0000             FC      .EQU    08H             ; Function call error
0128   0000             OV      .EQU    0AH             ; Overflow
0129   0000             OM      .EQU    0CH             ; Out of memory
0130   0000             UL      .EQU    0EH             ; Undefined line number
0131   0000             BS      .EQU    10H             ; Bad subscript
0132   0000             DD      .EQU    12H             ; Re-DIMensioned array
0133   0000             DZ      .EQU    14H             ; Division by zero (/0)
0134   0000             ID      .EQU    16H             ; Illegal direct
0135   0000             TM      .EQU    18H             ; Type miss-match
0136   0000             OS      .EQU    1AH             ; Out of string space
0137   0000             LS      .EQU    1CH             ; String too long
0138   0000             ST      .EQU    1EH             ; String formula too complex
0139   0000             CN      .EQU    20H             ; Can't CONTinue
0140   0000             UF      .EQU    22H             ; UnDEFined FN function
0141   0000             MO      .EQU    24H             ; Missing operand
0142   0000             HX      .EQU    26H             ; HEX error
0143   0000             BN      .EQU    28H             ; BIN error
0144   0000             
0145   0100             	.ORG    0100H ;BAS_LOC          ; WAS 02000H
0146   0100             
0147   0100 C3 06 01    COLD:   JP      STARTB          ; Jump for cold start
0148   0103 C3 68 01    WARM:   JP      WARMST          ; Jump for warm start
0149   0106             STARTB:
0150   0106 DD 21 00 00 	LD      IX,0            ; Flag cold start
0151   010A C3 11 01    	JP      CSTART          ; Jump to initialise
0152   010D             
0153   010D D1 0A       	.WORD   DEINT           ; Get integer -32768 to 32767
0154   010F 47 12       	.WORD   ABPASS          ; Return integer in AB
0155   0111             
0156   0111             CSTART:
0157   0111 21 90 22    	LD	HL,WRKSPC       ; Start of workspace RAM
0158   0114 F9          	LD      SP,HL           ; Set up a temporary stack
0159   0115 C3 88 1E    	JP      INITST          ; Go to initialise
0160   0118             
0161   0118 11 C3 04    INIT:   LD      DE,INITAB       ; Initialise workspace
0162   011B 06 63       	LD      B,INITBE-INITAB+3; Bytes to copy
0163   011D 21 90 22    	LD      HL,WRKSPC       ; Into workspace RAM
0164   0120 1A          COPY:   LD      A,(DE)          ; Get source
0165   0121 77          	LD      (HL),A          ; To destination
0166   0122 23          	INC     HL              ; Next destination
0167   0123 13          	INC     DE              ; Next source
0168   0124 05          	DEC     B               ; Count bytes
0169   0125 C2 20 01    	JP      NZ,COPY         ; More to move
0170   0128 F9          	LD      SP,HL           ; Temporary stack
0171   0129             
0172   0129 CD CA 06    	CALL    CLREG           ; Clear registers and stack
0173   012C CD C7 0C    	CALL    PRNTCRLF        ; Output CRLF
0174   012F 32 3A 23    	LD      (BUFFER+72+1),A ; Mark end of buffer
0175   0132 32 89 23    	LD      (PROGST),A      ; Initialise program area
0176   0135             
0177   0135             ;MSIZE:  LD      HL,MEMMSG       ; Point to message
0178   0135             ;        CALL    PRS             ; Output "Memory size"
0179   0135             ;        CALL    PROMPT          ; Get input with '?'
0180   0135             ;        CALL    GETCHR          ; Get next character
0181   0135             ;        OR      A               ; Set flags
0182   0135             ;        JP      NZ,TSTMEM       ; If number - Test if RAM there
0183   0135             ;        LD      HL,STLOOK       ; Point to start of RAM
0184   0135             ;MLOOP:  INC     HL              ; Next byte
0185   0135             ;;        LD      A,H             ; Above address FFFF ?
0186   0135             ;;;       OR      L
0187   0135             ;       LD      A,H             ; Memory top set below HBIOS Proxy @ FE00
0188   0135             ;       CP      $FD
0189   0135             ;        JP      Z,SETTOP        ; Yes - 64K RAM
0190   0135             ;        LD      A,(HL)          ; Get contents
0191   0135             ;        LD      B,A             ; Save it
0192   0135             ;        CPL                     ; Flip all bits
0193   0135             ;        LD      (HL),A          ; Put it back
0194   0135             ;        CP      (HL)            ; RAM there if same
0195   0135             ;        LD      (HL),B          ; Restore old contents
0196   0135             ;        JP      Z,MLOOP         ; If RAM - test next byte
0197   0135             ;        JP      SETTOP          ; Top of RAM found
0198   0135             ;
0199   0135             ;TSTMEM: CALL    ATOH            ; Get high memory into DE
0200   0135             ;        OR      A               ; Set flags on last byte
0201   0135             ;        JP      NZ,SNERR        ; ?SN Error if bad character
0202   0135             ;        EX      DE,HL           ; Address into HL
0203   0135             ;        DEC     HL              ; Back one byte
0204   0135             ;        LD      A,11011001B     ; Test byte
0205   0135             ;        LD      B,(HL)          ; Get old contents
0206   0135             ;        LD      (HL),A          ; Load test byte
0207   0135             ;        CP      (HL)            ; RAM there if same
0208   0135             ;        LD      (HL),B          ; Restore old contents
0209   0135             ;        JP      NZ,MSIZE        ; Ask again if no RAM
0210   0135             ;
0211   0135             ;SETTOP: DEC     HL              ; Back one byte
0212   0135             ;        LD      DE,STLOOK-1     ; See if enough RAM
0213   0135             ;        CALL    CPDEHL          ; Compare DE with HL
0214   0135             ;        JP      C,MSIZE         ; Ask again if not enough RAM
0215   0135 11 CE FF    	LD      DE,0-50         ; 50 Bytes string space
0216   0138 21 00 FE    	LD      HL, 0FE00H
0217   013B 22 3F 23    	LD      (LSTRAM),HL     ; Save last available RAM
0218   013E 19          	ADD     HL,DE           ; Allocate string space
0219   013F 22 EA 22    	LD      (STRSPC),HL     ; Save string space
0220   0142 CD A5 06    	CALL    CLRPTR          ; Clear program area
0221   0145 2A EA 22    	LD      HL,(STRSPC)     ; Get end of memory
0222   0148 11 EF FF    	LD      DE,0-17         ; Offset for free bytes
0223   014B 19          	ADD     HL,DE           ; Adjust HL
0224   014C 11 89 23    	LD      DE,PROGST       ; Start of program text
0225   014F 7D          	LD      A,L             ; Get LSB
0226   0150 93          	SUB     E               ; Adjust it
0227   0151 6F          	LD      L,A             ; Re-save
0228   0152 7C          	LD      A,H             ; Get MSB
0229   0153 9A          	SBC     A,D             ; Adjust it
0230   0154 67          	LD      H,A             ; Re-save
0231   0155 E5          	PUSH    HL              ; Save bytes free
0232   0156             
0233   0156 11 80 01    	cpm.cWriteStr(SIGNON)
0233   0159 0E 09       
0233   015B CD 05 00    
0234   015E             
0235   015E E1          	POP     HL              ; Get bytes free back
0236   015F CD 08 1A    	CALL    PRNTHL          ; Output amount of free memory
0237   0162 21 71 01    	LD      HL,BFREE        ; " Bytes free" message
0238   0165 CD 65 13    	CALL    PRS             ; Output string
0239   0168             
0240   0168 31 F6 22    WARMST: LD      SP,STACK        ; Temporary stack
0241   016B CD CA 06    BRKRET: CALL    CLREG           ; Clear registers and stack
0242   016E C3 E3 05    	JP      PRNTOK          ; Go to get command line
0243   0171             
0244   0171 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0244   0175 65 73 20 66 
0244   0179 72 65 65 0D 
0244   017D 0A 00 00 
0245   0180             
0246   0180 44 69 6E 6F SIGNON: .BYTE   "Dinotron BASIC Ver 0.0.7",CR,LF
0246   0184 74 72 6F 6E 
0246   0188 20 42 41 53 
0246   018C 49 43 20 56 
0246   0190 65 72 20 30 
0246   0194 2E 30 2E 37 
0246   0198 0D 0A 
0247   019A 43 6F 70 79 	.BYTE   "Copyright ",40,"C",41
0247   019E 72 69 67 68 
0247   01A2 74 20 28 43 
0247   01A6 29 
0248   01A7 20 31 39 37 	.BYTE   " 1978 by Microsoft",CR,LF,"$",0,0
0248   01AB 38 20 62 79 
0248   01AF 20 4D 69 63 
0248   01B3 72 6F 73 6F 
0248   01B7 66 74 0D 0A 
0248   01BB 24 00 00 
0249   01BE             
0250   01BE 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0250   01C2 72 79 20 74 
0250   01C6 6F 70 00 
0251   01C9             
0252   01C9             ; FUNCTION ADDRESS TABLE
0253   01C9             
0254   01C9 7D 18       FNCTAB: .WORD   SGN
0255   01CB 41 19       	.WORD   INT
0256   01CD 93 18       	.WORD   ABS
0257   01CF 93 22       	.WORD   USR
0258   01D1 25 12       	.WORD   FRE
0259   01D3 AA 15       	.WORD   INP
0260   01D5 53 12       	.WORD   POS
0261   01D7 07 1B       	.WORD   SQR
0262   01D9 E6 1B       	.WORD   RND
0263   01DB 22 17       	.WORD   LOG
0264   01DD 55 1B       	.WORD   EXP
0265   01DF 5B 1C       	.WORD   COS
0266   01E1 61 1C       	.WORD   SIN
0267   01E3 C2 1C       	.WORD   TAN
0268   01E5 D7 1C       	.WORD   ATN
0269   01E7 FE 15       	.WORD   PEEK
0270   01E9 5C 1D       	.WORD   DEEK
0271   01EB E1 22       	.WORD   POINT
0272   01ED D7 14       	.WORD   LEN
0273   01EF EF 12       	.WORD   STR
0274   01F1 71 15       	.WORD   VAL
0275   01F3 E6 14       	.WORD   ASC
0276   01F5 F7 14       	.WORD   CHR
0277   01F7 7E 1D       	.WORD   HEX
0278   01F9 11 1E       	.WORD   BIN
0279   01FB 07 15       	.WORD   LEFT
0280   01FD 37 15       	.WORD   RIGHT
0281   01FF 41 15       	.WORD   MID
0282   0201             
0283   0201             ; RESERVED WORD LIST
0284   0201             
0285   0201 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"            ; PEND:
0286   0204 C6 4F 52    	.BYTE   'F'+80H,"OR"            ; FOR:
0287   0207 CE 45 58 54 	.BYTE   'N'+80H,"EXT"           ; NEXT:
0288   020B C4 41 54 41 	.BYTE   'D'+80H,"ATA"           ; DATA:
0289   020F C9 4E 50 55 	.BYTE   'I'+80H,"NPUT"          ; INPUT:
0289   0213 54 
0290   0214 C4 49 4D    	.BYTE   'D'+80H,"IM"            ; DIM:
0291   0217 D2 45 41 44 	.BYTE   'R'+80H,"EAD"           ; READ:
0292   021B CC 45 54    	.BYTE   'L'+80H,"ET"            ; SET:
0293   021E C7 4F 54 4F 	.BYTE   'G'+80H,"OTO"           ; GOTO:
0294   0222 D2 55 4E    	.BYTE   'R'+80H,"UN"            ; RUN:
0295   0225 C9 46       	.BYTE   'I'+80H,"F"             ; IF:
0296   0227 D2 45 53 54 	.BYTE   'R'+80H,"ESTORE"        ; RESTOR:
0296   022B 4F 52 45 
0297   022E C7 4F 53 55 	.BYTE   'G'+80H,"OSUB"          ; GOSUB:
0297   0232 42 
0298   0233 D2 45 54 55 	.BYTE   'R'+80H,"ETURN"         ; RETURN:
0298   0237 52 4E 
0299   0239 D2 45 4D    	.BYTE   'R'+80H,"EM"            ; REM:
0300   023C D3 54 4F 50 	.BYTE   'S'+80H,"TOP"           ; STOP:
0301   0240 CF 55 54    	.BYTE   'O'+80H,"UT"            ; POUT:
0302   0243 CF 4E       	.BYTE   'O'+80H,"N"             ; ON:
0303   0245 CE 55 4C 4C 	.BYTE   'N'+80H,"ULL"           ; NULL:
0304   0249 D7 41 49 54 	.BYTE   'W'+80H,"AIT"           ; WAIT:
0305   024D C4 45 46    	.BYTE   'D'+80H,"EF"            ; DEF:
0306   0250 D0 4F 4B 45 	.BYTE   'P'+80H,"OKE"           ; POKE:
0307   0254 C4 4F 4B 45 	.BYTE   'D'+80H,"OKE"           ; DOKE:
0308   0258 D3 43 52 45 	.BYTE   'S'+80H,"CREEN"         ; REM: NOT IMPLEMENTED
0308   025C 45 4E 
0309   025E CC 49 4E 45 	.BYTE   'L'+80H,"INES"          ; LINES
0309   0262 53 
0310   0263 C3 4C 53    	.BYTE   'C'+80H,"LS"            ; CLS:
0311   0266 D7 49 44 54 	.BYTE   'W'+80H,"IDTH"          ; WIDTH:
0311   026A 48 
0312   026B C2 59 45    	.BYTE   'B'+80H,"YE"            ; MONITR:
0313   026E D3 45 54    	.BYTE   'S'+80H,"ET"            ; PSET:
0314   0271 D2 45 53 45 	.BYTE   'R'+80H,"ESET"          ; RESET:
0314   0275 54 
0315   0276 D0 52 49 4E 	.BYTE   'P'+80H,"RINT"          ; PRINT:
0315   027A 54 
0316   027B C3 4F 4E 54 	.BYTE   'C'+80H,"ONT"           ; CONT:
0317   027F CC 49 53 54 	.BYTE   'L'+80H,"IST"           ; LIST:
0318   0283 C3 4C 45 41 	.BYTE   'C'+80H,"LEAR"          ; CLEAR:
0318   0287 52 
0319   0288 D0 4C 41 59 	.BYTE   'P'+80H,"LAY"           ; PLAY: WAS CLOAD
0320   028C C3 53 41 56 	.BYTE   'C'+80H,"SAVE"          ; REM: NOT IMPLEMENTED
0320   0290 45 
0321   0291 CE 45 57    	.BYTE   'N'+80H,"EW"            ; NEW
0322   0294 D3 50 49 4B 	.BYTE   'S'+80H,"PIKE"          ; SPIKE
0322   0298 45 
0323   0299             
0324   0299 D4 41 42 28 	.BYTE   'T'+80H,"AB("
0325   029D D4 4F       	.BYTE   'T'+80H,"O"
0326   029F C6 4E       	.BYTE   'F'+80H,"N"
0327   02A1 D3 50 43 28 	.BYTE   'S'+80H,"PC("
0328   02A5 D4 48 45 4E 	.BYTE   'T'+80H,"HEN"
0329   02A9 CE 4F 54    	.BYTE   'N'+80H,"OT"
0330   02AC D3 54 45 50 	.BYTE   'S'+80H,"TEP"
0331   02B0             
0332   02B0 AB          	.BYTE   '+'+80H
0333   02B1 AD          	.BYTE   '-'+80H
0334   02B2 AA          	.BYTE   '*'+80H
0335   02B3 AF          	.BYTE   '/'+80H
0336   02B4 DE          	.BYTE   '^'+80H
0337   02B5 C1 4E 44    	.BYTE   'A'+80H,"ND"
0338   02B8 CF 52       	.BYTE   'O'+80H,"R"
0339   02BA BE          	.BYTE   '>'+80H
0340   02BB BD          	.BYTE   '='+80H
0341   02BC BC          	.BYTE   '<'+80H
0342   02BD             
0343   02BD D3 47 4E    	.BYTE   'S'+80H,"GN"
0344   02C0 C9 4E 54    	.BYTE   'I'+80H,"NT"
0345   02C3 C1 42 53    	.BYTE   'A'+80H,"BS"
0346   02C6 D5 53 52    	.BYTE   'U'+80H,"SR"
0347   02C9 C6 52 45    	.BYTE   'F'+80H,"RE"
0348   02CC C9 4E 50    	.BYTE   'I'+80H,"NP"
0349   02CF D0 4F 53    	.BYTE   'P'+80H,"OS"
0350   02D2 D3 51 52    	.BYTE   'S'+80H,"QR"
0351   02D5 D2 4E 44    	.BYTE   'R'+80H,"ND"
0352   02D8 CC 4F 47    	.BYTE   'L'+80H,"OG"
0353   02DB C5 58 50    	.BYTE   'E'+80H,"XP"
0354   02DE C3 4F 53    	.BYTE   'C'+80H,"OS"
0355   02E1 D3 49 4E    	.BYTE   'S'+80H,"IN"
0356   02E4 D4 41 4E    	.BYTE   'T'+80H,"AN"
0357   02E7 C1 54 4E    	.BYTE   'A'+80H,"TN"
0358   02EA D0 45 45 4B 	.BYTE   'P'+80H,"EEK"
0359   02EE C4 45 45 4B 	.BYTE   'D'+80H,"EEK"
0360   02F2 D0 4F 49 4E 	.BYTE   'P'+80H,"OINT"
0360   02F6 54 
0361   02F7 CC 45 4E    	.BYTE   'L'+80H,"EN"
0362   02FA D3 54 52 24 	.BYTE   'S'+80H,"TR$"
0363   02FE D6 41 4C    	.BYTE   'V'+80H,"AL"
0364   0301 C1 53 43    	.BYTE   'A'+80H,"SC"
0365   0304 C3 48 52 24 	.BYTE   'C'+80H,"HR$"
0366   0308 C8 45 58 24 	.BYTE   'H'+80H,"EX$"
0367   030C C2 49 4E 24 	.BYTE   'B'+80H,"IN$"
0368   0310 CC 45 46 54 	.BYTE   'L'+80H,"EFT$"
0368   0314 24 
0369   0315 D2 49 47 48 	.BYTE   'R'+80H,"IGHT$"
0369   0319 54 24 
0370   031B CD 49 44 24 	.BYTE   'M'+80H,"ID$"
0371   031F 80          	.BYTE   80H             ; End of list marker
0372   0320             
0373   0320             ; KEYWORD ADDRESS TABLE
0374   0320             
0375   0320 69 0A       WORDTB: .WORD   PEND
0376   0322 47 09       	.WORD   FOR
0377   0324 41 0E       	.WORD   NEXT
0378   0326 B6 0B       	.WORD   DATA
0379   0328 48 0D       	.WORD   INPUT
0380   032A 7D 10       	.WORD   DIM
0381   032C 77 0D       	.WORD   READ
0382   032E CD 0B       	.WORD   LET
0383   0330 73 0B       	.WORD   GOTO
0384   0332 56 0B       	.WORD   RUN
0385   0334 45 0C       	.WORD   IF
0386   0336 10 0A       	.WORD   RESTOR
0387   0338 62 0B       	.WORD   GOSUB
0388   033A 91 0B       	.WORD   RETURN
0389   033C B8 0B       	.WORD   REM
0390   033E 67 0A       	.WORD   STOP
0391   0340 B6 15       	.WORD   POUT
0392   0342 27 0C       	.WORD   ON
0393   0344 A8 0A       	.WORD   NULL
0394   0346 BC 15       	.WORD   WAIT
0395   0348 5B 12       	.WORD   DEF
0396   034A 05 16       	.WORD   POKE
0397   034C 67 1D       	.WORD   DOKE
0398   034E B8 0B       	.WORD   REM
0399   0350 4D 1D       	.WORD   LINES
0400   0352 31 1D       	.WORD   CLS
0401   0354 45 1D       	.WORD   WIDTH
0402   0356 87 1E       	.WORD   MONITR                          ; BYE
0403   0358 E4 22       	.WORD   PSET
0404   035A E7 22       	.WORD   RESET
0405   035C 69 0C       	.WORD   PRINT
0406   035E 95 0A       	.WORD   CONT
0407   0360 AC 08       	.WORD   LIST
0408   0362 10 0B       	.WORD   CLEAR
0409   0364 B7 1E       	.WORD   PLAY
0410   0366 B8 0B       	.WORD   REM
0411   0368 A4 06       	.WORD   NEW
0412   036A A2 1E       	.WORD   SPIKE
0413   036C             
0414   036C             ; RESERVED WORD TOKEN VALUES
0415   036C             
0416   036C             ZEND    .EQU    080H            ; END
0417   036C             ZFOR    .EQU    081H            ; FOR
0418   036C             ZDATA   .EQU    083H            ; DATA
0419   036C             ZGOTO   .EQU    088H            ; GOTO
0420   036C             ZGOSUB  .EQU    08CH            ; GOSUB
0421   036C             ZREM    .EQU    08EH            ; REM
0422   036C             ZPRINT  .EQU    09EH            ; PRINT
0423   036C             ZNEW    .EQU    0A6H            ; NEW
0424   036C             
0425   036C             ZTAB    .EQU    0A5H            ; TAB
0426   036C             ZTO     .EQU    0A6H            ; TO
0427   036C             ZFN     .EQU    0A7H            ; FN
0428   036C             ZSPC    .EQU    0A8H            ; SPC
0429   036C             ZTHEN   .EQU    0A9H            ; THEN
0430   036C             ZNOT    .EQU    0AAH            ; NOT
0431   036C             ZSTEP   .EQU    0ABH            ; STEP
0432   036C             
0433   036C             ZPLUS   .EQU    0ACH            ; +
0434   036C             ZMINUS  .EQU    0ADH            ; -
0435   036C             ZTIMES  .EQU    0AEH            ; *
0436   036C             ZDIV    .EQU    0AFH            ; /
0437   036C             ZOR     .EQU    0B2H            ; OR
0438   036C             ZGTR    .EQU    0B3H            ; >
0439   036C             ZEQUAL  .EQU    0B4H            ; =
0440   036C             ZLTH    .EQU    0B5H            ; <
0441   036C             ZSGN    .EQU    0B6H            ; SGN
0442   036C             ZPOINT  .EQU    0C7H            ; POINT
0443   036C             ZLEFT   .EQU    0CDH +2         ; LEFT$
0444   036C             
0445   036C             ; ARITHMETIC PRECEDENCE TABLE
0446   036C             
0447   036C 79          PRITAB: .BYTE   79H             ; Precedence value
0448   036D EF 19       	.WORD   PADD            ; FPREG = <last> + FPREG
0449   036F             
0450   036F 79          	.BYTE   79H             ; Precedence value
0451   0370 23 16       	.WORD   PSUB            ; FPREG = <last> - FPREG
0452   0372             
0453   0372 7C          	.BYTE   7CH             ; Precedence value
0454   0373 61 17       	.WORD   MULT            ; PPREG = <last> * FPREG
0455   0375             
0456   0375 7C          	.BYTE   7CH             ; Precedence value
0457   0376 C2 17       	.WORD   DIV             ; FPREG = <last> / FPREG
0458   0378             
0459   0378 7F          	.BYTE   7FH             ; Precedence value
0460   0379 10 1B       	.WORD   POWER           ; FPREG = <last> ^ FPREG
0461   037B             
0462   037B 50          	.BYTE   50H             ; Precedence value
0463   037C D6 0F       	.WORD   PAND            ; FPREG = <last> AND FPREG
0464   037E             
0465   037E 46          	.BYTE   46H             ; Precedence value
0466   037F D5 0F       	.WORD   POR             ; FPREG = <last> OR FPREG
0467   0381             
0468   0381             ; BASIC ERROR CODE LIST
0469   0381             
0470   0381~            #IF ABBRERR
0471   0381~            ERRORS: .BYTE   "NF"            ; NEXT without FOR
0472   0381~            	.BYTE   "SN"            ; Syntax error
0473   0381~            	.BYTE   "RG"            ; RETURN without GOSUB
0474   0381~            	.BYTE   "OD"            ; Out of DATA
0475   0381~            	.BYTE   "FC"            ; Illegal function call
0476   0381~            	.BYTE   "OV"            ; Overflow error
0477   0381~            	.BYTE   "OM"            ; Out of memory
0478   0381~            	.BYTE   "UL"            ; Undefined line
0479   0381~            	.BYTE   "BS"            ; Bad subscript
0480   0381~            	.BYTE   "DD"            ; Re-DIMensioned array
0481   0381~            	.BYTE   "/0"            ; Division by zero
0482   0381~            	.BYTE   "ID"            ; Illegal direct
0483   0381~            	.BYTE   "TM"            ; Type mismatch
0484   0381~            	.BYTE   "OS"            ; Out of string space
0485   0381~            	.BYTE   "LS"            ; String too long
0486   0381~            	.BYTE   "ST"            ; String formula too complex
0487   0381~            	.BYTE   "CN"            ; Can't CONTinue
0488   0381~            	.BYTE   "UF"            ; Undefined FN function
0489   0381~            	.BYTE   "MO"            ; Missing operand
0490   0381~            	.BYTE   "HX"            ; HEX error
0491   0381~            	.BYTE   "BN"            ; BIN error
0492   0381             #ELSE
0493   0381 4E 45 58 54 ERRORS: .BYTE   "NEXT without FOR",0
0493   0385 20 77 69 74 
0493   0389 68 6F 75 74 
0493   038D 20 46 4F 52 
0493   0391 00 
0494   0392 53 79 6E 74 	.BYTE   "Syntax",0
0494   0396 61 78 00 
0495   0399 52 45 54 55 	.BYTE   "RETURN without GOSUB",0
0495   039D 52 4E 20 77 
0495   03A1 69 74 68 6F 
0495   03A5 75 74 20 47 
0495   03A9 4F 53 55 42 
0495   03AD 00 
0496   03AE 4F 75 74 20 	.BYTE   "Out of DATA",0
0496   03B2 6F 66 20 44 
0496   03B6 41 54 41 00 
0497   03BA 49 6C 6C 65 	.BYTE   "Illegal function call",0
0497   03BE 67 61 6C 20 
0497   03C2 66 75 6E 63 
0497   03C6 74 69 6F 6E 
0497   03CA 20 63 61 6C 
0497   03CE 6C 00 
0498   03D0 4F 76 65 72 	.BYTE   "Overflow",0
0498   03D4 66 6C 6F 77 
0498   03D8 00 
0499   03D9 4F 75 74 20 	.BYTE   "Out of memory",0
0499   03DD 6F 66 20 6D 
0499   03E1 65 6D 6F 72 
0499   03E5 79 00 
0500   03E7 55 6E 64 65 	.BYTE   "Undefined line",0
0500   03EB 66 69 6E 65 
0500   03EF 64 20 6C 69 
0500   03F3 6E 65 00 
0501   03F6 42 61 64 20 	.BYTE   "Bad subscript",0
0501   03FA 73 75 62 73 
0501   03FE 63 72 69 70 
0501   0402 74 00 
0502   0404 52 65 2D 44 	.BYTE   "Re-DIMensioned array",0
0502   0408 49 4D 65 6E 
0502   040C 73 69 6F 6E 
0502   0410 65 64 20 61 
0502   0414 72 72 61 79 
0502   0418 00 
0503   0419 44 69 76 69 	.BYTE   "Division by zero",0
0503   041D 73 69 6F 6E 
0503   0421 20 62 79 20 
0503   0425 7A 65 72 6F 
0503   0429 00 
0504   042A 49 6C 6C 65 	.BYTE   "Illegal direct",0
0504   042E 67 61 6C 20 
0504   0432 64 69 72 65 
0504   0436 63 74 00 
0505   0439 54 79 70 65 	.BYTE   "Type mismatch",0
0505   043D 20 6D 69 73 
0505   0441 6D 61 74 63 
0505   0445 68 00 
0506   0447 4F 75 74 20 	.BYTE   "Out of string space",0
0506   044B 6F 66 20 73 
0506   044F 74 72 69 6E 
0506   0453 67 20 73 70 
0506   0457 61 63 65 00 
0507   045B 53 74 72 69 	.BYTE   "String too long",0
0507   045F 6E 67 20 74 
0507   0463 6F 6F 20 6C 
0507   0467 6F 6E 67 00 
0508   046B 53 74 72 69 	.BYTE   "String formula too complex",0
0508   046F 6E 67 20 66 
0508   0473 6F 72 6D 75 
0508   0477 6C 61 20 74 
0508   047B 6F 6F 20 63 
0508   047F 6F 6D 70 6C 
0508   0483 65 78 00 
0509   0486 43 61 6E 27 	.BYTE   "Can",$27,"t CONTinue",0
0509   048A 74 20 43 4F 
0509   048E 4E 54 69 6E 
0509   0492 75 65 00 
0510   0495 55 6E 64 65 	.BYTE   "Undefined FN function",0
0510   0499 66 69 6E 65 
0510   049D 64 20 46 4E 
0510   04A1 20 66 75 6E 
0510   04A5 63 74 69 6F 
0510   04A9 6E 00 
0511   04AB 4D 69 73 73 	.BYTE   "Missing operand",0
0511   04AF 69 6E 67 20 
0511   04B3 6F 70 65 72 
0511   04B7 61 6E 64 00 
0512   04BB 48 45 58 00 	.BYTE   "HEX",0
0513   04BF 42 49 4E 00 	.BYTE   "BIN",0
0514   04C3             #ENDIF
0515   04C3             
0516   04C3             ; INITIALISATION TABLE -------------------------------------------------------
0517   04C3             
0518   04C3 C3 68 01    INITAB: JP      WARMST          ; Warm start jump
0519   04C6 C3 E6 0A    	JP      FCERR           ; "USR (X)" jump (Set to Error)
0520   04C9 D3 00       	OUT     (0),A           ; "OUT p,n" skeleton
0521   04CB C9          	RET
0522   04CC D6 00       	SUB     0               ; Division support routine
0523   04CE 6F          	LD      L,A
0524   04CF 7C          	LD      A,H
0525   04D0 DE 00       	SBC     A,0
0526   04D2 67          	LD      H,A
0527   04D3 78          	LD      A,B
0528   04D4 DE 00       	SBC     A,0
0529   04D6 47          	LD      B,A
0530   04D7 3E 00       	LD      A,0
0531   04D9 C9          	RET
0532   04DA 00 00 00    	.BYTE   0,0,0                   ; Random number seed table used by RND
0533   04DD 35 4A CA 99 	.BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0534   04E1 39 1C 76 98 	.BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0535   04E5 22 95 B3 98 	.BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0536   04E9 0A DD 47 98 	.BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0537   04ED 53 D1 99 99 	.BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0538   04F1 0A 1A 9F 98 	.BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0539   04F5 65 BC CD 98 	.BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0540   04F9 D6 77 3E 98 	.BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0541   04FD 52 C7 4F 80 	.BYTE   052H,0C7H,04FH,080H     ; Last random number
0542   0501 DB 00       	IN      A,(0)           ; INP (x) skeleton
0543   0503 C9          	RET
0544   0504 01          	.BYTE   1               ; POS (x) number (1)
0545   0505 FF          	.BYTE   255             ; Terminal width (255 = no auto CRLF)
0546   0506 1C          	.BYTE   28              ; Width for commas (3 columns)
0547   0507 00          	.BYTE   0               ; No nulls after input bytes
0548   0508 00          	.BYTE   0               ; Output enabled (^O off)
0549   0509 14 00       	.WORD   20              ; Initial lines counter
0550   050B 14 00       	.WORD   20              ; Initial lines number
0551   050D 00 00       	.WORD   0               ; Array load/save check sum
0552   050F 00          	.BYTE   0               ; Break not by NMI
0553   0510 00          	.BYTE   0               ; Break flag
0554   0511 C3 DD 07    	JP      TTYLIN          ; Input reflection (set to TTY)
0555   0514 C3 00 00    	JP      $0000           ; POINT reflection unused
0556   0517 C3 00 00    	JP      $0000           ; SET reflection
0557   051A C3 00 00    	JP      $0000           ; RESET reflection
0558   051D ED 23       	.WORD   STLOOK          ; Temp string space
0559   051F FE FF       	.WORD   -2              ; Current line number (cold)
0560   0521 8A 23       	.WORD   PROGST+1        ; Start of program text
0561   0523             INITBE:
0562   0523             
0563   0523             ; END OF INITIALISATION TABLE ---------------------------------------------------
0564   0523             
0565   0523 20 45 72 72 ERRMSG: .BYTE   " Error",0
0565   0527 6F 72 00 
0566   052A 20 69 6E 20 INMSG:  .BYTE   " in ",0
0566   052E 00 
0567   052F             ZERBYT  .EQU    $-1             ; A zero byte
0568   052F 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
0568   0533 00 00 
0569   0535 42 72 65 61 BRKMSG: .BYTE   "Break",0
0569   0539 6B 00 
0570   053B             
0571   053B 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0572   053E 39          	ADD     HL,SP           ; same index as specified
0573   053F 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0574   0540 23          	INC     HL              ; Point to index address
0575   0541 FE 81       	CP      ZFOR            ; Is it a "FOR" token
0576   0543 C0          	RET     NZ              ; No - exit
0577   0544 4E          	LD      C,(HL)          ; BC = Address of "FOR" index
0578   0545 23          	INC     HL
0579   0546 46          	LD      B,(HL)
0580   0547 23          	INC     HL              ; Point to sign of STEP
0581   0548 E5          	PUSH    HL              ; Save pointer to sign
0582   0549 69          	LD      L,C             ; HL = address of "FOR" index
0583   054A 60          	LD      H,B
0584   054B 7A          	LD      A,D             ; See if an index was specified
0585   054C B3          	OR      E               ; DE = 0 if no index specified
0586   054D EB          	EX      DE,HL           ; Specified index into HL
0587   054E CA 55 05    	JP      Z,INDFND        ; Skip if no index given
0588   0551 EB          	EX      DE,HL           ; Index back into DE
0589   0552 CD 60 08    	CALL    CPDEHL          ; Compare index with one given
0590   0555 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0591   0558 E1          	POP     HL              ; Restore pointer to sign
0592   0559 C8          	RET     Z               ; Return if block found
0593   055A 09          	ADD     HL,BC           ; Point to next block
0594   055B C3 3F 05    	JP      LOKFOR          ; Keep on looking
0595   055E             
0596   055E CD 78 05    MOVUP:  CALL    ENFMEM          ; See if enough memory
0597   0561 C5          MOVSTR: PUSH    BC              ; Save end of source
0598   0562 E3          	EX      (SP),HL         ; Swap source and dest" end
0599   0563 C1          	POP     BC              ; Get end of destination
0600   0564 CD 60 08    MOVLP:  CALL    CPDEHL          ; See if list moved
0601   0567 7E          	LD      A,(HL)          ; Get byte
0602   0568 02          	LD      (BC),A          ; Move it
0603   0569 C8          	RET     Z               ; Exit if all done
0604   056A 0B          	DEC     BC              ; Next byte to move to
0605   056B 2B          	DEC     HL              ; Next byte to move
0606   056C C3 64 05    	JP      MOVLP           ; Loop until all bytes moved
0607   056F             
0608   056F E5          CHKSTK: PUSH    HL              ; Save code string address
0609   0570 2A 6A 23    	LD      HL,(ARREND)     ; Lowest free memory
0610   0573 06 00       	LD      B,0             ; BC = Number of levels to test
0611   0575 09          	ADD     HL,BC           ; 2 Bytes for each level
0612   0576 09          	ADD     HL,BC
0613   0577 3E          	.BYTE   3EH             ; Skip "PUSH HL"
0614   0578 E5          ENFMEM: PUSH    HL              ; Save code string address
0615   0579 3E D0       	LD      A,0D0H          ;LOW -48 ; 48 Bytes minimum RAM
0616   057B 95          	SUB     L
0617   057C 6F          	LD      L,A
0618   057D 3E FF       	LD      A,0FFH          ; HIGH (-48) ; 48 Bytes minimum RAM
0619   057F 9C          	SBC     A,H
0620   0580 DA 87 05    	JP      C,OMERR         ; Not enough - ?OM Error
0621   0583 67          	LD      H,A
0622   0584 39          	ADD     HL,SP           ; Test if stack is overflowed
0623   0585 E1          	POP     HL              ; Restore code string address
0624   0586 D8          	RET     C               ; Return if enough mmory
0625   0587 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0626   0589 C3 A6 05    	JP      ERROR
0627   058C             
0628   058C 2A 59 23    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0629   058F 22 EC 22    	LD      (LINEAT),HL     ; Save as current line
0630   0592 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0631   0594 01          	.BYTE   01H             ; Skip "LD E,DZ"
0632   0595 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0633   0597 01          	.BYTE   01H             ; Skip "LD E,NF"
0634   0598 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0635   059A 01          	.BYTE   01H             ; Skip "LD E,DD"
0636   059B 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0637   059D 01          	.BYTE   01H             ; Skip "LD E,UF"
0638   059E 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0639   05A0 01          	.BYTE   01H             ; Skip "LD E,OV
0640   05A1 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0641   05A3 01          	.BYTE   01H             ; Skip "LD E,TM"
0642   05A4 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0643   05A6             
0644   05A6 CD CA 06    ERROR:  CALL    CLREG           ; Clear registers and stack
0645   05A9 32 D5 22    	LD      (CTLOFG),A      ; Enable output (A is 0)
0646   05AC CD BA 0C    	CALL    STTLIN          ; Start new line
0647   05AF 21 81 03    	LD      HL,ERRORS       ; Point to error codes
0648   05B2 57          	LD      D,A             ; D = 0 (A is 0)
0649   05B3 3E 3F       	LD      A,'?'
0650   05B5 CD 71 08    	CALL    OUTC            ; Output '?'
0651   05B8~            #IF ABBRERR
0652   05B8~            	ADD     HL,DE           ; Offset to correct error code
0653   05B8~            	LD      A,(HL)          ; First character
0654   05B8~            	CALL    OUTC            ; Output it
0655   05B8~            	CALL    GETCHR          ; Get next character
0656   05B8~            	CALL    OUTC            ; Output it
0657   05B8             #ELSE
0658   05B8 C5          	PUSH    BC              ; Count through
0659   05B9 43          	LD      B,E             ; the error list
0660   05BA CB 38       	SRL     B               ; until we get
0661   05BC 28 07       	JR      Z,CHRZRO        ; error message
0662   05BE 7E          NXCHR:  LD      A,(HL)          ;
0663   05BF B7          	OR      A               ; E/2 = entry
0664   05C0 23          	INC     HL              ; number in the
0665   05C1 20 FB       	JR      NZ,NXCHR        ; list.
0666   05C3 10 F9       	DJNZ    NXCHR
0667   05C5 CD 65 13    CHRZRO: CALL    PRS             ; Display message.
0668   05C8 C1          	POP     BC
0669   05C9             #ENDIF
0670   05C9 21 23 05    	LD      HL,ERRMSG       ; "Error" message
0671   05CC CD 65 13    ERRIN:  CALL    PRS             ; Output message
0672   05CF 2A EC 22    	LD      HL,(LINEAT)     ; Get line of error
0673   05D2 11 FE FF    	LD      DE,-2           ; Cold start error if -2
0674   05D5 CD 60 08    	CALL    CPDEHL          ; See if cold start error
0675   05D8 CA 11 01    	JP      Z,CSTART        ; Cold start error - Restart
0676   05DB 7C          	LD      A,H             ; Was it a direct error?
0677   05DC A5          	AND     L               ; Line = -1 if direct error
0678   05DD 3C          	INC     A
0679   05DE C4 00 1A    	CALL    NZ,LINEIN       ; No - output line of error
0680   05E1 3E          	.BYTE   3EH             ; Skip "POP BC"
0681   05E2 C1          POPNOK: POP     BC              ; Drop address in input buffer
0682   05E3             
0683   05E3 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0684   05E4 32 D5 22    	LD      (CTLOFG),A      ; Enable output
0685   05E7 CD BA 0C    	CALL    STTLIN          ; Start new line
0686   05EA 21 2F 05    	LD      HL,OKMSG        ; "Ok" message
0687   05ED CD 65 13    	CALL    PRS             ; Output "Ok"
0688   05F0 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0689   05F3 22 EC 22    	LD      (LINEAT),HL     ; Save as current line
0690   05F6 CD DD 07    	CALL    GETLIN          ; Get an input line
0691   05F9 DA F0 05    	JP      C,GETCMD        ; Get line again if break
0692   05FC CD 00 0A    	CALL    GETCHR          ; Get first character
0693   05FF 3C          	INC     A               ; Test if end of line
0694   0600 3D          	DEC     A               ; Without affecting Carry
0695   0601 CA F0 05    	JP      Z,GETCMD        ; Nothing entered - Get another
0696   0604 F5          	PUSH    AF              ; Save Carry status
0697   0605 CD EB 0A    	CALL    ATOH            ; Get line number into DE
0698   0608 D5          	PUSH    DE              ; Save line number
0699   0609 CD F4 06    	CALL    CRUNCH          ; Tokenise rest of line
0700   060C 47          	LD      B,A             ; Length of tokenised line
0701   060D D1          	POP     DE              ; Restore line number
0702   060E F1          	POP     AF              ; Restore Carry
0703   060F D2 E0 09    	JP      NC,EXCUTE       ; No line number - Direct mode
0704   0612 D5          	PUSH    DE              ; Save line number
0705   0613 C5          	PUSH    BC              ; Save length of tokenised line
0706   0614 AF          	XOR     A
0707   0615 32 5C 23    	LD      (LSTBIN),A      ; Clear last byte input
0708   0618 CD 00 0A    	CALL    GETCHR          ; Get next character
0709   061B B7          	OR      A               ; Set flags
0710   061C F5          	PUSH    AF              ; And save them
0711   061D CD 84 06    	CALL    SRCHLN          ; Search for line number in DE
0712   0620 DA 29 06    	JP      C,LINFND        ; Jump if line found
0713   0623 F1          	POP     AF              ; Get status
0714   0624 F5          	PUSH    AF              ; And re-save
0715   0625 CA 8C 0B    	JP      Z,ULERR         ; Nothing after number - Error
0716   0628 B7          	OR      A               ; Clear Carry
0717   0629 C5          LINFND: PUSH    BC              ; Save address of line in prog
0718   062A D2 40 06    	JP      NC,INEWLN       ; Line not found - Insert new
0719   062D EB          	EX      DE,HL           ; Next line address in DE
0720   062E 2A 66 23    	LD      HL,(PROGND)     ; End of program
0721   0631 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0722   0632 02          	LD      (BC),A
0723   0633 03          	INC     BC              ; Next destination
0724   0634 13          	INC     DE              ; Next source
0725   0635 CD 60 08    	CALL    CPDEHL          ; All done?
0726   0638 C2 31 06    	JP      NZ,SFTPRG       ; More to do
0727   063B 60          	LD      H,B             ; HL - New end of program
0728   063C 69          	LD      L,C
0729   063D 22 66 23    	LD      (PROGND),HL     ; Update end of program
0730   0640             
0731   0640 D1          INEWLN: POP     DE              ; Get address of line,
0732   0641 F1          	POP     AF              ; Get status
0733   0642 CA 67 06    	JP      Z,SETPTR        ; No text - Set up pointers
0734   0645 2A 66 23    	LD      HL,(PROGND)     ; Get end of program
0735   0648 E3          	EX      (SP),HL         ; Get length of input line
0736   0649 C1          	POP     BC              ; End of program to BC
0737   064A 09          	ADD     HL,BC           ; Find new end
0738   064B E5          	PUSH    HL              ; Save new end
0739   064C CD 5E 05    	CALL    MOVUP           ; Make space for line
0740   064F E1          	POP     HL              ; Restore new end
0741   0650 22 66 23    	LD      (PROGND),HL     ; Update end of program pointer
0742   0653 EB          	EX      DE,HL           ; Get line to move up in HL
0743   0654 74          	LD      (HL),H          ; Save MSB
0744   0655 D1          	POP     DE              ; Get new line number
0745   0656 23          	INC     HL              ; Skip pointer
0746   0657 23          	INC     HL
0747   0658 73          	LD      (HL),E          ; Save LSB of line number
0748   0659 23          	INC     HL
0749   065A 72          	LD      (HL),D          ; Save MSB of line number
0750   065B 23          	INC     HL              ; To first byte in line
0751   065C 11 F1 22    	LD      DE,BUFFER       ; Copy buffer to program
0752   065F 1A          MOVBUF: LD      A,(DE)          ; Get source
0753   0660 77          	LD      (HL),A          ; Save destinations
0754   0661 23          	INC     HL              ; Next source
0755   0662 13          	INC     DE              ; Next destination
0756   0663 B7          	OR      A               ; Done?
0757   0664 C2 5F 06    	JP      NZ,MOVBUF       ; No - Repeat
0758   0667 CD B0 06    SETPTR: CALL    RUNFST          ; Set line pointers
0759   066A 23          	INC     HL              ; To LSB of pointer
0760   066B EB          	EX      DE,HL           ; Address to DE
0761   066C 62          PTRLP:  LD      H,D             ; Address to HL
0762   066D 6B          	LD      L,E
0763   066E 7E          	LD      A,(HL)          ; Get LSB of pointer
0764   066F 23          	INC     HL              ; To MSB of pointer
0765   0670 B6          	OR      (HL)            ; Compare with MSB pointer
0766   0671 CA F0 05    	JP      Z,GETCMD        ; Get command line if end
0767   0674 23          	INC     HL              ; To LSB of line number
0768   0675 23          	INC     HL              ; Skip line number
0769   0676 23          	INC     HL              ; Point to first byte in line
0770   0677 AF          	XOR     A               ; Looking for 00 byte
0771   0678 BE          FNDEND: CP      (HL)            ; Found end of line?
0772   0679 23          	INC     HL              ; Move to next byte
0773   067A C2 78 06    	JP      NZ,FNDEND       ; No - Keep looking
0774   067D EB          	EX      DE,HL           ; Next line address to HL
0775   067E 73          	LD      (HL),E          ; Save LSB of pointer
0776   067F 23          	INC     HL
0777   0680 72          	LD      (HL),D          ; Save MSB of pointer
0778   0681 C3 6C 06    	JP      PTRLP           ; Do next line
0779   0684             
0780   0684 2A EE 22    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0781   0687 44          SRCHLP: LD      B,H             ; BC = Address to look at
0782   0688 4D          	LD      C,L
0783   0689 7E          	LD      A,(HL)          ; Get address of next line
0784   068A 23          	INC     HL
0785   068B B6          	OR      (HL)            ; End of program found?
0786   068C 2B          	DEC     HL
0787   068D C8          	RET     Z               ; Yes - Line not found
0788   068E 23          	INC     HL
0789   068F 23          	INC     HL
0790   0690 7E          	LD      A,(HL)          ; Get LSB of line number
0791   0691 23          	INC     HL
0792   0692 66          	LD      H,(HL)          ; Get MSB of line number
0793   0693 6F          	LD      L,A
0794   0694 CD 60 08    	CALL    CPDEHL          ; Compare with line in DE
0795   0697 60          	LD      H,B             ; HL = Start of this line
0796   0698 69          	LD      L,C
0797   0699 7E          	LD      A,(HL)          ; Get LSB of next line address
0798   069A 23          	INC     HL
0799   069B 66          	LD      H,(HL)          ; Get MSB of next line address
0800   069C 6F          	LD      L,A             ; Next line to HL
0801   069D 3F          	CCF
0802   069E C8          	RET     Z               ; Lines found - Exit
0803   069F 3F          	CCF
0804   06A0 D0          	RET     NC              ; Line not found,at line after
0805   06A1 C3 87 06    	JP      SRCHLP          ; Keep looking
0806   06A4             
0807   06A4 C0          NEW:    RET     NZ              ; Return if any more on line
0808   06A5 2A EE 22    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0809   06A8 AF          	XOR     A               ; Set program area to empty
0810   06A9 77          	LD      (HL),A          ; Save LSB = 00
0811   06AA 23          	INC     HL
0812   06AB 77          	LD      (HL),A          ; Save MSB = 00
0813   06AC 23          	INC     HL
0814   06AD 22 66 23    	LD      (PROGND),HL     ; Set program end
0815   06B0             
0816   06B0 2A EE 22    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0817   06B3 2B          	DEC     HL
0818   06B4             
0819   06B4 22 5E 23    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0820   06B7 2A 3F 23    	LD      HL,(LSTRAM)     ; Get end of RAM
0821   06BA 22 53 23    	LD      (STRBOT),HL     ; Clear string space
0822   06BD AF          	XOR     A
0823   06BE CD 10 0A    	CALL    RESTOR          ; Reset DATA pointers
0824   06C1 2A 66 23    	LD      HL,(PROGND)     ; Get end of program
0825   06C4 22 68 23    	LD      (VAREND),HL     ; Clear variables
0826   06C7 22 6A 23    	LD      (ARREND),HL     ; Clear arrays
0827   06CA             
0828   06CA C1          CLREG:  POP     BC              ; Save return address
0829   06CB 2A EA 22    	LD      HL,(STRSPC)     ; Get end of working RAN
0830   06CE F9          	LD      SP,HL           ; Set stack
0831   06CF 21 43 23    	LD      HL,TMSTPL       ; Temporary string pool
0832   06D2 22 41 23    	LD      (TMSTPT),HL     ; Reset temporary string ptr
0833   06D5 AF          	XOR     A               ; A = 00
0834   06D6 6F          	LD      L,A             ; HL = 0000
0835   06D7 67          	LD      H,A
0836   06D8 22 64 23    	LD      (CONTAD),HL     ; No CONTinue
0837   06DB 32 5B 23    	LD      (FORFLG),A      ; Clear FOR flag
0838   06DE 22 6E 23    	LD      (FNRGNM),HL     ; Clear FN argument
0839   06E1 E5          	PUSH    HL              ; HL = 0000
0840   06E2 C5          	PUSH    BC              ; Put back return
0841   06E3 2A 5E 23    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0842   06E6 C9          	RET                     ; Return to execution driver
0843   06E7             
0844   06E7 3E 3F       PROMPT: LD      A,'?'           ; '?'
0845   06E9 CD 71 08    	CALL    OUTC            ; Output character
0846   06EC 3E 20       	LD      A,' '           ; Space
0847   06EE CD 71 08    	CALL    OUTC            ; Output character
0848   06F1 C3 DE 22    	JP      RINPUT          ; Get input line
0849   06F4             
0850   06F4 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0851   06F5 32 3E 23    	LD      (DATFLG),A      ; Reset literal flag
0852   06F8 0E 05       	LD      C,2+3           ; 2 byte number and 3 nulls
0853   06FA 11 F1 22    	LD      DE,BUFFER       ; Start of input buffer
0854   06FD 7E          CRNCLP: LD      A,(HL)          ; Get byte
0855   06FE FE 20       	CP      ' '             ; Is it a space?
0856   0700 CA 7C 07    	JP      Z,MOVDIR        ; Yes - Copy direct
0857   0703 47          	LD      B,A             ; Save character
0858   0704 FE 22       	CP      '"'             ; Is it a quote?
0859   0706 CA 9C 07    	JP      Z,CPYLIT        ; Yes - Copy literal string
0860   0709 B7          	OR      A               ; Is it end of buffer?
0861   070A CA A3 07    	JP      Z,ENDBUF        ; Yes - End buffer
0862   070D 3A 3E 23    	LD      A,(DATFLG)      ; Get data type
0863   0710 B7          	OR      A               ; Literal?
0864   0711 7E          	LD      A,(HL)          ; Get byte to copy
0865   0712 C2 7C 07    	JP      NZ,MOVDIR       ; Literal - Copy direct
0866   0715 FE 3F       	CP      '?'             ; Is it '?' short for PRINT
0867   0717 3E 9E       	LD      A,ZPRINT        ; "PRINT" token
0868   0719 CA 7C 07    	JP      Z,MOVDIR        ; Yes - replace it
0869   071C 7E          	LD      A,(HL)          ; Get byte again
0870   071D FE 30       	CP      '0'             ; Is it less than '0'
0871   071F DA 27 07    	JP      C,FNDWRD        ; Yes - Look for reserved words
0872   0722 FE 3C       	CP      60; ";"+1           ; Is it "0123456789:;" ?
0873   0724 DA 7C 07    	JP      C,MOVDIR        ; Yes - copy it direct
0874   0727 D5          FNDWRD: PUSH    DE              ; Look for reserved words
0875   0728 11 00 02    	LD      DE,WORDS-1      ; Point to table
0876   072B C5          	PUSH    BC              ; Save count
0877   072C 01 78 07    	LD      BC,RETNAD       ; Where to return to
0878   072F C5          	PUSH    BC              ; Save return address
0879   0730 06 7F       	LD      B,ZEND-1        ; First token value -1
0880   0732 7E          	LD      A,(HL)          ; Get byte
0881   0733 FE 61       	CP      'a'             ; Less than 'a' ?
0882   0735 DA 40 07    	JP      C,SEARCH        ; Yes - search for words
0883   0738 FE 7B       	CP      'z'+1           ; Greater than 'z' ?
0884   073A D2 40 07    	JP      NC,SEARCH       ; Yes - search for words
0885   073D E6 5F       	AND     01011111B       ; Force upper case
0886   073F 77          	LD      (HL),A          ; Replace byte
0887   0740 4E          SEARCH: LD      C,(HL)          ; Search for a word
0888   0741 EB          	EX      DE,HL
0889   0742 23          GETNXT: INC     HL              ; Get next reserved word
0890   0743 B6          	OR      (HL)            ; Start of word?
0891   0744 F2 42 07    	JP      P,GETNXT        ; No - move on
0892   0747 04          	INC     B               ; Increment token value
0893   0748 7E          	LD      A, (HL)         ; Get byte from table
0894   0749 E6 7F       	AND     01111111B       ; Strip bit 7
0895   074B C8          	RET     Z               ; Return if end of list
0896   074C B9          	CP      C               ; Same character as in buffer?
0897   074D C2 42 07    	JP      NZ,GETNXT       ; No - get next word
0898   0750 EB          	EX      DE,HL
0899   0751 E5          	PUSH    HL              ; Save start of word
0900   0752             
0901   0752 13          NXTBYT: INC     DE              ; Look through rest of word
0902   0753 1A          	LD      A,(DE)          ; Get byte from table
0903   0754 B7          	OR      A               ; End of word ?
0904   0755 FA 74 07    	JP      M,MATCH         ; Yes - Match found
0905   0758 4F          	LD      C,A             ; Save it
0906   0759 78          	LD      A,B             ; Get token value
0907   075A FE 88       	CP      ZGOTO           ; Is it "GOTO" token ?
0908   075C C2 63 07    	JP      NZ,NOSPC        ; No - Don't allow spaces
0909   075F CD 00 0A    	CALL    GETCHR          ; Get next character
0910   0762 2B          	DEC     HL              ; Cancel increment from GETCHR
0911   0763 23          NOSPC:  INC     HL              ; Next byte
0912   0764 7E          	LD      A,(HL)          ; Get byte
0913   0765 FE 61       	CP      'a'             ; Less than 'a' ?
0914   0767 DA 6C 07    	JP      C,NOCHNG        ; Yes - don't change
0915   076A E6 5F       	AND     01011111B       ; Make upper case
0916   076C B9          NOCHNG: CP      C               ; Same as in buffer ?
0917   076D CA 52 07    	JP      Z,NXTBYT        ; Yes - keep testing
0918   0770 E1          	POP     HL              ; Get back start of word
0919   0771 C3 40 07    	JP      SEARCH          ; Look at next word
0920   0774             
0921   0774 48          MATCH:  LD      C,B             ; Word found - Save token value
0922   0775 F1          	POP     AF              ; Throw away return
0923   0776 EB          	EX      DE,HL
0924   0777 C9          	RET                     ; Return to "RETNAD"
0925   0778 EB          RETNAD: EX      DE,HL           ; Get address in string
0926   0779 79          	LD      A,C             ; Get token value
0927   077A C1          	POP     BC              ; Restore buffer length
0928   077B D1          	POP     DE              ; Get destination address
0929   077C 23          MOVDIR: INC     HL              ; Next source in buffer
0930   077D 12          	LD      (DE),A          ; Put byte in buffer
0931   077E 13          	INC     DE              ; Move up buffer
0932   077F 0C          	INC     C               ; Increment length of buffer
0933   0780 D6 3A       	SUB     ':'             ; End of statement?
0934   0782 CA 8A 07    	JP      Z,SETLIT        ; Jump if multi-statement line
0935   0785 FE 49       	CP      ZDATA-3AH       ; Is it DATA statement ?
0936   0787 C2 8D 07    	JP      NZ,TSTREM       ; No - see if REM
0937   078A 32 3E 23    SETLIT: LD      (DATFLG),A      ; Set literal flag
0938   078D D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0939   078F C2 FD 06    	JP      NZ,CRNCLP       ; No - Leave flag
0940   0792 47          	LD      B,A             ; Copy rest of buffer
0941   0793 7E          NXTCHR: LD      A,(HL)          ; Get byte
0942   0794 B7          	OR      A               ; End of line ?
0943   0795 CA A3 07    	JP      Z,ENDBUF        ; Yes - Terminate buffer
0944   0798 B8          	CP      B               ; End of statement ?
0945   0799 CA 7C 07    	JP      Z,MOVDIR        ; Yes - Get next one
0946   079C 23          CPYLIT: INC     HL              ; Move up source string
0947   079D 12          	LD      (DE),A          ; Save in destination
0948   079E 0C          	INC     C               ; Increment length
0949   079F 13          	INC     DE              ; Move up destination
0950   07A0 C3 93 07    	JP      NXTCHR          ; Repeat
0951   07A3             
0952   07A3 21 F0 22    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0953   07A6 12          	LD      (DE),A          ; Mark end of buffer (A = 00)
0954   07A7 13          	INC     DE
0955   07A8 12          	LD      (DE),A          ; A = 00
0956   07A9 13          	INC     DE
0957   07AA 12          	LD      (DE),A          ; A = 00
0958   07AB C9          	RET
0959   07AC             
0960   07AC 3A D4 22    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0961   07AF B7          	OR      A               ; Is it zero?
0962   07B0 3E 00       	LD      A,0             ; Zero A - Leave flags
0963   07B2 32 D4 22    	LD      (NULFLG),A      ; Zero null flag
0964   07B5 C2 C0 07    	JP      NZ,ECHDEL       ; Set - Echo it
0965   07B8 05          	DEC     B               ; Decrement length
0966   07B9 CA DD 07    	JP      Z,GETLIN        ; Get line again if empty
0967   07BC CD 71 08    	CALL    OUTC            ; Output null character
0968   07BF 3E          	.BYTE   3EH             ; Skip "DEC B"
0969   07C0 05          ECHDEL: DEC     B               ; Count bytes in buffer
0970   07C1 2B          	DEC     HL              ; Back space buffer
0971   07C2 CA D4 07    	JP      Z,OTKLN         ; No buffer - Try again
0972   07C5 7E          	LD      A,(HL)          ; Get deleted byte
0973   07C6 CD 71 08    	CALL    OUTC            ; Echo it
0974   07C9 C3 E6 07    	JP      MORINP          ; Get more input
0975   07CC             
0976   07CC 05          DELCHR: DEC     B               ; Count bytes in buffer
0977   07CD 2B          	DEC     HL              ; Back space buffer
0978   07CE CD 71 08    	CALL    OUTC            ; Output character in A
0979   07D1 C2 E6 07    	JP      NZ,MORINP       ; Not end - Get more
0980   07D4 CD 71 08    OTKLN:  CALL    OUTC            ; Output character in A
0981   07D7 CD C7 0C    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0982   07DA C3 DD 07    	JP      TTYLIN          ; Get line again
0983   07DD             
0984   07DD             GETLIN:
0985   07DD 21 F1 22    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0986   07E0 06 01       	LD      B,1             ; Set buffer as empty
0987   07E2 AF          	XOR     A
0988   07E3 32 D4 22    	LD      (NULFLG),A      ; Clear null flag
0989   07E6 CD 9B 08    MORINP: CALL    CLOTST          ; Get character and test ^O
0990   07E9 4F          	LD      C,A             ; Save character in C
0991   07EA FE 7F       	CP      DEL             ; Delete character?
0992   07EC CA AC 07    	JP      Z,DODEL         ; Yes - Process it
0993   07EF 3A D4 22    	LD      A,(NULFLG)      ; Get null flag
0994   07F2 B7          	OR      A               ; Test null flag status
0995   07F3 CA FF 07    	JP      Z,PROCES        ; Reset - Process character
0996   07F6 3E 00       	LD      A,0             ; Set a null
0997   07F8 CD 71 08    	CALL    OUTC            ; Output null
0998   07FB AF          	XOR     A               ; Clear A
0999   07FC 32 D4 22    	LD      (NULFLG),A      ; Reset null flag
1000   07FF 79          PROCES: LD      A,C             ; Get character
1001   0800 FE 07       	CP      CTRLG           ; Bell?
1002   0802 CA 43 08    	JP      Z,PUTCTL        ; Yes - Save it
1003   0805 FE 03       	CP      CTRLC           ; Is it control "C"?
1004   0807 CC C7 0C    	CALL    Z,PRNTCRLF      ; Yes - Output CRLF
1005   080A 37          	SCF                     ; Flag break
1006   080B C8          	RET     Z               ; Return if control "C"
1007   080C FE 0D       	CP      CR              ; Is it enter?
1008   080E CA C2 0C    	JP      Z,ENDINP        ; Yes - Terminate input
1009   0811 FE 15       	CP      CTRLU           ; Is it control "U"?
1010   0813 CA D7 07    	JP      Z,KILIN         ; Yes - Get another line
1011   0816 FE 40       	CP      '@'             ; Is it "kill line"?
1012   0818 CA D4 07    	JP      Z,OTKLN         ; Yes - Kill line
1013   081B FE 5F       	CP      '_'             ; Is it delete?
1014   081D CA CC 07    	JP      Z,DELCHR        ; Yes - Delete character
1015   0820 FE 08       	CP      BKSP            ; Is it backspace?
1016   0822 CA CC 07    	JP      Z,DELCHR        ; Yes - Delete character
1017   0825 FE 12       	CP      CTRLR           ; Is it control "R"?
1018   0827 C2 3E 08    	JP      NZ,PUTBUF       ; No - Put in buffer
1019   082A C5          	PUSH    BC              ; Save buffer length
1020   082B D5          	PUSH    DE              ; Save DE
1021   082C E5          	PUSH    HL              ; Save buffer address
1022   082D 36 00       	LD      (HL),0          ; Mark end of buffer
1023   082F CD 9C 1E    	CALL    OUTNCR          ; Output and do CRLF
1024   0832 21 F1 22    	LD      HL,BUFFER       ; Point to buffer start
1025   0835 CD 65 13    	CALL    PRS             ; Output buffer
1026   0838 E1          	POP     HL              ; Restore buffer address
1027   0839 D1          	POP     DE              ; Restore DE
1028   083A C1          	POP     BC              ; Restore buffer length
1029   083B C3 E6 07    	JP      MORINP          ; Get another character
1030   083E             
1031   083E FE 20       PUTBUF: CP      ' '             ; Is it a control code?
1032   0840 DA E6 07    	JP      C,MORINP        ; Yes - Ignore
1033   0843 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
1034   0844 FE 49       	CP      72+1            ; Test for line overflow
1035   0846 3E 07       	LD      A,CTRLG         ; Set a bell
1036   0848 D2 58 08    	JP      NC,OUTNBS       ; Ring bell if buffer full
1037   084B 79          	LD      A,C             ; Get character
1038   084C 71          	LD      (HL),C          ; Save in buffer
1039   084D 32 5C 23    	LD      (LSTBIN),A      ; Save last input byte
1040   0850 23          	INC     HL              ; Move up buffer
1041   0851 04          	INC     B               ; Increment length
1042   0852 CD 71 08    OUTIT:  CALL    OUTC            ; Output the character entered
1043   0855 C3 E6 07    	JP      MORINP          ; Get another character
1044   0858             
1045   0858 CD 71 08    OUTNBS: CALL    OUTC            ; Output bell and back over it
1046   085B 3E 08       	LD      A,BKSP          ; Set back space
1047   085D C3 52 08    	JP      OUTIT           ; Output it and get more
1048   0860             
1049   0860 7C          CPDEHL: LD      A,H             ; Get H
1050   0861 92          	SUB     D               ; Compare with D
1051   0862 C0          	RET     NZ              ; Different - Exit
1052   0863 7D          	LD      A,L             ; Get L
1053   0864 93          	SUB     E               ; Compare with E
1054   0865 C9          	RET                     ; Return status
1055   0866             
1056   0866 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
1057   0867 E3          	EX      (SP),HL         ; Address of test byte
1058   0868 BE          	CP      (HL)            ; Same as in code string?
1059   0869 23          	INC     HL              ; Return address
1060   086A E3          	EX      (SP),HL         ; Put it back
1061   086B CA 00 0A    	JP      Z,GETCHR        ; Yes - Get next character
1062   086E C3 92 05    	JP      SNERR           ; Different - ?SN Error
1063   0871             
1064   0871 F5          OUTC:   PUSH    AF              ; Save character
1065   0872 3A D5 22    	LD      A,(CTLOFG)      ; Get control "O" flag
1066   0875 B7          	OR      A               ; Is it set?
1067   0876 C2 9A 13    	JP      NZ,POPAF        ; Yes - don't output
1068   0879 F1          	POP     AF              ; Restore character
1069   087A C5          	PUSH    BC              ; Save buffer length
1070   087B F5          	PUSH    AF              ; Save character
1071   087C FE 20       	CP      ' '             ; Is it a control code?
1072   087E DA 95 08    	JP      C,DINPOS        ; Yes - Don't INC POS(X)
1073   0881 3A D2 22    	LD      A,(LWIDTH)      ; Get line width
1074   0884 47          	LD      B,A             ; To B
1075   0885 3A 3B 23    	LD      A,(CURPOS)      ; Get cursor position
1076   0888 04          	INC     B               ; Width 255?
1077   0889 CA 91 08    	JP      Z,INCLEN        ; Yes - No width limit
1078   088C 05          	DEC     B               ; Restore width
1079   088D B8          	CP      B               ; At end of line?
1080   088E CC C7 0C    	CALL    Z,PRNTCRLF      ; Yes - output CRLF
1081   0891 3C          INCLEN: INC     A               ; Move on one character
1082   0892 32 3B 23    	LD      (CURPOS),A      ; Save new position
1083   0895 F1          DINPOS: POP     AF              ; Restore character
1084   0896 C1          	POP     BC              ; Restore buffer length
1085   0897 CD 7A 1E    	CALL    MONOUT          ; Send it
1086   089A C9          	RET
1087   089B             
1088   089B CD 24 1D    CLOTST: CALL    GETINP          ; Get input character
1089   089E E6 7F       	AND     01111111B       ; Strip bit 7
1090   08A0 FE 0F       	CP      CTRLO           ; Is it control "O"?
1091   08A2 C0          	RET     NZ              ; No don't flip flag
1092   08A3 3A D5 22    	LD      A,(CTLOFG)      ; Get flag
1093   08A6 2F          	CPL                     ; Flip it
1094   08A7 32 D5 22    	LD      (CTLOFG),A      ; Put it back
1095   08AA AF          	XOR     A               ; Null character
1096   08AB C9          	RET
1097   08AC             
1098   08AC C5          LIST: 	trace(MARKER1)
1098   08AD D5          
1098   08AE F5          
1098   08AF E5          
1098   08B0 11 CB 1F    
1098   08B3 0E 09       
1098   08B5 CD 05 00    
1098   08B8 E1          
1098   08B9 F1          
1098   08BA D1          
1098   08BB C1          
1099   08BC             
1100   08BC             
1101   08BC CD EB 0A    	CALL    ATOH            ; ASCII number to DE
1102   08BF C0          	RET     NZ              ; Return if anything extra
1103   08C0 C1          	POP     BC              ; Rubbish - Not needed
1104   08C1 CD 84 06    	CALL    SRCHLN          ; Search for line number in DE
1105   08C4 C5          	PUSH    BC              ; Save address of line
1106   08C5 CD 12 09    	CALL    SETLIN          ; Set up lines counter
1107   08C8 E1          LISTLP: POP     HL              ; Restore address of line
1108   08C9 4E          	LD      C,(HL)          ; Get LSB of next line
1109   08CA 23          	INC     HL
1110   08CB 46          	LD      B,(HL)          ; Get MSB of next line
1111   08CC 23          	INC     HL
1112   08CD 78          	LD      A,B             ; BC = 0 (End of program)?
1113   08CE B1          	OR      C
1114   08CF CA E3 05    	JP      Z,PRNTOK        ; Yes - Go to command mode
1115   08D2 CD 1B 09    	CALL    COUNT           ; Count lines
1116   08D5 CD 2B 0A    	CALL    TSTBRK          ; Test for break key
1117   08D8 C5          	PUSH    BC              ; Save address of next line
1118   08D9 CD C7 0C    	CALL    PRNTCRLF        ; Output CRLF
1119   08DC 5E          	LD      E,(HL)          ; Get LSB of line number
1120   08DD 23          	INC     HL
1121   08DE 56          	LD      D,(HL)          ; Get MSB of line number
1122   08DF 23          	INC     HL
1123   08E0 E5          	PUSH    HL              ; Save address of line start
1124   08E1 EB          	EX      DE,HL           ; Line number to HL
1125   08E2 CD 08 1A    	CALL    PRNTHL          ; Output line number in decimal
1126   08E5 3E 20       	LD      A,' '           ; Space after line number
1127   08E7 E1          	POP     HL              ; Restore start of line address
1128   08E8 CD 71 08    LSTLP2: CALL    OUTC            ; Output character in A
1129   08EB 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1130   08EC B7          	OR      A               ; End of line?
1131   08ED 23          	INC     HL              ; To next byte in line
1132   08EE CA C8 08    	JP      Z,LISTLP        ; Yes - get next line
1133   08F1 F2 E8 08    	JP      P,LSTLP2        ; No token - output it
1134   08F4 D6 7F       	SUB     ZEND-1          ; Find and output word
1135   08F6 4F          	LD      C,A             ; Token offset+1 to C
1136   08F7 11 01 02    	LD      DE,WORDS        ; Reserved word list
1137   08FA 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1138   08FB 13          	INC     DE              ; Move on to next
1139   08FC B7          	OR      A               ; Is it start of word?
1140   08FD F2 FA 08    	JP      P,FNDTOK        ; No - Keep looking for word
1141   0900 0D          	DEC     C               ; Count words
1142   0901 C2 FA 08    	JP      NZ,FNDTOK       ; Not there - keep looking
1143   0904 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1144   0906 CD 71 08    	CALL    OUTC            ; Output first character
1145   0909 1A          	LD      A,(DE)          ; Get next character
1146   090A 13          	INC     DE              ; Move on to next
1147   090B B7          	OR      A               ; Is it end of word?
1148   090C F2 04 09    	JP      P,OUTWRD        ; No - output the rest
1149   090F C3 EB 08    	JP      LSTLP3          ; Next byte in line
1150   0912             
1151   0912 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1152   0913 2A D8 22    	LD      HL,(LINESN)     ; Get LINES number
1153   0916 22 D6 22    	LD      (LINESC),HL     ; Save in LINES counter
1154   0919 E1          	POP     HL
1155   091A C9          	RET
1156   091B             
1157   091B E5          COUNT:  PUSH    HL              ; Save code string address
1158   091C D5          	PUSH    DE
1159   091D 2A D6 22    	LD      HL,(LINESC)     ; Get LINES counter
1160   0920 11 FF FF    	LD      DE,-1
1161   0923 ED 5A       	ADC     HL,DE           ; Decrement
1162   0925 22 D6 22    	LD      (LINESC),HL     ; Put it back
1163   0928 D1          	POP     DE
1164   0929 E1          	POP     HL              ; Restore code string address
1165   092A F0          	RET     P               ; Return if more lines to go
1166   092B E5          	PUSH    HL              ; Save code string address
1167   092C 2A D8 22    	LD      HL,(LINESN)     ; Get LINES number
1168   092F 22 D6 22    	LD      (LINESC),HL     ; Reset LINES counter
1169   0932 CD 24 1D    	CALL    GETINP          ; Get input character
1170   0935 FE 03       	CP      CTRLC           ; Is it control "C"?
1171   0937 CA 3E 09    	JP      Z,RSLNBK        ; Yes - Reset LINES and break
1172   093A E1          	POP     HL              ; Restore code string address
1173   093B C3 1B 09    	JP      COUNT           ; Keep on counting
1174   093E             
1175   093E 2A D8 22    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1176   0941 22 D6 22    	LD      (LINESC),HL     ; Reset LINES counter
1177   0944 C3 6B 01    	JP      BRKRET          ; Go and output "Break"
1178   0947             
1179   0947 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1180   0949 32 5B 23    	LD      (FORFLG),A      ; Save "FOR" flag
1181   094C CD CD 0B    	CALL    LET             ; Set up initial index
1182   094F C1          	POP     BC              ; Drop RETurn address
1183   0950 E5          	PUSH    HL              ; Save code string address
1184   0951 CD B6 0B    	CALL    DATA            ; Get next statement address
1185   0954 22 57 23    	LD      (LOOPST),HL     ; Save it for start of loop
1186   0957 21 02 00    	LD      HL,2            ; Offset for "FOR" block
1187   095A 39          	ADD     HL,SP           ; Point to it
1188   095B CD 3F 05    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1189   095E D1          	POP     DE              ; Get code string address
1190   095F C2 77 09    	JP      NZ,FORFND       ; No nesting found
1191   0962 09          	ADD     HL,BC           ; Move into "FOR" block
1192   0963 D5          	PUSH    DE              ; Save code string address
1193   0964 2B          	DEC     HL
1194   0965 56          	LD      D,(HL)          ; Get MSB of loop statement
1195   0966 2B          	DEC     HL
1196   0967 5E          	LD      E,(HL)          ; Get LSB of loop statement
1197   0968 23          	INC     HL
1198   0969 23          	INC     HL
1199   096A E5          	PUSH    HL              ; Save block address
1200   096B 2A 57 23    	LD      HL,(LOOPST)     ; Get address of loop statement
1201   096E CD 60 08    	CALL    CPDEHL          ; Compare the FOR loops
1202   0971 E1          	POP     HL              ; Restore block address
1203   0972 C2 5B 09    	JP      NZ,FORSLP       ; Different FORs - Find another
1204   0975 D1          	POP     DE              ; Restore code string address
1205   0976 F9          	LD      SP,HL           ; Remove all nested loops
1206   0977             
1207   0977 EB          FORFND: EX      DE,HL           ; Code string address to HL
1208   0978 0E 08       	LD      C,8
1209   097A CD 6F 05    	CALL    CHKSTK          ; Check for 8 levels of stack
1210   097D E5          	PUSH    HL              ; Save code string address
1211   097E 2A 57 23    	LD      HL,(LOOPST)     ; Get first statement of loop
1212   0981 E3          	EX      (SP),HL         ; Save and restore code string
1213   0982 E5          	PUSH    HL              ; Re-save code string address
1214   0983 2A EC 22    	LD      HL,(LINEAT)     ; Get current line number
1215   0986 E3          	EX      (SP),HL         ; Save and restore code string
1216   0987 CD 8F 0E    	CALL    TSTNUM          ; Make sure it's a number
1217   098A CD 66 08    	CALL    CHKSYN          ; Make sure "TO" is next
1218   098D A6          	.BYTE   ZTO          ; "TO" token
1219   098E CD 8C 0E    	CALL    GETNUM          ; Get "TO" expression value
1220   0991 E5          	PUSH    HL              ; Save code string address
1221   0992 CD BA 18    	CALL    BCDEFP          ; Move "TO" value to BCDE
1222   0995 E1          	POP     HL              ; Restore code string address
1223   0996 C5          	PUSH    BC              ; Save "TO" value in block
1224   0997 D5          	PUSH    DE
1225   0998 01 00 81    	LD      BC,8100H        ; BCDE - 1 (default STEP)
1226   099B 51          	LD      D,C             ; C=0
1227   099C 5A          	LD      E,D             ; D=0
1228   099D 7E          	LD      A,(HL)          ; Get next byte in code string
1229   099E FE AB       	CP      ZSTEP           ; See if "STEP" is stated
1230   09A0 3E 01       	LD      A,1             ; Sign of step = 1
1231   09A2 C2 B3 09    	JP      NZ,SAVSTP       ; No STEP given - Default to 1
1232   09A5 CD 00 0A    	CALL    GETCHR          ; Jump over "STEP" token
1233   09A8 CD 8C 0E    	CALL    GETNUM          ; Get step value
1234   09AB E5          	PUSH    HL              ; Save code string address
1235   09AC CD BA 18    	CALL    BCDEFP          ; Move STEP to BCDE
1236   09AF CD 6E 18    	CALL    TSTSGN          ; Test sign of FPREG
1237   09B2 E1          	POP     HL              ; Restore code string address
1238   09B3 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1239   09B4 D5          	PUSH    DE
1240   09B5 F5          	PUSH    AF              ; Save sign of STEP
1241   09B6 33          	INC     SP              ; Don't save flags
1242   09B7 E5          	PUSH    HL              ; Save code string address
1243   09B8 2A 5E 23    	LD      HL,(BRKLIN)     ; Get address of index variable
1244   09BB E3          	EX      (SP),HL         ; Save and restore code string
1245   09BC 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1246   09BE C5          	PUSH    BC              ; Save it
1247   09BF 33          	INC     SP              ; Don't save C
1248   09C0             
1249   09C0 CD 2B 0A    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1250   09C3 22 5E 23    	LD      (BRKLIN),HL     ; Save code address for break
1251   09C6 7E          	LD      A,(HL)          ; Get next byte in code string
1252   09C7 FE 3A       	CP      ':'             ; Multi statement line?
1253   09C9 CA E0 09    	JP      Z,EXCUTE        ; Yes - Execute it
1254   09CC B7          	OR      A               ; End of line?
1255   09CD C2 92 05    	JP      NZ,SNERR        ; No - Syntax error
1256   09D0 23          	INC     HL              ; Point to address of next line
1257   09D1 7E          	LD      A,(HL)          ; Get LSB of line pointer
1258   09D2 23          	INC     HL
1259   09D3 B6          	OR      (HL)            ; Is it zero (End of prog)?
1260   09D4 CA 71 0A    	JP      Z,ENDPRG        ; Yes - Terminate execution
1261   09D7 23          	INC     HL              ; Point to line number
1262   09D8 5E          	LD      E,(HL)          ; Get LSB of line number
1263   09D9 23          	INC     HL
1264   09DA 56          	LD      D,(HL)          ; Get MSB of line number
1265   09DB EB          	EX      DE,HL           ; Line number to HL
1266   09DC 22 EC 22    	LD      (LINEAT),HL     ; Save as current line number
1267   09DF EB          	EX      DE,HL           ; Line number back to DE
1268   09E0 CD 00 0A    EXCUTE: CALL    GETCHR          ; Get key word
1269   09E3 11 C0 09    	LD      DE,RUNCNT       ; Where to RETurn to
1270   09E6 D5          	PUSH    DE              ; Save for RETurn
1271   09E7 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1272   09E8 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1273   09EA DA CD 0B    	JP      C,LET           ; No - try to assign it
1274   09ED FE 27       	CP      ZNEW+1-ZEND     ; END to NEW ?
1275   09EF D2 92 05    	JP      NC,SNERR        ; Not a key word - ?SN Error
1276   09F2 07          	RLCA                    ; Double it
1277   09F3 4F          	LD      C,A             ; BC = Offset into table
1278   09F4 06 00       	LD      B,0
1279   09F6 EB          	EX      DE,HL           ; Save code string address
1280   09F7 21 20 03    	LD      HL,WORDTB       ; Keyword address table
1281   09FA 09          	ADD     HL,BC           ; Point to routine address
1282   09FB 4E          	LD      C,(HL)          ; Get LSB of routine address
1283   09FC 23          	INC     HL
1284   09FD 46          	LD      B,(HL)          ; Get MSB of routine address
1285   09FE C5          	PUSH    BC              ; Save routine address
1286   09FF EB          	EX      DE,HL           ; Restore code string address
1287   0A00             
1288   0A00 23          GETCHR: INC     HL              ; Point to next character
1289   0A01 7E          	LD      A,(HL)          ; Get next code string byte
1290   0A02 FE 3A       	CP      ':'             ; Z if ':'
1291   0A04 D0          	RET     NC              ; NC if > "9"
1292   0A05 FE 20       	CP      ' '
1293   0A07 CA 00 0A    	JP      Z,GETCHR        ; Skip over spaces
1294   0A0A FE 30       	CP      '0'
1295   0A0C 3F          	CCF                     ; NC if < '0'
1296   0A0D 3C          	INC     A               ; Test for zero - Leave carry
1297   0A0E 3D          	DEC     A               ; Z if Null
1298   0A0F C9          	RET
1299   0A10             
1300   0A10 EB          RESTOR: EX      DE,HL           ; Save code string address
1301   0A11 2A EE 22    	LD      HL,(BASTXT)     ; Point to start of program
1302   0A14 CA 25 0A    	JP      Z,RESTNL        ; Just RESTORE - reset pointer
1303   0A17 EB          	EX      DE,HL           ; Restore code string address
1304   0A18 CD EB 0A    	CALL    ATOH            ; Get line number to DE
1305   0A1B E5          	PUSH    HL              ; Save code string address
1306   0A1C CD 84 06    	CALL    SRCHLN          ; Search for line number in DE
1307   0A1F 60          	LD      H,B             ; HL = Address of line
1308   0A20 69          	LD      L,C
1309   0A21 D1          	POP     DE              ; Restore code string address
1310   0A22 D2 8C 0B    	JP      NC,ULERR        ; ?UL Error if not found
1311   0A25 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1312   0A26 22 6C 23    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1313   0A29 EB          	EX      DE,HL           ; Restore code string address
1314   0A2A C9          	RET
1315   0A2B             
1316   0A2B             ;        GET CONSOLE INPUT STATUS VIA HBIOS
1317   0A2B             
1318   0A2B             TSTBRK:
1319   0A2B C5          	PUSH    BC              ; SAVE INCOMING REGISTERS (AF IS OUTPUT)
1320   0A2C D5          	PUSH    DE
1321   0A2D E5          	PUSH    HL
1322   0A2E             
1323   0A2E 0E 0B       	cpm.cStat()
1323   0A30 CD 05 00    
1324   0A33             
1325   0A33 B7          	OR      A
1326   0A34 20 04       	JR      NZ, skip
1327   0A36             
1328   0A36 E1          	POP     HL              ; RESTORE REGISTERS (AF IS OUTPUT)
1329   0A37 D1          	POP     DE
1330   0A38 C1          	POP     BC
1331   0A39 C9          	RET
1332   0A3A             
1333   0A3A             skip:
1334   0A3A 0E 01       	cpm.cReadChr()
1334   0A3C CD 05 00    
1335   0A3F E1          	POP     HL              ; RESTORE REGISTERS (AF IS OUTPUT)
1336   0A40 D1          	POP     DE
1337   0A41 C1          	POP     BC
1338   0A42             
1339   0A42 FE 1B       	CP      ESC             ; Escape key?
1340   0A44 28 1C       	JR      Z,BRK           ; Yes, break
1341   0A46 FE 03       	CP      CTRLC           ; <Ctrl-C>
1342   0A48 28 18       	JR      Z,BRK           ; Yes, break
1343   0A4A FE 13       	CP      CTRLS           ; Stop scrolling?
1344   0A4C C0          	RET     NZ              ; Other key, ignore
1345   0A4D             STALL:                          ; Wait for key
1346   0A4D             
1347   0A4D C5          	PUSH    BC              ; SAVE INCOMING REGISTERS (AF IS OUTPUT)
1348   0A4E D5          	PUSH    DE
1349   0A4F E5          	PUSH    HL
1350   0A50             ;
1351   0A50             ;       INPUT CHARACTER FROM CONSOLE VIA HBIOS
1352   0A50             ;
1353   0A50 0E D0       	LD      C,CIODEV_CONSOLE; CONSOLE UNIT TO C
1354   0A52 06 00       	LD      B,BF_CIOIN      ; HBIOS FUNC: INPUT CHAR
1355   0A54 CF          	RST     08              ; HBIOS READS CHARACTDR
1356   0A55 7B          	LD      A,E             ; MOVE CHARACTER TO A FOR RETURN
1357   0A56             ;
1358   0A56 E1          	POP     HL              ; RESTORE REGISTERS (AF IS OUTPUT)
1359   0A57 D1          	POP     DE
1360   0A58 C1          	POP     BC
1361   0A59 FE 11       	CP      CTRLQ           ; Resume scrolling?
1362   0A5B C8          	RET      Z              ; Release the chokehold
1363   0A5C FE 03       	CP      CTRLC           ; Second break?
1364   0A5E 28 07       	JR      Z,STOP          ; Break during hold exits prog
1365   0A60 18 EB       	JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1366   0A62             
1367   0A62 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1368   0A64 32 DD 22    	LD      (BRKFLG),A      ; Store it
1369   0A67             
1370   0A67 C0          STOP:   RET     NZ              ; Exit if anything else
1371   0A68 F6          	.BYTE   0F6H            ; Flag "STOP"
1372   0A69 C0          PEND:   RET     NZ              ; Exit if anything else
1373   0A6A 22 5E 23    	LD      (BRKLIN),HL     ; Save point of break
1374   0A6D 21          	.BYTE   21H             ; Skip "OR 11111111B"
1375   0A6E F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1376   0A70 C1          	POP     BC              ; Return not needed and more
1377   0A71 2A EC 22    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1378   0A74 F5          	PUSH    AF              ; Save STOP / END status
1379   0A75 7D          	LD      A,L             ; Is it direct break?
1380   0A76 A4          	AND     H
1381   0A77 3C          	INC     A               ; Line is -1 if direct break
1382   0A78 CA 84 0A    	JP      Z,NOLIN         ; Yes - No line number
1383   0A7B 22 62 23    	LD      (ERRLIN),HL     ; Save line of break
1384   0A7E 2A 5E 23    	LD      HL,(BRKLIN)     ; Get point of break
1385   0A81 22 64 23    	LD      (CONTAD),HL     ; Save point to CONTinue
1386   0A84 AF          NOLIN:  XOR     A
1387   0A85 32 D5 22    	LD      (CTLOFG),A      ; Enable output
1388   0A88 CD BA 0C    	CALL    STTLIN          ; Start a new line
1389   0A8B F1          	POP     AF              ; Restore STOP / END status
1390   0A8C 21 35 05    	LD      HL,BRKMSG       ; "Break" message
1391   0A8F C2 CC 05    	JP      NZ,ERRIN        ; "in line" wanted?
1392   0A92 C3 E3 05    	JP      PRNTOK          ; Go to command mode
1393   0A95             
1394   0A95 2A 64 23    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1395   0A98 7C          	LD      A,H             ; Is it zero?
1396   0A99 B5          	OR      L
1397   0A9A 1E 20       	LD      E,CN            ; ?CN Error
1398   0A9C CA A6 05    	JP      Z,ERROR         ; Yes - output "?CN Error"
1399   0A9F EB          	EX      DE,HL           ; Save code string address
1400   0AA0 2A 62 23    	LD      HL,(ERRLIN)     ; Get line of last break
1401   0AA3 22 EC 22    	LD      (LINEAT),HL     ; Set up current line number
1402   0AA6 EB          	EX      DE,HL           ; Restore code string address
1403   0AA7 C9          	RET                     ; CONTinue where left off
1404   0AA8             
1405   0AA8 CD ED 15    NULL:   CALL    GETINT          ; Get integer 0-255
1406   0AAB C0          	RET     NZ              ; Return if bad value
1407   0AAC 32 D1 22    	LD      (NULLS),A       ; Set nulls number
1408   0AAF C9          	RET
1409   0AB0             
1410   0AB0 E5          ACCSUM: PUSH    HL              ; Save address in array
1411   0AB1 2A DA 22    	LD      HL,(CHKSUM)     ; Get check sum
1412   0AB4 06 00       	LD      B,0             ; BC - Value of byte
1413   0AB6 4F          	LD      C,A
1414   0AB7 09          	ADD     HL,BC           ; Add byte to check sum
1415   0AB8 22 DA 22    	LD      (CHKSUM),HL     ; Re-save check sum
1416   0ABB E1          	POP     HL              ; Restore address in array
1417   0ABC C9          	RET
1418   0ABD             
1419   0ABD 7E          CHKLTR: LD      A,(HL)          ; Get byte
1420   0ABE FE 41       	CP      'A'             ; < 'a' ?
1421   0AC0 D8          	RET     C               ; Carry set if not letter
1422   0AC1 FE 5B       	CP      'Z'+1           ; > 'z' ?
1423   0AC3 3F          	CCF
1424   0AC4 C9          	RET                     ; Carry set if not letter
1425   0AC5             
1426   0AC5 CD 00 0A    FPSINT: CALL    GETCHR          ; Get next character
1427   0AC8 CD 8C 0E    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1428   0ACB CD 6E 18    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1429   0ACE FA E6 0A    	JP      M,FCERR         ; Negative - ?FC Error
1430   0AD1 3A 77 23    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1431   0AD4 FE 90       	CP      80H+16          ; Exponent in range (16 bits)?
1432   0AD6 DA 16 19    	JP      C,FPINT         ; Yes - convert it
1433   0AD9 01 80 90    	LD      BC,9080H        ; BCDE = -32768
1434   0ADC 11 00 00    	LD      DE,0000
1435   0ADF E5          	PUSH    HL              ; Save code string address
1436   0AE0 CD E9 18    	CALL    CMPNUM          ; Compare FPREG with BCDE
1437   0AE3 E1          	POP     HL              ; Restore code string address
1438   0AE4 51          	LD      D,C             ; MSB to D
1439   0AE5 C8          	RET     Z               ; Return if in range
1440   0AE6 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1441   0AE8 C3 A6 05    	JP      ERROR           ; Output error-
1442   0AEB             
1443   0AEB 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1444   0AEC 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1445   0AEF CD 00 0A    GTLNLP: CALL    GETCHR          ; Get next character
1446   0AF2 D0          	RET     NC              ; Exit if not a digit
1447   0AF3 E5          	PUSH    HL              ; Save code string address
1448   0AF4 F5          	PUSH    AF              ; Save digit
1449   0AF5 21 98 19    	LD      HL,65529/10     ; Largest number 65529
1450   0AF8 CD 60 08    	CALL    CPDEHL          ; Number in range?
1451   0AFB DA 92 05    	JP      C,SNERR         ; No - ?SN Error
1452   0AFE 62          	LD      H,D             ; HL = Number
1453   0AFF 6B          	LD      L,E
1454   0B00 19          	ADD     HL,DE           ; Times 2
1455   0B01 29          	ADD     HL,HL           ; Times 4
1456   0B02 19          	ADD     HL,DE           ; Times 5
1457   0B03 29          	ADD     HL,HL           ; Times 10
1458   0B04 F1          	POP     AF              ; Restore digit
1459   0B05 D6 30       	SUB     '0'             ; Make it 0 to 9
1460   0B07 5F          	LD      E,A             ; DE = Value of digit
1461   0B08 16 00       	LD      D,0
1462   0B0A 19          	ADD     HL,DE           ; Add to number
1463   0B0B EB          	EX      DE,HL           ; Number to DE
1464   0B0C E1          	POP     HL              ; Restore code string address
1465   0B0D C3 EF 0A    	JP      GTLNLP          ; Go to next character
1466   0B10             
1467   0B10 CA B4 06    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1468   0B13 CD C8 0A    	CALL    POSINT          ; Get integer 0 to 32767 to DE
1469   0B16 2B          	DEC     HL              ; Cancel increment
1470   0B17 CD 00 0A    	CALL    GETCHR          ; Get next character
1471   0B1A E5          	PUSH    HL              ; Save code string address
1472   0B1B 2A 3F 23    	LD      HL,(LSTRAM)     ; Get end of RAM
1473   0B1E CA 33 0B    	JP      Z,STORED        ; No value given - Use stored
1474   0B21 E1          	POP     HL              ; Restore code string address
1475   0B22 CD 66 08    	CALL    CHKSYN          ; Check for comma
1476   0B25 2C          	.BYTE      ','
1477   0B26 D5          	PUSH    DE              ; Save number
1478   0B27 CD C8 0A    	CALL    POSINT          ; Get integer 0 to 32767
1479   0B2A 2B          	DEC     HL              ; Cancel increment
1480   0B2B CD 00 0A    	CALL    GETCHR          ; Get next character
1481   0B2E C2 92 05    	JP      NZ,SNERR        ; ?SN Error if more on line
1482   0B31 E3          	EX      (SP),HL         ; Save code string address
1483   0B32 EB          	EX      DE,HL           ; Number to DE
1484   0B33 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1485   0B34 93          	SUB     E               ; Subtract LSB of string space
1486   0B35 5F          	LD      E,A             ; Save LSB
1487   0B36 7C          	LD      A,H             ; Get MSB of new RAM top
1488   0B37 9A          	SBC     A,D             ; Subtract MSB of string space
1489   0B38 57          	LD      D,A             ; Save MSB
1490   0B39 DA 87 05    	JP      C,OMERR         ; ?OM Error if not enough mem
1491   0B3C E5          	PUSH    HL              ; Save RAM top
1492   0B3D 2A 66 23    	LD      HL,(PROGND)     ; Get program end
1493   0B40 01 28 00    	LD      BC,40           ; 40 Bytes minimum working RAM
1494   0B43 09          	ADD     HL,BC           ; Get lowest address
1495   0B44 CD 60 08    	CALL    CPDEHL          ; Enough memory?
1496   0B47 D2 87 05    	JP      NC,OMERR        ; No - ?OM Error
1497   0B4A EB          	EX      DE,HL           ; RAM top to HL
1498   0B4B 22 EA 22    	LD      (STRSPC),HL     ; Set new string space
1499   0B4E E1          	POP     HL              ; End of memory to use
1500   0B4F 22 3F 23    	LD      (LSTRAM),HL     ; Set new top of RAM
1501   0B52 E1          	POP     HL              ; Restore code string address
1502   0B53 C3 B4 06    	JP      INTVAR          ; Initialise variables
1503   0B56             
1504   0B56 CA B0 06    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1505   0B59 CD B4 06    	CALL    INTVAR          ; Initialise variables
1506   0B5C 01 C0 09    	LD      BC,RUNCNT       ; Execution driver loop
1507   0B5F C3 72 0B    	JP      RUNLIN          ; RUN from line number
1508   0B62             
1509   0B62 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1510   0B64 CD 6F 05    	CALL    CHKSTK          ; Check for 3 levels of stack
1511   0B67 C1          	POP     BC              ; Get return address
1512   0B68 E5          	PUSH    HL              ; Save code string for RETURN
1513   0B69 E5          	PUSH    HL              ; And for GOSUB routine
1514   0B6A 2A EC 22    	LD      HL,(LINEAT)     ; Get current line
1515   0B6D E3          	EX      (SP),HL         ; Into stack - Code string out
1516   0B6E 3E 8C       	LD      A,ZGOSUB        ; "GOSUB" token
1517   0B70 F5          	PUSH    AF              ; Save token
1518   0B71 33          	INC     SP              ; Don't save flags
1519   0B72             
1520   0B72 C5          RUNLIN: PUSH    BC              ; Save return address
1521   0B73 CD EB 0A    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1522   0B76 CD B8 0B    	CALL    REM             ; Get end of line
1523   0B79 E5          	PUSH    HL              ; Save end of line
1524   0B7A 2A EC 22    	LD      HL,(LINEAT)     ; Get current line
1525   0B7D CD 60 08    	CALL    CPDEHL          ; Line after current?
1526   0B80 E1          	POP     HL              ; Restore end of line
1527   0B81 23          	INC     HL              ; Start of next line
1528   0B82 DC 87 06    	CALL    C,SRCHLP        ; Line is after current line
1529   0B85 D4 84 06    	CALL    NC,SRCHLN       ; Line is before current line
1530   0B88 60          	LD      H,B             ; Set up code string address
1531   0B89 69          	LD      L,C
1532   0B8A 2B          	DEC     HL              ; Incremented after
1533   0B8B D8          	RET     C               ; Line found
1534   0B8C 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1535   0B8E C3 A6 05    	JP      ERROR           ; Output error message
1536   0B91             
1537   0B91 C0          RETURN: RET     NZ              ; Return if not just RETURN
1538   0B92 16 FF       	LD      D,-1            ; Flag "GOSUB" search
1539   0B94 CD 3B 05    	CALL    BAKSTK          ; Look "GOSUB" block
1540   0B97 F9          	LD      SP,HL           ; Kill all FORs in subroutine
1541   0B98 FE 8C       	CP      ZGOSUB          ; Test for "GOSUB" token
1542   0B9A 1E 04       	LD      E,RG            ; ?RG Error
1543   0B9C C2 A6 05    	JP      NZ,ERROR        ; Error if no "GOSUB" found
1544   0B9F E1          	POP     HL              ; Get RETURN line number
1545   0BA0 22 EC 22    	LD      (LINEAT),HL     ; Save as current
1546   0BA3 23          	INC     HL              ; Was it from direct statement?
1547   0BA4 7C          	LD      A,H
1548   0BA5 B5          	OR      L               ; Return to line
1549   0BA6 C2 B0 0B    	JP      NZ,RETLIN       ; No - Return to line
1550   0BA9 3A 5C 23    	LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1551   0BAC B7          	OR      A               ; If so buffer is corrupted
1552   0BAD C2 E2 05    	JP      NZ,POPNOK       ; Yes - Go to command mode
1553   0BB0 21 C0 09    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1554   0BB3 E3          	EX      (SP),HL         ; Into stack - Code string out
1555   0BB4 3E          	.BYTE      3EH             ; Skip "POP HL"
1556   0BB5 E1          NXTDTA: POP     HL              ; Restore code string address
1557   0BB6             
1558   0BB6 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1559   0BB8 0E 00       REM:    LD      C,0             ; 00  End of statement
1560   0BBA 06 00       	LD      B,0
1561   0BBC 79          NXTSTL: LD      A,C             ; Statement and byte
1562   0BBD 48          	LD      C,B
1563   0BBE 47          	LD      B,A             ; Statement end byte
1564   0BBF 7E          NXTSTT: LD      A,(HL)          ; Get byte
1565   0BC0 B7          	OR      A               ; End of line?
1566   0BC1 C8          	RET     Z               ; Yes - Exit
1567   0BC2 B8          	CP      B               ; End of statement?
1568   0BC3 C8          	RET     Z               ; Yes - Exit
1569   0BC4 23          	INC     HL              ; Next byte
1570   0BC5 FE 22       	CP      '"'             ; Literal string?
1571   0BC7 CA BC 0B    	JP      Z,NXTSTL        ; Yes - Look for another '"'
1572   0BCA C3 BF 0B    	JP      NXTSTT          ; Keep looking
1573   0BCD             
1574   0BCD CD 82 10    LET:    CALL    GETVAR          ; Get variable name
1575   0BD0 CD 66 08    	CALL    CHKSYN          ; Make sure "=" follows
1576   0BD3 B4          	.BYTE      ZEQUAL          ; "=" token
1577   0BD4 D5          	PUSH    DE              ; Save address of variable
1578   0BD5 3A 3D 23    	LD      A,(TYPE)        ; Get data type
1579   0BD8 F5          	PUSH    AF              ; Save type
1580   0BD9 CD 9E 0E    	CALL    EVAL            ; Evaluate expression
1581   0BDC F1          	POP     AF              ; Restore type
1582   0BDD E3          	EX      (SP),HL         ; Save code - Get var addr
1583   0BDE 22 5E 23    	LD      (BRKLIN),HL     ; Save address of variable
1584   0BE1 1F          	RRA                     ; Adjust type
1585   0BE2 CD 91 0E    	CALL    CHKTYP          ; Check types are the same
1586   0BE5 CA 20 0C    	JP      Z,LETNUM        ; Numeric - Move value
1587   0BE8 E5          LETSTR: PUSH    HL              ; Save address of string var
1588   0BE9 2A 74 23    	LD      HL,(FPREG)      ; Pointer to string entry
1589   0BEC E5          	PUSH    HL              ; Save it on stack
1590   0BED 23          	INC     HL              ; Skip over length
1591   0BEE 23          	INC     HL
1592   0BEF 5E          	LD      E,(HL)          ; LSB of string address
1593   0BF0 23          	INC     HL
1594   0BF1 56          	LD      D,(HL)          ; MSB of string address
1595   0BF2 2A EE 22    	LD      HL,(BASTXT)     ; Point to start of program
1596   0BF5 CD 60 08    	CALL    CPDEHL          ; Is string before program?
1597   0BF8 D2 0F 0C    	JP      NC,CRESTR       ; Yes - Create string entry
1598   0BFB 2A EA 22    	LD      HL,(STRSPC)     ; Point to string space
1599   0BFE CD 60 08    	CALL    CPDEHL          ; Is string literal in program?
1600   0C01 D1          	POP     DE              ; Restore address of string
1601   0C02 D2 17 0C    	JP      NC,MVSTPT       ; Yes - Set up pointer
1602   0C05 21 4F 23    	LD      HL,TMPSTR       ; Temporary string pool
1603   0C08 CD 60 08    	CALL    CPDEHL          ; Is string in temporary pool?
1604   0C0B D2 17 0C    	JP      NC,MVSTPT       ; No - Set up pointer
1605   0C0E 3E          	.BYTE   3EH             ; Skip "POP DE"
1606   0C0F D1          CRESTR: POP     DE              ; Restore address of string
1607   0C10 CD C6 14    	CALL    BAKTMP          ; Back to last tmp-str entry
1608   0C13 EB          	EX      DE,HL           ; Address of string entry
1609   0C14 CD FF 12    	CALL    SAVSTR          ; Save string in string area
1610   0C17 CD C6 14    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1611   0C1A E1          	POP     HL              ; Get string pointer
1612   0C1B CD C9 18    	CALL    DETHL4          ; Move string pointer to var
1613   0C1E E1          	POP     HL              ; Restore code string address
1614   0C1F C9          	RET
1615   0C20             
1616   0C20 E5          LETNUM: PUSH    HL              ; Save address of variable
1617   0C21 CD C6 18    	CALL    FPTHL           ; Move value to variable
1618   0C24 D1          	POP     DE              ; Restore address of variable
1619   0C25 E1          	POP     HL              ; Restore code string address
1620   0C26 C9          	RET
1621   0C27             
1622   0C27 CD ED 15    ON:     CALL    GETINT          ; Get integer 0-255
1623   0C2A 7E          	LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1624   0C2B 47          	LD      B,A             ; Save in B
1625   0C2C FE 8C       	CP      ZGOSUB          ; "GOSUB" token?
1626   0C2E CA 36 0C    	JP      Z,ONGO          ; Yes - Find line number
1627   0C31 CD 66 08    	CALL    CHKSYN          ; Make sure it's "GOTO"
1628   0C34 88          	.BYTE   ZGOTO           ; "GOTO" token
1629   0C35 2B          	DEC     HL              ; Cancel increment
1630   0C36 4B          ONGO:   LD      C,E             ; Integer of branch value
1631   0C37 0D          ONGOLP: DEC     C               ; Count branches
1632   0C38 78          	LD      A,B             ; Get "GOTO" or "GOSUB" token
1633   0C39 CA E8 09    	JP      Z,ONJMP         ; Go to that line if right one
1634   0C3C CD EC 0A    	CALL    GETLN           ; Get line number to DE
1635   0C3F FE 2C       	CP      ','             ; Another line number?
1636   0C41 C0          	RET     NZ              ; No - Drop through
1637   0C42 C3 37 0C    	JP      ONGOLP          ; Yes - loop
1638   0C45             
1639   0C45 CD 9E 0E    IF:     CALL    EVAL            ; Evaluate expression
1640   0C48 7E          	LD      A,(HL)          ; Get token
1641   0C49 FE 88       	CP      ZGOTO           ; "GOTO" token?
1642   0C4B CA 53 0C    	JP      Z,IFGO          ; Yes - Get line
1643   0C4E CD 66 08    	CALL    CHKSYN          ; Make sure it's "THEN"
1644   0C51 A9          	.BYTE      ZTHEN           ; "THEN" token
1645   0C52 2B          	DEC     HL              ; Cancel increment
1646   0C53 CD 8F 0E    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1647   0C56 CD 6E 18    	CALL    TSTSGN          ; Test state of expression
1648   0C59 CA B8 0B    	JP      Z,REM           ; False - Drop through
1649   0C5C CD 00 0A    	CALL    GETCHR          ; Get next character
1650   0C5F DA 73 0B    	JP      C,GOTO          ; Number - GOTO that line
1651   0C62 C3 E7 09    	JP      IFJMP           ; Otherwise do statement
1652   0C65             
1653   0C65 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1654   0C66 CD 00 0A    	CALL    GETCHR          ; Get next character
1655   0C69 CA C7 0C    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1656   0C6C C8          PRNTLP: RET     Z               ; End of list - Exit
1657   0C6D FE A5       	CP      ZTAB            ; "TAB(" token?
1658   0C6F CA FA 0C    	JP      Z,DOTAB         ; Yes - Do TAB routine
1659   0C72 FE A8       	CP      ZSPC            ; "SPC(" token?
1660   0C74 CA FA 0C    	JP      Z,DOTAB         ; Yes - Do SPC routine
1661   0C77 E5          	PUSH    HL              ; Save code string address
1662   0C78 FE 2C       	CP      ','             ; Comma?
1663   0C7A CA E3 0C    	JP      Z,DOCOM         ; Yes - Move to next zone
1664   0C7D FE 3B       	CP      59 ;";"         ; Semi-colon?
1665   0C7F CA 1D 0D    	JP      Z,NEXITM        ; Do semi-colon routine
1666   0C82 C1          	POP     BC              ; Code string address to BC
1667   0C83 CD 9E 0E    	CALL    EVAL            ; Evaluate expression
1668   0C86 E5          	PUSH    HL              ; Save code string address
1669   0C87 3A 3D 23    	LD      A,(TYPE)        ; Get variable type
1670   0C8A B7          	OR      A               ; Is it a string variable?
1671   0C8B C2 B3 0C    	JP      NZ,PRNTST       ; Yes - Output string contents
1672   0C8E CD 13 1A    	CALL    NUMASC          ; Convert number to text
1673   0C91 CD 23 13    	CALL    CRTST           ; Create temporary string
1674   0C94 36 20       	LD      (HL),' '        ; Followed by a space
1675   0C96 2A 74 23    	LD      HL,(FPREG)      ; Get length of output
1676   0C99 34          	INC     (HL)            ; Plus 1 for the space
1677   0C9A 2A 74 23    	LD      HL,(FPREG)      ; < Not needed >
1678   0C9D 3A D2 22    	LD      A,(LWIDTH)      ; Get width of line
1679   0CA0 47          	LD      B,A             ; To B
1680   0CA1 04          	INC     B               ; Width 255 (No limit)?
1681   0CA2 CA AF 0C    	JP      Z,PRNTNB        ; Yes - Output number string
1682   0CA5 04          	INC     B               ; Adjust it
1683   0CA6 3A 3B 23    	LD      A,(CURPOS)      ; Get cursor position
1684   0CA9 86          	ADD     A,(HL)          ; Add length of string
1685   0CAA 3D          	DEC     A               ; Adjust it
1686   0CAB B8          	CP      B               ; Will output fit on this line?
1687   0CAC D4 C7 0C    	CALL    NC,PRNTCRLF     ; No - CRLF first
1688   0CAF CD 68 13    PRNTNB: CALL    PRS1            ; Output string at (HL)
1689   0CB2 AF          	XOR     A               ; Skip CALL by setting 'z' flag
1690   0CB3 C4 68 13    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1691   0CB6 E1          	POP     HL              ; Restore code string address
1692   0CB7 C3 65 0C    	JP      MRPRNT          ; See if more to PRINT
1693   0CBA             
1694   0CBA 3A 3B 23    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1695   0CBD B7          	OR      A               ; Already at start?
1696   0CBE C8          	RET     Z               ; Yes - Do nothing
1697   0CBF C3 C7 0C    	JP      PRNTCRLF        ; Start a new line
1698   0CC2             
1699   0CC2 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1700   0CC4 21 F0 22    	LD      HL,BUFFER-1     ; Point to buffer
1701   0CC7 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1702   0CC9 CD 71 08    	CALL    OUTC            ; Output character
1703   0CCC 3E 0A       	LD      A,LF           ; Load a LF
1704   0CCE CD 71 08    	CALL    OUTC            ; Output character
1705   0CD1 AF          DONULL: XOR     A               ; Set to position 0
1706   0CD2 32 3B 23    	LD      (CURPOS),A      ; Store it
1707   0CD5 3A D1 22    	LD      A,(NULLS)       ; Get number of nulls
1708   0CD8 3D          NULLP:  DEC     A               ; Count them
1709   0CD9 C8          	RET     Z               ; Return if done
1710   0CDA F5          	PUSH    AF              ; Save count
1711   0CDB AF          	XOR     A               ; Load a null
1712   0CDC CD 71 08    	CALL    OUTC            ; Output it
1713   0CDF F1          	POP     AF              ; Restore count
1714   0CE0 C3 D8 0C    	JP      NULLP           ; Keep counting
1715   0CE3             
1716   0CE3 3A D3 22    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1717   0CE6 47          	LD      B,A             ; Save in B
1718   0CE7 3A 3B 23    	LD      A,(CURPOS)      ; Get current position
1719   0CEA B8          	CP      B               ; Within the limit?
1720   0CEB D4 C7 0C    	CALL    NC,PRNTCRLF     ; No - output CRLF
1721   0CEE D2 1D 0D    	JP      NC,NEXITM       ; Get next item
1722   0CF1 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1723   0CF3 D2 F1 0C    	JP      NC,ZONELP       ; Repeat if more zones
1724   0CF6 2F          	CPL                     ; Number of spaces to output
1725   0CF7 C3 12 0D    	JP      ASPCS           ; Output them
1726   0CFA             
1727   0CFA F5          DOTAB:  PUSH    AF              ; Save token
1728   0CFB CD EA 15    	CALL    FNDNUM          ; Evaluate expression
1729   0CFE CD 66 08    	CALL    CHKSYN          ; Make sure ")" follows
1730   0D01 29          	.BYTE   ")"
1731   0D02 2B          	DEC     HL              ; Back space on to ")"
1732   0D03 F1          	POP     AF              ; Restore token
1733   0D04 D6 A8       	SUB     ZSPC            ; Was it "SPC(" ?
1734   0D06 E5          	PUSH    HL              ; Save code string address
1735   0D07 CA 0D 0D    	JP      Z,DOSPC         ; Yes - Do 'E' spaces
1736   0D0A 3A 3B 23    	LD      A,(CURPOS)      ; Get current position
1737   0D0D 2F          DOSPC:  CPL                     ; Number of spaces to print to
1738   0D0E 83          	ADD     A,E             ; Total number to print
1739   0D0F D2 1D 0D    	JP      NC,NEXITM       ; TAB < Current POS(X)
1740   0D12 3C          ASPCS:  INC     A               ; Output A spaces
1741   0D13 47          	LD      B,A             ; Save number to print
1742   0D14 3E 20       	LD      A,' '           ; Space
1743   0D16 CD 71 08    SPCLP:  CALL    OUTC            ; Output character in A
1744   0D19 05          	DEC     B               ; Count them
1745   0D1A C2 16 0D    	JP      NZ,SPCLP        ; Repeat if more
1746   0D1D E1          NEXITM: POP     HL              ; Restore code string address
1747   0D1E CD 00 0A    	CALL    GETCHR          ; Get next character
1748   0D21 C3 6C 0C    	JP      PRNTLP          ; More to print
1749   0D24             
1750   0D24 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
1750   0D28 6F 20 66 72 
1750   0D2C 6F 6D 20 73 
1750   0D30 74 61 72 74 
1750   0D34 0D 0A 00 
1751   0D37             
1752   0D37 3A 5D 23    BADINP: LD      A,(READFG)      ; READ or INPUT?
1753   0D3A B7          	OR      A
1754   0D3B C2 8C 05    	JP      NZ,DATSNR       ; READ - ?SN Error
1755   0D3E C1          	POP     BC              ; Throw away code string addr
1756   0D3F 21 24 0D    	LD      HL,REDO         ; "Redo from start" message
1757   0D42 CD 65 13    	CALL    PRS             ; Output string
1758   0D45 C3 E3 06    	JP      DOAGN           ; Do last INPUT again
1759   0D48             
1760   0D48 CD D0 12    INPUT:  CALL    IDTEST          ; Test for illegal direct
1761   0D4B 7E          	LD      A,(HL)          ; Get character after "INPUT"
1762   0D4C FE 22       	CP      '"'             ; Is there a prompt string?
1763   0D4E 3E 00       	LD      A,0             ; Clear A and leave flags
1764   0D50 32 D5 22    	LD      (CTLOFG),A      ; Enable output
1765   0D53 C2 62 0D    	JP      NZ,NOPMPT       ; No prompt - get input
1766   0D56 CD 24 13    	CALL    QTSTR           ; Get string terminated by '"'
1767   0D59 CD 66 08    	CALL    CHKSYN          ; Check for ';' after prompt
1768   0D5C 3B          	.BYTE   ';'
1769   0D5D E5          	PUSH    HL              ; Save code string address
1770   0D5E CD 68 13    	CALL    PRS1            ; Output prompt string
1771   0D61 3E          	.BYTE   3EH             ; Skip "PUSH HL"
1772   0D62 E5          NOPMPT: PUSH    HL              ; Save code string address
1773   0D63 CD E7 06    	CALL    PROMPT          ; Get input with "? " prompt
1774   0D66 C1          	POP     BC              ; Restore code string address
1775   0D67 DA 6E 0A    	JP      C,INPBRK        ; Break pressed - Exit
1776   0D6A 23          	INC     HL              ; Next byte
1777   0D6B 7E          	LD      A,(HL)          ; Get it
1778   0D6C B7          	OR      A               ; End of line?
1779   0D6D 2B          	DEC     HL              ; Back again
1780   0D6E C5          	PUSH    BC              ; Re-save code string address
1781   0D6F CA B5 0B    	JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1782   0D72 36 2C       	LD      (HL),','        ; Store comma as separator
1783   0D74 C3 7C 0D    	JP      NXTITM          ; Get next item
1784   0D77             
1785   0D77 E5          READ:   PUSH    HL              ; Save code string address
1786   0D78 2A 6C 23    	LD      HL,(NXTDAT)     ; Next DATA statement
1787   0D7B F6          	.BYTE   0F6H            ; Flag "READ"
1788   0D7C AF          NXTITM: XOR     A               ; Flag "INPUT"
1789   0D7D 32 5D 23    	LD      (READFG),A      ; Save "READ"/"INPUT" flag
1790   0D80 E3          	EX      (SP),HL         ; Get code str' , Save pointer
1791   0D81 C3 88 0D    	JP      GTVLUS          ; Get values
1792   0D84             
1793   0D84 CD 66 08    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1794   0D87 2C          	.BYTE      ','
1795   0D88 CD 82 10    GTVLUS: CALL    GETVAR          ; Get variable name
1796   0D8B E3          	EX      (SP),HL         ; Save code str" , Get pointer
1797   0D8C D5          	PUSH    DE              ; Save variable address
1798   0D8D 7E          	LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1799   0D8E FE 2C       	CP      ','             ; Comma?
1800   0D90 CA B0 0D    	JP      Z,ANTVLU        ; Yes - Get another value
1801   0D93 3A 5D 23    	LD      A,(READFG)      ; Is it READ?
1802   0D96 B7          	OR      A
1803   0D97 C2 1D 0E    	JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1804   0D9A 3E 3F       	LD      A,'?'           ; More INPUT needed
1805   0D9C CD 71 08    	CALL    OUTC            ; Output character
1806   0D9F CD E7 06    	CALL    PROMPT          ; Get INPUT with prompt
1807   0DA2 D1          	POP     DE              ; Variable address
1808   0DA3 C1          	POP     BC              ; Code string address
1809   0DA4 DA 6E 0A    	JP      C,INPBRK        ; Break pressed
1810   0DA7 23          	INC     HL              ; Point to next DATA byte
1811   0DA8 7E          	LD      A,(HL)          ; Get byte
1812   0DA9 B7          	OR      A               ; Is it zero (No input) ?
1813   0DAA 2B          	DEC     HL              ; Back space INPUT pointer
1814   0DAB C5          	PUSH    BC              ; Save code string address
1815   0DAC CA B5 0B    	JP      Z,NXTDTA        ; Find end of buffer
1816   0DAF D5          	PUSH    DE              ; Save variable address
1817   0DB0 3A 3D 23    ANTVLU: LD      A,(TYPE)        ; Check data type
1818   0DB3 B7          	OR      A               ; Is it numeric?
1819   0DB4 CA DA 0D    	JP      Z,INPBIN        ; Yes - Convert to binary
1820   0DB7 CD 00 0A    	CALL    GETCHR          ; Get next character
1821   0DBA 57          	LD      D,A             ; Save input character
1822   0DBB 47          	LD      B,A             ; Again
1823   0DBC FE 22       	CP      '"'             ; Start of literal sting?
1824   0DBE CA CE 0D    	JP      Z,STRENT        ; Yes - Create string entry
1825   0DC1 3A 5D 23    	LD      A,(READFG)      ; "READ" or "INPUT" ?
1826   0DC4 B7          	OR      A
1827   0DC5 57          	LD      D,A             ; Save 00 if "INPUT"
1828   0DC6 CA CB 0D    	JP      Z,ITMSEP        ; "INPUT" - End with 00
1829   0DC9 16 3A       	LD      D,':'           ; "DATA" - End with 00 or ':'
1830   0DCB 06 2C       ITMSEP: LD      B,','           ; Item separator
1831   0DCD 2B          	DEC     HL              ; Back space for DTSTR
1832   0DCE CD 27 13    STRENT: CALL    DTSTR           ; Get string terminated by D
1833   0DD1 EB          	EX      DE,HL           ; String address to DE
1834   0DD2 21 E5 0D    	LD      HL,LTSTND       ; Where to go after LETSTR
1835   0DD5 E3          	EX      (SP),HL         ; Save HL , get input pointer
1836   0DD6 D5          	PUSH    DE              ; Save address of string
1837   0DD7 C3 E8 0B    	JP      LETSTR          ; Assign string to variable
1838   0DDA             
1839   0DDA CD 00 0A    INPBIN: CALL    GETCHR          ; Get next character
1840   0DDD CD 75 19    	CALL    ASCTFP          ; Convert ASCII to FP number
1841   0DE0 E3          	EX      (SP),HL         ; Save input ptr, Get var addr
1842   0DE1 CD C6 18    	CALL    FPTHL           ; Move FPREG to variable
1843   0DE4 E1          	POP     HL              ; Restore input pointer
1844   0DE5 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1845   0DE6 CD 00 0A    	CALL    GETCHR          ; Get next character
1846   0DE9 CA F1 0D    	JP      Z,MORDT         ; End of line - More needed?
1847   0DEC FE 2C       	CP      ','             ; Another value?
1848   0DEE C2 37 0D    	JP      NZ,BADINP       ; No - Bad input
1849   0DF1 E3          MORDT:  EX      (SP),HL         ; Get code string address
1850   0DF2 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
1851   0DF3 CD 00 0A    	CALL    GETCHR          ; Get next character
1852   0DF6 C2 84 0D    	JP      NZ,NEDMOR       ; More needed - Get it
1853   0DF9 D1          	POP     DE              ; Restore DATA pointer
1854   0DFA 3A 5D 23    	LD      A,(READFG)      ; "READ" or "INPUT" ?
1855   0DFD B7          	OR      A
1856   0DFE EB          	EX      DE,HL           ; DATA pointer to HL
1857   0DFF C2 26 0A    	JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1858   0E02 D5          	PUSH    DE              ; Save code string address
1859   0E03 B6          	OR      (HL)            ; More input given?
1860   0E04 21 0C 0E    	LD      HL,EXTIG        ; "?Extra ignored" message
1861   0E07 C4 65 13    	CALL    NZ,PRS          ; Output string if extra given
1862   0E0A E1          	POP     HL              ; Restore code string address
1863   0E0B C9          	RET
1864   0E0C             
1865   0E0C 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1865   0E10 72 61 20 69 
1865   0E14 67 6E 6F 72 
1865   0E18 65 64 0D 0A 
1865   0E1C 00 
1866   0E1D             
1867   0E1D CD B6 0B    FDTLP:  CALL    DATA            ; Get next statement
1868   0E20 B7          	OR      A               ; End of line?
1869   0E21 C2 36 0E    	JP      NZ,FANDT        ; No - See if DATA statement
1870   0E24 23          	INC     HL
1871   0E25 7E          	LD      A,(HL)          ; End of program?
1872   0E26 23          	INC     HL
1873   0E27 B6          	OR      (HL)            ; 00 00 Ends program
1874   0E28 1E 06       	LD      E,OD            ; ?OD Error
1875   0E2A CA A6 05    	JP      Z,ERROR         ; Yes - Out of DATA
1876   0E2D 23          	INC     HL
1877   0E2E 5E          	LD      E,(HL)          ; LSB of line number
1878   0E2F 23          	INC     HL
1879   0E30 56          	LD      D,(HL)          ; MSB of line number
1880   0E31 EB          	EX      DE,HL
1881   0E32 22 59 23    	LD      (DATLIN),HL     ; Set line of current DATA item
1882   0E35 EB          	EX      DE,HL
1883   0E36 CD 00 0A    FANDT:  CALL    GETCHR          ; Get next character
1884   0E39 FE 83       	CP      ZDATA           ; "DATA" token
1885   0E3B C2 1D 0E    	JP      NZ,FDTLP        ; No "DATA" - Keep looking
1886   0E3E C3 B0 0D    	JP      ANTVLU          ; Found - Convert input
1887   0E41             
1888   0E41 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1889   0E44 C4 82 10    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1890   0E47 22 5E 23    	LD      (BRKLIN),HL     ; Save code string address
1891   0E4A CD 3B 05    	CALL    BAKSTK          ; Look for "FOR" block
1892   0E4D C2 98 05    	JP      NZ,NFERR        ; No "FOR" - ?NF Error
1893   0E50 F9          	LD      SP,HL           ; Clear nested loops
1894   0E51 D5          	PUSH    DE              ; Save index address
1895   0E52 7E          	LD      A,(HL)          ; Get sign of STEP
1896   0E53 23          	INC     HL
1897   0E54 F5          	PUSH    AF              ; Save sign of STEP
1898   0E55 D5          	PUSH    DE              ; Save index address
1899   0E56 CD AC 18    	CALL    PHLTFP          ; Move index value to FPREG
1900   0E59 E3          	EX      (SP),HL         ; Save address of TO value
1901   0E5A E5          	PUSH    HL              ; Save address of index
1902   0E5B CD 19 16    	CALL    ADDPHL          ; Add STEP to index value
1903   0E5E E1          	POP     HL              ; Restore address of index
1904   0E5F CD C6 18    	CALL    FPTHL           ; Move value to index variable
1905   0E62 E1          	POP     HL              ; Restore address of TO value
1906   0E63 CD BD 18    	CALL    LOADFP          ; Move TO value to BCDE
1907   0E66 E5          	PUSH    HL              ; Save address of line of FOR
1908   0E67 CD E9 18    	CALL    CMPNUM          ; Compare index with TO value
1909   0E6A E1          	POP     HL              ; Restore address of line num
1910   0E6B C1          	POP     BC              ; Address of sign of STEP
1911   0E6C 90          	SUB     B               ; Compare with expected sign
1912   0E6D CD BD 18    	CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1913   0E70 CA 7C 0E    	JP      Z,KILFOR        ; Loop finished - Terminate it
1914   0E73 EB          	EX      DE,HL           ; Loop statement line number
1915   0E74 22 EC 22    	LD      (LINEAT),HL     ; Set loop line number
1916   0E77 69          	LD      L,C             ; Set code string to loop
1917   0E78 60          	LD      H,B
1918   0E79 C3 BC 09    	JP      PUTFID          ; Put back "FOR" and continue
1919   0E7C             
1920   0E7C F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1921   0E7D 2A 5E 23    	LD      HL,(BRKLIN)     ; Code string after "NEXT"
1922   0E80 7E          	LD      A,(HL)          ; Get next byte in code string
1923   0E81 FE 2C       	CP      ','             ; More NEXTs ?
1924   0E83 C2 C0 09    	JP      NZ,RUNCNT       ; No - Do next statement
1925   0E86 CD 00 0A    	CALL    GETCHR          ; Position to index name
1926   0E89 CD 44 0E    	CALL    NEXT1           ; Re-enter NEXT routine
1927   0E8C             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1928   0E8C             
1929   0E8C CD 9E 0E    GETNUM: CALL    EVAL            ; Get a numeric expression
1930   0E8F F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1931   0E90 37          TSTSTR: SCF                     ; Set carry (string)
1932   0E91 3A 3D 23    CHKTYP: LD      A,(TYPE)        ; Check types match
1933   0E94 8F          	ADC     A,A             ; Expected + actual
1934   0E95 B7          	OR      A               ; Clear carry , set parity
1935   0E96 E8          	RET     PE              ; Even parity - Types match
1936   0E97 C3 A4 05    	JP      TMERR           ; Different types - Error
1937   0E9A             
1938   0E9A CD 66 08    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1939   0E9D 28          	.BYTE   "("
1940   0E9E 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1941   0E9F 16 00       	LD      D,0             ; Precedence value
1942   0EA1 D5          EVAL1:  PUSH    DE              ; Save precedence
1943   0EA2 0E 01       	LD      C,1
1944   0EA4 CD 6F 05    	CALL    CHKSTK          ; Check for 1 level of stack
1945   0EA7 CD 15 0F    	CALL    OPRND           ; Get next expression value
1946   0EAA 22 60 23    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1947   0EAD 2A 60 23    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1948   0EB0 C1          	POP     BC              ; Precedence value and operator
1949   0EB1 78          	LD      A,B             ; Get precedence value
1950   0EB2 FE 78       	CP      78H             ; "AND" or "OR" ?
1951   0EB4 D4 8F 0E    	CALL    NC,TSTNUM       ; No - Make sure it's a number
1952   0EB7 7E          	LD      A,(HL)          ; Get next operator / function
1953   0EB8 16 00       	LD      D,0             ; Clear Last relation
1954   0EBA D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1955   0EBC DA D6 0E    	JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1956   0EBF FE 03       	CP      ZLTH+1-ZGTR     ; < = >
1957   0EC1 D2 D6 0E    	JP      NC,FOPRND       ; Function - Call it
1958   0EC4 FE 01       	CP      ZEQUAL-ZGTR     ; "="
1959   0EC6 17          	RLA                     ; <- Test for legal
1960   0EC7 AA          	XOR     D               ; <- combinations of < = >
1961   0EC8 BA          	CP      D               ; <- by combining last token
1962   0EC9 57          	LD      D,A             ; <- with current one
1963   0ECA DA 92 05    	JP      C,SNERR         ; Error if "<<' '==" or ">>"
1964   0ECD 22 55 23    	LD      (CUROPR),HL     ; Save address of current token
1965   0ED0 CD 00 0A    	CALL    GETCHR          ; Get next character
1966   0ED3 C3 BA 0E    	JP      RLTLP           ; Treat the two as one
1967   0ED6             
1968   0ED6 7A          FOPRND: LD      A,D             ; < = > found ?
1969   0ED7 B7          	OR      A
1970   0ED8 C2 FD 0F    	JP      NZ,TSTRED       ; Yes - Test for reduction
1971   0EDB 7E          	LD      A,(HL)          ; Get operator token
1972   0EDC 22 55 23    	LD      (CUROPR),HL     ; Save operator address
1973   0EDF D6 AC       	SUB     ZPLUS           ; Operator or function?
1974   0EE1 D8          	RET     C               ; Neither - Exit
1975   0EE2 FE 07       	CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1976   0EE4 D0          	RET     NC              ; No - Exit
1977   0EE5 5F          	LD      E,A             ; Coded operator
1978   0EE6 3A 3D 23    	LD      A,(TYPE)        ; Get data type
1979   0EE9 3D          	DEC     A               ; FF = numeric , 00 = string
1980   0EEA B3          	OR      E               ; Combine with coded operator
1981   0EEB 7B          	LD      A,E             ; Get coded operator
1982   0EEC CA 5B 14    	JP      Z,CONCAT        ; String concatenation
1983   0EEF 07          	RLCA                    ; Times 2
1984   0EF0 83          	ADD     A,E             ; Times 3
1985   0EF1 5F          	LD      E,A             ; To DE (D is 0)
1986   0EF2 21 6C 03    	LD      HL,PRITAB       ; Precedence table
1987   0EF5 19          	ADD     HL,DE           ; To the operator concerned
1988   0EF6 78          	LD      A,B             ; Last operator precedence
1989   0EF7 56          	LD      D,(HL)          ; Get evaluation precedence
1990   0EF8 BA          	CP      D               ; Compare with eval precedence
1991   0EF9 D0          	RET     NC              ; Exit if higher precedence
1992   0EFA 23          	INC     HL              ; Point to routine address
1993   0EFB CD 8F 0E    	CALL    TSTNUM          ; Make sure it's a number
1994   0EFE             
1995   0EFE C5          STKTHS: PUSH    BC              ; Save last precedence & token
1996   0EFF 01 AD 0E    	LD      BC,EVAL3        ; Where to go on prec' break
1997   0F02 C5          	PUSH    BC              ; Save on stack for return
1998   0F03 43          	LD      B,E             ; Save operator
1999   0F04 4A          	LD      C,D             ; Save precedence
2000   0F05 CD 9F 18    	CALL    STAKFP          ; Move value to stack
2001   0F08 58          	LD      E,B             ; Restore operator
2002   0F09 51          	LD      D,C             ; Restore precedence
2003   0F0A 4E          	LD      C,(HL)          ; Get LSB of routine address
2004   0F0B 23          	INC     HL
2005   0F0C 46          	LD      B,(HL)          ; Get MSB of routine address
2006   0F0D 23          	INC     HL
2007   0F0E C5          	PUSH    BC              ; Save routine address
2008   0F0F 2A 55 23    	LD      HL,(CUROPR)     ; Address of current operator
2009   0F12 C3 A1 0E    	JP      EVAL1           ; Loop until prec' break
2010   0F15             
2011   0F15 AF          OPRND:  XOR     A               ; Get operand routine
2012   0F16 32 3D 23    	LD      (TYPE),A        ; Set numeric expected
2013   0F19 CD 00 0A    	CALL    GETCHR          ; Get next character
2014   0F1C 1E 24       	LD      E,MO            ; ?MO Error
2015   0F1E CA A6 05    	JP      Z,ERROR         ; No operand - Error
2016   0F21 DA 75 19    	JP      C,ASCTFP        ; Number - Get value
2017   0F24 CD BD 0A    	CALL    CHKLTR          ; See if a letter
2018   0F27 D2 7C 0F    	JP      NC,CONVAR       ; Letter - Find variable
2019   0F2A FE 26       	CP      '&'             ; &H = HEX, &B = BINARY
2020   0F2C 20 12       	JR      NZ, NOTAMP
2021   0F2E CD 00 0A    	CALL    GETCHR          ; Get next character
2022   0F31 FE 48       	CP      'H'             ; Hex number indicated? [function added]
2023   0F33 CA D3 1D    	JP      Z,HEXTFP        ; Convert Hex to FPREG
2024   0F36 FE 42       	CP      'B'             ; Binary number indicated? [function added]
2025   0F38 CA 43 1E    	JP      Z,BINTFP        ; Convert Bin to FPREG
2026   0F3B 1E 02       	LD      E,SN            ; If neither then a ?SN Error
2027   0F3D CA A6 05    	JP      Z,ERROR         ;
2028   0F40 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
2029   0F42 CA 15 0F    	JP      Z,OPRND         ; Yes - Look for operand
2030   0F45 FE 2E       	CP      '.'             ; '.' ?
2031   0F47 CA 75 19    	JP      Z,ASCTFP        ; Yes - Create FP number
2032   0F4A FE AD       	CP      ZMINUS          ; '-' Token ?
2033   0F4C CA 6B 0F    	JP      Z,MINUS         ; Yes - Do minus
2034   0F4F FE 22       	CP      '"'             ; Literal string ?
2035   0F51 CA 24 13    	JP      Z,QTSTR         ; Get string terminated by '"'
2036   0F54 FE AA       	CP      ZNOT            ; "NOT" Token ?
2037   0F56 CA 5D 10    	JP      Z,EVNOT         ; Yes - Eval NOT expression
2038   0F59 FE A7       	CP      ZFN             ; "FN" Token ?
2039   0F5B CA 88 12    	JP      Z,DOFN          ; Yes - Do FN routine
2040   0F5E D6 B6       	SUB     ZSGN            ; Is it a function?
2041   0F60 D2 8D 0F    	JP      NC,FNOFST       ; Yes - Evaluate function
2042   0F63 CD 9A 0E    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2043   0F66 CD 66 08    	CALL    CHKSYN          ; Make sure ")" follows
2044   0F69 29          	.BYTE   ")"
2045   0F6A C9          	RET
2046   0F6B             
2047   0F6B 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
2048   0F6D CD A1 0E    	CALL    EVAL1           ; Evaluate until prec' break
2049   0F70 2A 60 23    	LD      HL,(NXTOPR)     ; Get next operator address
2050   0F73 E5          	PUSH    HL              ; Save next operator address
2051   0F74 CD 97 18    	CALL    INVSGN          ; Negate value
2052   0F77 CD 8F 0E    RETNUM: CALL    TSTNUM          ; Make sure it's a number
2053   0F7A E1          	POP     HL              ; Restore next operator address
2054   0F7B C9          	RET
2055   0F7C             
2056   0F7C CD 82 10    CONVAR: CALL    GETVAR          ; Get variable address to DE
2057   0F7F E5          FRMEVL: PUSH    HL              ; Save code string address
2058   0F80 EB          	EX      DE,HL           ; Variable address to HL
2059   0F81 22 74 23    	LD      (FPREG),HL      ; Save address of variable
2060   0F84 3A 3D 23    	LD      A,(TYPE)        ; Get type
2061   0F87 B7          	OR      A               ; Numeric?
2062   0F88 CC AC 18    	CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2063   0F8B E1          	POP     HL              ; Restore code string address
2064   0F8C C9          	RET
2065   0F8D             
2066   0F8D 06 00       FNOFST: LD      B,0             ; Get address of function
2067   0F8F 07          	RLCA                    ; Double function offset
2068   0F90 4F          	LD      C,A             ; BC = Offset in function table
2069   0F91 C5          	PUSH    BC              ; Save adjusted token value
2070   0F92 CD 00 0A    	CALL    GETCHR          ; Get next character
2071   0F95 79          	LD      A,C             ; Get adjusted token value
2072   0F96 FE 31       	CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2073   0F98 DA B4 0F    	JP      C,FNVAL         ; No - Do function
2074   0F9B CD 9A 0E    	CALL    OPNPAR          ; Evaluate expression  (X,...
2075   0F9E CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
2076   0FA1 2C          	.BYTE      ','
2077   0FA2 CD 90 0E    	CALL    TSTSTR          ; Make sure it's a string
2078   0FA5 EB          	EX      DE,HL           ; Save code string address
2079   0FA6 2A 74 23    	LD      HL,(FPREG)      ; Get address of string
2080   0FA9 E3          	EX      (SP),HL         ; Save address of string
2081   0FAA E5          	PUSH    HL              ; Save adjusted token value
2082   0FAB EB          	EX      DE,HL           ; Restore code string address
2083   0FAC CD ED 15    	CALL    GETINT          ; Get integer 0-255
2084   0FAF EB          	EX      DE,HL           ; Save code string address
2085   0FB0 E3          	EX      (SP),HL         ; Save integer,HL = adj' token
2086   0FB1 C3 BC 0F    	JP      GOFUNC          ; Jump to string function
2087   0FB4             
2088   0FB4 CD 63 0F    FNVAL:  CALL    EVLPAR          ; Evaluate expression
2089   0FB7 E3          	EX      (SP),HL         ; HL = Adjusted token value
2090   0FB8 11 77 0F    	LD      DE,RETNUM       ; Return number from function
2091   0FBB D5          	PUSH    DE              ; Save on stack
2092   0FBC 01 C9 01    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2093   0FBF 09          	ADD     HL,BC           ; Point to right address
2094   0FC0 4E          	LD      C,(HL)          ; Get LSB of address
2095   0FC1 23          	INC     HL              ;
2096   0FC2 66          	LD      H,(HL)          ; Get MSB of address
2097   0FC3 69          	LD      L,C             ; Address to HL
2098   0FC4 E9          	JP      (HL)            ; Jump to function
2099   0FC5             
2100   0FC5 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2101   0FC6 FE AD       	CP      ZMINUS          ; '-' token ?
2102   0FC8 C8          	RET     Z               ; Yes - Return
2103   0FC9 FE 2D       	CP      '-'             ; '-' ASCII ?
2104   0FCB C8          	RET     Z               ; Yes - Return
2105   0FCC 14          	INC     D               ; Inc to flag positive exponent
2106   0FCD FE 2B       	CP      '+'             ; '+' ASCII ?
2107   0FCF C8          	RET     Z               ; Yes - Return
2108   0FD0 FE AC       	CP      ZPLUS           ; '+' token ?
2109   0FD2 C8          	RET     Z               ; Yes - Return
2110   0FD3 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
2111   0FD4 C9          	RET                     ; Return "NZ"
2112   0FD5             
2113   0FD5 F6          POR:    .BYTE      0F6H            ; Flag "OR"
2114   0FD6 AF          PAND:   XOR     A               ; Flag "AND"
2115   0FD7 F5          	PUSH    AF              ; Save "AND" / "OR" flag
2116   0FD8 CD 8F 0E    	CALL    TSTNUM          ; Make sure it's a number
2117   0FDB CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
2118   0FDE F1          	POP     AF              ; Restore "AND" / "OR" flag
2119   0FDF EB          	EX      DE,HL           ; <- Get last
2120   0FE0 C1          	POP     BC              ; <-  value
2121   0FE1 E3          	EX      (SP),HL         ; <-  from
2122   0FE2 EB          	EX      DE,HL           ; <-  stack
2123   0FE3 CD AF 18    	CALL    FPBCDE          ; Move last value to FPREG
2124   0FE6 F5          	PUSH    AF              ; Save "AND" / "OR" flag
2125   0FE7 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
2126   0FEA F1          	POP     AF              ; Restore "AND" / "OR" flag
2127   0FEB C1          	POP     BC              ; Get value
2128   0FEC 79          	LD      A,C             ; Get LSB
2129   0FED 21 46 12    	LD      HL,ACPASS       ; Address of save AC as current
2130   0FF0 C2 F8 0F    	JP      NZ,POR1         ; Jump if OR
2131   0FF3 A3          	AND     E               ; "AND" LSBs
2132   0FF4 4F          	LD      C,A             ; Save LSB
2133   0FF5 78          	LD      A,B             ; Get MBS
2134   0FF6 A2          	AND     D               ; "AND" MSBs
2135   0FF7 E9          	JP      (HL)            ; Save AC as current (ACPASS)
2136   0FF8             
2137   0FF8 B3          POR1:   OR      E               ; "OR" LSBs
2138   0FF9 4F          	LD      C,A             ; Save LSB
2139   0FFA 78          	LD      A,B             ; Get MSB
2140   0FFB B2          	OR      D               ; "OR" MSBs
2141   0FFC E9          	JP      (HL)            ; Save AC as current (ACPASS)
2142   0FFD             
2143   0FFD 21 0F 10    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2144   1000 3A 3D 23    	LD      A,(TYPE)        ; Get data type
2145   1003 1F          	RRA                     ; Carry set = string
2146   1004 7A          	LD      A,D             ; Get last precedence value
2147   1005 17          	RLA                     ; Times 2 plus carry
2148   1006 5F          	LD      E,A             ; To E
2149   1007 16 64       	LD      D,64H           ; Relational precedence
2150   1009 78          	LD      A,B             ; Get current precedence
2151   100A BA          	CP      D               ; Compare with last
2152   100B D0          	RET     NC              ; Eval if last was rel' or log'
2153   100C C3 FE 0E    	JP      STKTHS          ; Stack this one and get next
2154   100F             
2155   100F 11 10       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2156   1011 79          CMPLG1: LD      A,C             ; Get data type
2157   1012 B7          	OR      A
2158   1013 1F          	RRA
2159   1014 C1          	POP     BC              ; Get last expression to BCDE
2160   1015 D1          	POP     DE
2161   1016 F5          	PUSH    AF              ; Save status
2162   1017 CD 91 0E    	CALL    CHKTYP          ; Check that types match
2163   101A 21 53 10    	LD      HL,CMPRES       ; Result to comparison
2164   101D E5          	PUSH    HL              ; Save for RETurn
2165   101E CA E9 18    	JP      Z,CMPNUM        ; Compare values if numeric
2166   1021 AF          	XOR     A               ; Compare two strings
2167   1022 32 3D 23    	LD      (TYPE),A        ; Set type to numeric
2168   1025 D5          	PUSH    DE              ; Save string name
2169   1026 CD A8 14    	CALL    GSTRCU          ; Get current string
2170   1029 7E          	LD      A,(HL)          ; Get length of string
2171   102A 23          	INC     HL
2172   102B 23          	INC     HL
2173   102C 4E          	LD      C,(HL)          ; Get LSB of address
2174   102D 23          	INC     HL
2175   102E 46          	LD      B,(HL)          ; Get MSB of address
2176   102F D1          	POP     DE              ; Restore string name
2177   1030 C5          	PUSH    BC              ; Save address of string
2178   1031 F5          	PUSH    AF              ; Save length of string
2179   1032 CD AC 14    	CALL    GSTRDE          ; Get second string
2180   1035 CD BD 18    	CALL    LOADFP          ; Get address of second string
2181   1038 F1          	POP     AF              ; Restore length of string 1
2182   1039 57          	LD      D,A             ; Length to D
2183   103A E1          	POP     HL              ; Restore address of string 1
2184   103B 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2185   103C B2          	OR      D               ; Bytes of string 1 to do
2186   103D C8          	RET     Z               ; Exit if all bytes compared
2187   103E 7A          	LD      A,D             ; Get bytes of string 1 to do
2188   103F D6 01       	SUB     1
2189   1041 D8          	RET     C               ; Exit if end of string 1
2190   1042 AF          	XOR     A
2191   1043 BB          	CP      E               ; Bytes of string 2 to do
2192   1044 3C          	INC     A
2193   1045 D0          	RET     NC              ; Exit if end of string 2
2194   1046 15          	DEC     D               ; Count bytes in string 1
2195   1047 1D          	DEC     E               ; Count bytes in string 2
2196   1048 0A          	LD      A,(BC)          ; Byte in string 2
2197   1049 BE          	CP      (HL)            ; Compare to byte in string 1
2198   104A 23          	INC     HL              ; Move up string 1
2199   104B 03          	INC     BC              ; Move up string 2
2200   104C CA 3B 10    	JP      Z,CMPSTR        ; Same - Try next bytes
2201   104F 3F          	CCF                     ; Flag difference (">" or "<")
2202   1050 C3 79 18    	JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2203   1053             
2204   1053 3C          CMPRES: INC     A               ; Increment current value
2205   1054 8F          	ADC     A,A             ; Double plus carry
2206   1055 C1          	POP     BC              ; Get other value
2207   1056 A0          	AND     B               ; Combine them
2208   1057 C6 FF       	ADD     A,-1            ; Carry set if different
2209   1059 9F          	SBC     A,A             ; 00 - Equal , FF - Different
2210   105A C3 80 18    	JP      FLGREL          ; Set current value & continue
2211   105D             
2212   105D 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2213   105F CD A1 0E    	CALL    EVAL1           ; Eval until precedence break
2214   1062 CD 8F 0E    	CALL    TSTNUM          ; Make sure it's a number
2215   1065 CD D1 0A    	CALL    DEINT           ; Get integer -32768 - 32767
2216   1068 7B          	LD      A,E             ; Get LSB
2217   1069 2F          	CPL                     ; Invert LSB
2218   106A 4F          	LD      C,A             ; Save "NOT" of LSB
2219   106B 7A          	LD      A,D             ; Get MSB
2220   106C 2F          	CPL                     ; Invert MSB
2221   106D CD 46 12    	CALL    ACPASS          ; Save AC as current
2222   1070 C1          	POP     BC              ; Clean up stack
2223   1071 C3 AD 0E    	JP      EVAL3           ; Continue evaluation
2224   1074             
2225   1074 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2226   1075 CD 00 0A    	CALL    GETCHR          ; Get next character
2227   1078 C8          	RET     Z               ; End of DIM statement
2228   1079 CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
2229   107C 2C          	.BYTE      ','
2230   107D 01 74 10    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2231   1080 C5          	PUSH    BC              ; Save on stack
2232   1081 F6          	.BYTE      0F6H            ; Flag "Create" variable
2233   1082 AF          GETVAR: XOR     A               ; Find variable address,to DE
2234   1083 32 3C 23    	LD      (LCRFLG),A      ; Set locate / create flag
2235   1086 46          	LD      B,(HL)          ; Get First byte of name
2236   1087 CD BD 0A    GTFNAM: CALL    CHKLTR          ; See if a letter
2237   108A DA 92 05    	JP      C,SNERR         ; ?SN Error if not a letter
2238   108D AF          	XOR     A
2239   108E 4F          	LD      C,A             ; Clear second byte of name
2240   108F 32 3D 23    	LD      (TYPE),A        ; Set type to numeric
2241   1092 CD 00 0A    	CALL    GETCHR          ; Get next character
2242   1095 DA 9E 10    	JP      C,SVNAM2        ; Numeric - Save in name
2243   1098 CD BD 0A    	CALL    CHKLTR          ; See if a letter
2244   109B DA AB 10    	JP      C,CHARTY        ; Not a letter - Check type
2245   109E 4F          SVNAM2: LD      C,A             ; Save second byte of name
2246   109F CD 00 0A    ENDNAM: CALL    GETCHR          ; Get next character
2247   10A2 DA 9F 10    	JP      C,ENDNAM        ; Numeric - Get another
2248   10A5 CD BD 0A    	CALL    CHKLTR          ; See if a letter
2249   10A8 D2 9F 10    	JP      NC,ENDNAM       ; Letter - Get another
2250   10AB D6 24       CHARTY: SUB     '$'             ; String variable?
2251   10AD C2 BA 10    	JP      NZ,NOTSTR       ; No - Numeric variable
2252   10B0 3C          	INC     A               ; A = 1 (string type)
2253   10B1 32 3D 23    	LD      (TYPE),A        ; Set type to string
2254   10B4 0F          	RRCA                    ; A = 80H , Flag for string
2255   10B5 81          	ADD     A,C             ; 2nd byte of name has bit 7 on
2256   10B6 4F          	LD      C,A             ; Resave second byte on name
2257   10B7 CD 00 0A    	CALL    GETCHR          ; Get next character
2258   10BA 3A 5B 23    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2259   10BD 3D          	DEC     A
2260   10BE CA 67 11    	JP      Z,ARLDSV        ; Yes - Get array name
2261   10C1 F2 CA 10    	JP      P,NSCFOR        ; No array with "FOR" or "FN"
2262   10C4 7E          	LD      A,(HL)          ; Get byte again
2263   10C5 D6 28       	SUB     '('             ; Subscripted variable?
2264   10C7 CA 3F 11    	JP      Z,SBSCPT        ; Yes - Sort out subscript
2265   10CA             
2266   10CA AF          NSCFOR: XOR     A               ; Simple variable
2267   10CB 32 5B 23    	LD      (FORFLG),A      ; Clear "FOR" flag
2268   10CE E5          	PUSH    HL              ; Save code string address
2269   10CF 50          	LD      D,B             ; DE = Variable name to find
2270   10D0 59          	LD      E,C
2271   10D1 2A 6E 23    	LD      HL,(FNRGNM)     ; FN argument name
2272   10D4 CD 60 08    	CALL    CPDEHL          ; Is it the FN argument?
2273   10D7 11 70 23    	LD      DE,FNARG        ; Point to argument value
2274   10DA CA AF 17    	JP      Z,POPHRT        ; Yes - Return FN argument value
2275   10DD 2A 68 23    	LD      HL,(VAREND)     ; End of variables
2276   10E0 EB          	EX      DE,HL           ; Address of end of search
2277   10E1 2A 66 23    	LD      HL,(PROGND)     ; Start of variables address
2278   10E4 CD 60 08    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2279   10E7 CA FD 10    	JP      Z,CFEVAL        ; Yes - Called from EVAL?
2280   10EA 79          	LD      A,C             ; Get second byte of name
2281   10EB 96          	SUB     (HL)            ; Compare with name in list
2282   10EC 23          	INC     HL              ; Move on to first byte
2283   10ED C2 F2 10    	JP      NZ,FNTHR        ; Different - Find another
2284   10F0 78          	LD      A,B             ; Get first byte of name
2285   10F1 96          	SUB     (HL)            ; Compare with name in list
2286   10F2 23          FNTHR:  INC     HL              ; Move on to LSB of value
2287   10F3 CA 31 11    	JP      Z,RETADR        ; Found - Return address
2288   10F6 23          	INC     HL              ; <- Skip
2289   10F7 23          	INC     HL              ; <- over
2290   10F8 23          	INC     HL              ; <- F.P.
2291   10F9 23          	INC     HL              ; <- value
2292   10FA C3 E4 10    	JP      FNDVAR          ; Keep looking
2293   10FD             
2294   10FD E1          CFEVAL: POP     HL              ; Restore code string address
2295   10FE E3          	EX      (SP),HL         ; Get return address
2296   10FF D5          	PUSH    DE              ; Save address of variable
2297   1100 11 7F 0F    	LD      DE,FRMEVL       ; Return address in EVAL
2298   1103 CD 60 08    	CALL    CPDEHL          ; Called from EVAL ?
2299   1106 D1          	POP     DE              ; Restore address of variable
2300   1107 CA 34 11    	JP      Z,RETNUL        ; Yes - Return null variable
2301   110A E3          	EX      (SP),HL         ; Put back return
2302   110B E5          	PUSH    HL              ; Save code string address
2303   110C C5          	PUSH    BC              ; Save variable name
2304   110D 01 06 00    	LD      BC,6            ; 2 byte name plus 4 byte data
2305   1110 2A 6A 23    	LD      HL,(ARREND)     ; End of arrays
2306   1113 E5          	PUSH    HL              ; Save end of arrays
2307   1114 09          	ADD     HL,BC           ; Move up 6 bytes
2308   1115 C1          	POP     BC              ; Source address in BC
2309   1116 E5          	PUSH    HL              ; Save new end address
2310   1117 CD 5E 05    	CALL    MOVUP           ; Move arrays up
2311   111A E1          	POP     HL              ; Restore new end address
2312   111B 22 6A 23    	LD      (ARREND),HL     ; Set new end address
2313   111E 60          	LD      H,B             ; End of variables to HL
2314   111F 69          	LD      L,C
2315   1120 22 68 23    	LD      (VAREND),HL     ; Set new end address
2316   1123             
2317   1123 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2318   1124 36 00       	LD      (HL),0          ; Zero byte in variable
2319   1126 CD 60 08    	CALL    CPDEHL          ; Done them all?
2320   1129 C2 23 11    	JP      NZ,ZEROLP       ; No - Keep on going
2321   112C D1          	POP     DE              ; Get variable name
2322   112D 73          	LD      (HL),E          ; Store second character
2323   112E 23          	INC     HL
2324   112F 72          	LD      (HL),D          ; Store first character
2325   1130 23          	INC     HL
2326   1131 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2327   1132 E1          	POP     HL              ; Restore code string address
2328   1133 C9          	RET
2329   1134             
2330   1134 32 77 23    RETNUL: LD      (FPEXP),A       ; Set result to zero
2331   1137 21 2E 05    	LD      HL,ZERBYT       ; Also set a null string
2332   113A 22 74 23    	LD      (FPREG),HL      ; Save for EVAL
2333   113D E1          	POP     HL              ; Restore code string address
2334   113E C9          	RET
2335   113F             
2336   113F E5          SBSCPT: PUSH    HL              ; Save code string address
2337   1140 2A 3C 23    	LD      HL,(LCRFLG)     ; Locate/Create and Type
2338   1143 E3          	EX      (SP),HL         ; Save and get code string
2339   1144 57          	LD      D,A             ; Zero number of dimensions
2340   1145 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2341   1146 C5          	PUSH    BC              ; Save array name
2342   1147 CD C5 0A    	CALL    FPSINT          ; Get subscript (0-32767)
2343   114A C1          	POP     BC              ; Restore array name
2344   114B F1          	POP     AF              ; Get number of dimensions
2345   114C EB          	EX      DE,HL
2346   114D E3          	EX      (SP),HL         ; Save subscript value
2347   114E E5          	PUSH    HL              ; Save LCRFLG and TYPE
2348   114F EB          	EX      DE,HL
2349   1150 3C          	INC     A               ; Count dimensions
2350   1151 57          	LD      D,A             ; Save in D
2351   1152 7E          	LD      A,(HL)          ; Get next byte in code string
2352   1153 FE 2C       	CP      ','             ; Comma (more to come)?
2353   1155 CA 45 11    	JP      Z,SCPTLP        ; Yes - More subscripts
2354   1158 CD 66 08    	CALL    CHKSYN          ; Make sure ")" follows
2355   115B 29          	.BYTE      ")"
2356   115C 22 60 23    	LD      (NXTOPR),HL     ; Save code string address
2357   115F E1          	POP     HL              ; Get LCRFLG and TYPE
2358   1160 22 3C 23    	LD      (LCRFLG),HL     ; Restore Locate/create & type
2359   1163 1E 00       	LD      E,0             ; Flag not CSAVE* or CLOAD*
2360   1165 D5          	PUSH    DE              ; Save number of dimensions (D)
2361   1166 11          	.BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2362   1167             
2363   1167 E5          ARLDSV: PUSH    HL              ; Save code string address
2364   1168 F5          	PUSH    AF              ; A = 00 , Flags set = Z,N
2365   1169 2A 68 23    	LD      HL,(VAREND)     ; Start of arrays
2366   116C 3E          	.BYTE      3EH             ; Skip "ADD HL,DE"
2367   116D 19          FNDARY: ADD     HL,DE           ; Move to next array start
2368   116E EB          	EX      DE,HL
2369   116F 2A 6A 23    	LD      HL,(ARREND)     ; End of arrays
2370   1172 EB          	EX      DE,HL           ; Current array pointer
2371   1173 CD 60 08    	CALL    CPDEHL          ; End of arrays found?
2372   1176 CA 9F 11    	JP      Z,CREARY        ; Yes - Create array
2373   1179 7E          	LD      A,(HL)          ; Get second byte of name
2374   117A B9          	CP      C               ; Compare with name given
2375   117B 23          	INC     HL              ; Move on
2376   117C C2 81 11    	JP      NZ,NXTARY       ; Different - Find next array
2377   117F 7E          	LD      A,(HL)          ; Get first byte of name
2378   1180 B8          	CP      B               ; Compare with name given
2379   1181 23          NXTARY: INC     HL              ; Move on
2380   1182 5E          	LD      E,(HL)          ; Get LSB of next array address
2381   1183 23          	INC     HL
2382   1184 56          	LD      D,(HL)          ; Get MSB of next array address
2383   1185 23          	INC     HL
2384   1186 C2 6D 11    	JP      NZ,FNDARY       ; Not found - Keep looking
2385   1189 3A 3C 23    	LD      A,(LCRFLG)      ; Found Locate or Create it?
2386   118C B7          	OR      A
2387   118D C2 9B 05    	JP      NZ,DDERR        ; Create - ?DD Error
2388   1190 F1          	POP     AF              ; Locate - Get number of dim'ns
2389   1191 44          	LD      B,H             ; BC Points to array dim'ns
2390   1192 4D          	LD      C,L
2391   1193 CA AF 17    	JP      Z,POPHRT        ; Jump if array load/save
2392   1196 96          	SUB     (HL)            ; Same number of dimensions?
2393   1197 CA FD 11    	JP      Z,FINDEL        ; Yes - Find element
2394   119A 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2395   119C C3 A6 05    	JP      ERROR           ; Output error
2396   119F             
2397   119F 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2398   11A2 F1          	POP     AF              ; Array to save or 0 dim'ns?
2399   11A3 CA E6 0A    	JP      Z,FCERR         ; Yes - ?FC Error
2400   11A6 71          	LD      (HL),C          ; Save second byte of name
2401   11A7 23          	INC     HL
2402   11A8 70          	LD      (HL),B          ; Save first byte of name
2403   11A9 23          	INC     HL
2404   11AA 4F          	LD      C,A             ; Number of dimensions to C
2405   11AB CD 6F 05    	CALL    CHKSTK          ; Check if enough memory
2406   11AE 23          	INC     HL              ; Point to number of dimensions
2407   11AF 23          	INC     HL
2408   11B0 22 55 23    	LD      (CUROPR),HL     ; Save address of pointer
2409   11B3 71          	LD      (HL),C          ; Set number of dimensions
2410   11B4 23          	INC     HL
2411   11B5 3A 3C 23    	LD      A,(LCRFLG)      ; Locate of Create?
2412   11B8 17          	RLA                     ; Carry set = Create
2413   11B9 79          	LD      A,C             ; Get number of dimensions
2414   11BA 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2415   11BD D2 C2 11    	JP      NC,DEFSIZ       ; Locate - Set default size
2416   11C0 C1          	POP     BC              ; Get specified dimension size
2417   11C1 03          	INC     BC              ; Include zero element
2418   11C2 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2419   11C3 23          	INC     HL
2420   11C4 70          	LD      (HL),B          ; Save MSB of dimension size
2421   11C5 23          	INC     HL
2422   11C6 F5          	PUSH    AF              ; Save num' of dim'ns an status
2423   11C7 E5          	PUSH    HL              ; Save address of dim'n size
2424   11C8 CD 5A 19    	CALL    MLDEBC          ; Multiply DE by BC to find
2425   11CB EB          	EX      DE,HL           ; amount of mem needed (to DE)
2426   11CC E1          	POP     HL              ; Restore address of dimension
2427   11CD F1          	POP     AF              ; Restore number of dimensions
2428   11CE 3D          	DEC     A               ; Count them
2429   11CF C2 BA 11    	JP      NZ,CRARLP       ; Do next dimension if more
2430   11D2 F5          	PUSH    AF              ; Save locate/create flag
2431   11D3 42          	LD      B,D             ; MSB of memory needed
2432   11D4 4B          	LD      C,E             ; LSB of memory needed
2433   11D5 EB          	EX      DE,HL
2434   11D6 19          	ADD     HL,DE           ; Add bytes to array start
2435   11D7 DA 87 05    	JP      C,OMERR         ; Too big - Error
2436   11DA CD 78 05    	CALL    ENFMEM          ; See if enough memory
2437   11DD 22 6A 23    	LD      (ARREND),HL     ; Save new end of array
2438   11E0             
2439   11E0 2B          ZERARY: DEC     HL              ; Back through array data
2440   11E1 36 00       	LD      (HL),0          ; Set array element to zero
2441   11E3 CD 60 08    	CALL    CPDEHL          ; All elements zeroed?
2442   11E6 C2 E0 11    	JP      NZ,ZERARY       ; No - Keep on going
2443   11E9 03          	INC     BC              ; Number of bytes + 1
2444   11EA 57          	LD      D,A             ; A=0
2445   11EB 2A 55 23    	LD      HL,(CUROPR)     ; Get address of array
2446   11EE 5E          	LD      E,(HL)          ; Number of dimensions
2447   11EF EB          	EX      DE,HL           ; To HL
2448   11F0 29          	ADD     HL,HL           ; Two bytes per dimension size
2449   11F1 09          	ADD     HL,BC           ; Add number of bytes
2450   11F2 EB          	EX      DE,HL           ; Bytes needed to DE
2451   11F3 2B          	DEC     HL
2452   11F4 2B          	DEC     HL
2453   11F5 73          	LD      (HL),E          ; Save LSB of bytes needed
2454   11F6 23          	INC     HL
2455   11F7 72          	LD      (HL),D          ; Save MSB of bytes needed
2456   11F8 23          	INC     HL
2457   11F9 F1          	POP     AF              ; Locate / Create?
2458   11FA DA 21 12    	JP      C,ENDDIM        ; A is 0 , End if create
2459   11FD 47          FINDEL: LD      B,A             ; Find array element
2460   11FE 4F          	LD      C,A
2461   11FF 7E          	LD      A,(HL)          ; Number of dimensions
2462   1200 23          	INC     HL
2463   1201 16          	.BYTE      16H             ; Skip "POP HL"
2464   1202 E1          FNDELP: POP     HL              ; Address of next dim' size
2465   1203 5E          	LD      E,(HL)          ; Get LSB of dim'n size
2466   1204 23          	INC     HL
2467   1205 56          	LD      D,(HL)          ; Get MSB of dim'n size
2468   1206 23          	INC     HL
2469   1207 E3          	EX      (SP),HL         ; Save address - Get index
2470   1208 F5          	PUSH    AF              ; Save number of dim'ns
2471   1209 CD 60 08    	CALL    CPDEHL          ; Dimension too large?
2472   120C D2 9A 11    	JP      NC,BSERR        ; Yes - ?BS Error
2473   120F E5          	PUSH    HL              ; Save index
2474   1210 CD 5A 19    	CALL    MLDEBC          ; Multiply previous by size
2475   1213 D1          	POP     DE              ; Index supplied to DE
2476   1214 19          	ADD     HL,DE           ; Add index to pointer
2477   1215 F1          	POP     AF              ; Number of dimensions
2478   1216 3D          	DEC     A               ; Count them
2479   1217 44          	LD      B,H             ; MSB of pointer
2480   1218 4D          	LD      C,L             ; LSB of pointer
2481   1219 C2 02 12    	JP      NZ,FNDELP       ; More - Keep going
2482   121C 29          	ADD     HL,HL           ; 4 Bytes per element
2483   121D 29          	ADD     HL,HL
2484   121E C1          	POP     BC              ; Start of array
2485   121F 09          	ADD     HL,BC           ; Point to element
2486   1220 EB          	EX      DE,HL           ; Address of element to DE
2487   1221 2A 60 23    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2488   1224 C9          	RET
2489   1225             
2490   1225 2A 6A 23    FRE:    LD      HL,(ARREND)     ; Start of free memory
2491   1228 EB          	EX      DE,HL           ; To DE
2492   1229 21 00 00    	LD      HL,0            ; End of free memory
2493   122C 39          	ADD     HL,SP           ; Current stack value
2494   122D 3A 3D 23    	LD      A,(TYPE)        ; Dummy argument type
2495   1230 B7          	OR      A
2496   1231 CA 41 12    	JP      Z,FRENUM        ; Numeric - Free variable space
2497   1234 CD A8 14    	CALL    GSTRCU          ; Current string to pool
2498   1237 CD A8 13    	CALL    GARBGE          ; Garbage collection
2499   123A 2A EA 22    	LD      HL,(STRSPC)     ; Bottom of string space in use
2500   123D EB          	EX      DE,HL           ; To DE
2501   123E 2A 53 23    	LD      HL,(STRBOT)     ; Bottom of string space
2502   1241 7D          FRENUM: LD      A,L             ; Get LSB of end
2503   1242 93          	SUB     E               ; Subtract LSB of beginning
2504   1243 4F          	LD      C,A             ; Save difference if C
2505   1244 7C          	LD      A,H             ; Get MSB of end
2506   1245 9A          	SBC     A,D             ; Subtract MSB of beginning
2507   1246 41          ACPASS: LD      B,C             ; Return integer AC
2508   1247 50          ABPASS: LD      D,B             ; Return integer AB
2509   1248 1E 00       	LD      E,0
2510   124A 21 3D 23    	LD      HL,TYPE         ; Point to type
2511   124D 73          	LD      (HL),E          ; Set type to numeric
2512   124E 06 90       	LD      B,80H+16        ; 16 bit integer
2513   1250 C3 85 18    	JP      RETINT          ; Return the integr
2514   1253             
2515   1253 3A 3B 23    POS:    LD      A,(CURPOS)      ; Get cursor position
2516   1256 47          PASSA:  LD      B,A             ; Put A into AB
2517   1257 AF          	XOR     A               ; Zero A
2518   1258 C3 47 12    	JP      ABPASS          ; Return integer AB
2519   125B             
2520   125B CD DE 12    DEF:    CALL    CHEKFN          ; Get "FN" and name
2521   125E CD D0 12    	CALL    IDTEST          ; Test for illegal direct
2522   1261 01 B6 0B    	LD      BC,DATA         ; To get next statement
2523   1264 C5          	PUSH    BC              ; Save address for RETurn
2524   1265 D5          	PUSH    DE              ; Save address of function ptr
2525   1266 CD 66 08    	CALL    CHKSYN          ; Make sure "(" follows
2526   1269 28          	.BYTE      "("
2527   126A CD 82 10    	CALL    GETVAR          ; Get argument variable name
2528   126D E5          	PUSH    HL              ; Save code string address
2529   126E EB          	EX      DE,HL           ; Argument address to HL
2530   126F 2B          	DEC     HL
2531   1270 56          	LD      D,(HL)          ; Get first byte of arg name
2532   1271 2B          	DEC     HL
2533   1272 5E          	LD      E,(HL)          ; Get second byte of arg name
2534   1273 E1          	POP     HL              ; Restore code string address
2535   1274 CD 8F 0E    	CALL    TSTNUM          ; Make sure numeric argument
2536   1277 CD 66 08    	CALL    CHKSYN          ; Make sure ")" follows
2537   127A 29          	.BYTE      ")"
2538   127B CD 66 08    	CALL    CHKSYN          ; Make sure "=" follows
2539   127E B4          	.BYTE      ZEQUAL          ; "=" token
2540   127F 44          	LD      B,H             ; Code string address to BC
2541   1280 4D          	LD      C,L
2542   1281 E3          	EX      (SP),HL         ; Save code str , Get FN ptr
2543   1282 71          	LD      (HL),C          ; Save LSB of FN code string
2544   1283 23          	INC     HL
2545   1284 70          	LD      (HL),B          ; Save MSB of FN code string
2546   1285 C3 1D 13    	JP      SVSTAD          ; Save address and do function
2547   1288             
2548   1288 CD DE 12    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2549   128B D5          	PUSH    DE              ; Save function pointer address
2550   128C CD 63 0F    	CALL    EVLPAR          ; Evaluate expression in "()"
2551   128F CD 8F 0E    	CALL    TSTNUM          ; Make sure numeric result
2552   1292 E3          	EX      (SP),HL         ; Save code str , Get FN ptr
2553   1293 5E          	LD      E,(HL)          ; Get LSB of FN code string
2554   1294 23          	INC     HL
2555   1295 56          	LD      D,(HL)          ; Get MSB of FN code string
2556   1296 23          	INC     HL
2557   1297 7A          	LD      A,D             ; And function DEFined?
2558   1298 B3          	OR      E
2559   1299 CA 9E 05    	JP      Z,UFERR         ; No - ?UF Error
2560   129C 7E          	LD      A,(HL)          ; Get LSB of argument address
2561   129D 23          	INC     HL
2562   129E 66          	LD      H,(HL)          ; Get MSB of argument address
2563   129F 6F          	LD      L,A             ; HL = Arg variable address
2564   12A0 E5          	PUSH    HL              ; Save it
2565   12A1 2A 6E 23    	LD      HL,(FNRGNM)     ; Get old argument name
2566   12A4 E3          	EX      (SP),HL ;       ; Save old , Get new
2567   12A5 22 6E 23    	LD      (FNRGNM),HL     ; Set new argument name
2568   12A8 2A 72 23    	LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2569   12AB E5          	PUSH    HL              ; Save it
2570   12AC 2A 70 23    	LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2571   12AF E5          	PUSH    HL              ; Save it
2572   12B0 21 70 23    	LD      HL,FNARG        ; HL = Value of argument
2573   12B3 D5          	PUSH    DE              ; Save FN code string address
2574   12B4 CD C6 18    	CALL    FPTHL           ; Move FPREG to argument
2575   12B7 E1          	POP     HL              ; Get FN code string address
2576   12B8 CD 8C 0E    	CALL    GETNUM          ; Get value from function
2577   12BB 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
2578   12BC CD 00 0A    	CALL    GETCHR          ; Get next character
2579   12BF C2 92 05    	JP      NZ,SNERR        ; Bad character in FN - Error
2580   12C2 E1          	POP     HL              ; Get MSB,EXP of old arg
2581   12C3 22 70 23    	LD      (FNARG),HL      ; Restore it
2582   12C6 E1          	POP     HL              ; Get LSB,NLSB of old arg
2583   12C7 22 72 23    	LD      (FNARG+2),HL    ; Restore it
2584   12CA E1          	POP     HL              ; Get name of old arg
2585   12CB 22 6E 23    	LD      (FNRGNM),HL     ; Restore it
2586   12CE E1          	POP     HL              ; Restore code string address
2587   12CF C9          	RET
2588   12D0             
2589   12D0 E5          IDTEST: PUSH    HL              ; Save code string address
2590   12D1 2A EC 22    	LD      HL,(LINEAT)     ; Get current line number
2591   12D4 23          	INC     HL              ; -1 means direct statement
2592   12D5 7C          	LD      A,H
2593   12D6 B5          	OR      L
2594   12D7 E1          	POP     HL              ; Restore code string address
2595   12D8 C0          	RET     NZ              ; Return if in program
2596   12D9 1E 16       	LD      E,ID            ; ?ID Error
2597   12DB C3 A6 05    	JP      ERROR
2598   12DE             
2599   12DE CD 66 08    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2600   12E1 A7          	.BYTE      ZFN             ; "FN" token
2601   12E2 3E 80       	LD      A,80H
2602   12E4 32 5B 23    	LD      (FORFLG),A      ; Flag FN name to find
2603   12E7 B6          	OR      (HL)            ; FN name has bit 7 set
2604   12E8 47          	LD      B,A             ; in first byte of name
2605   12E9 CD 87 10    	CALL    GTFNAM          ; Get FN name
2606   12EC C3 8F 0E    	JP      TSTNUM          ; Make sure numeric function
2607   12EF             
2608   12EF CD 8F 0E    STR:    CALL    TSTNUM          ; Make sure it's a number
2609   12F2 CD 13 1A    	CALL    NUMASC          ; Turn number into text
2610   12F5 CD 23 13    STR1:   CALL    CRTST           ; Create string entry for it
2611   12F8 CD A8 14    	CALL    GSTRCU          ; Current string to pool
2612   12FB 01 03 15    	LD      BC,TOPOOL       ; Save in string pool
2613   12FE C5          	PUSH    BC              ; Save address on stack
2614   12FF             
2615   12FF 7E          SAVSTR: LD      A,(HL)          ; Get string length
2616   1300 23          	INC     HL
2617   1301 23          	INC     HL
2618   1302 E5          	PUSH    HL              ; Save pointer to string
2619   1303 CD 7E 13    	CALL    TESTR           ; See if enough string space
2620   1306 E1          	POP     HL              ; Restore pointer to string
2621   1307 4E          	LD      C,(HL)          ; Get LSB of address
2622   1308 23          	INC     HL
2623   1309 46          	LD      B,(HL)          ; Get MSB of address
2624   130A CD 17 13    	CALL    CRTMST          ; Create string entry
2625   130D E5          	PUSH    HL              ; Save pointer to MSB of addr
2626   130E 6F          	LD      L,A             ; Length of string
2627   130F CD 9B 14    	CALL    TOSTRA          ; Move to string area
2628   1312 D1          	POP     DE              ; Restore pointer to MSB
2629   1313 C9          	RET
2630   1314             
2631   1314 CD 7E 13    MKTMST: CALL    TESTR           ; See if enough string space
2632   1317 21 4F 23    CRTMST: LD      HL,TMPSTR       ; Temporary string
2633   131A E5          	PUSH    HL              ; Save it
2634   131B 77          	LD      (HL),A          ; Save length of string
2635   131C 23          	INC     HL
2636   131D 23          SVSTAD: INC     HL
2637   131E 73          	LD      (HL),E          ; Save LSB of address
2638   131F 23          	INC     HL
2639   1320 72          	LD      (HL),D          ; Save MSB of address
2640   1321 E1          	POP     HL              ; Restore pointer
2641   1322 C9          	RET
2642   1323             
2643   1323 2B          CRTST:  DEC     HL              ; DEC - INCed after
2644   1324 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2645   1326 50          	LD      D,B             ; Quote to D
2646   1327 E5          DTSTR:  PUSH    HL              ; Save start
2647   1328 0E FF       	LD      C,-1            ; Set counter to -1
2648   132A 23          QTSTLP: INC     HL              ; Move on
2649   132B 7E          	LD      A,(HL)          ; Get byte
2650   132C 0C          	INC     C               ; Count bytes
2651   132D B7          	OR      A               ; End of line?
2652   132E CA 39 13    	JP      Z,CRTSTE        ; Yes - Create string entry
2653   1331 BA          	CP      D               ; Terminator D found?
2654   1332 CA 39 13    	JP      Z,CRTSTE        ; Yes - Create string entry
2655   1335 B8          	CP      B               ; Terminator B found?
2656   1336 C2 2A 13    	JP      NZ,QTSTLP       ; No - Keep looking
2657   1339 FE 22       CRTSTE: CP      '"'             ; End with '"'?
2658   133B CC 00 0A    	CALL    Z,GETCHR        ; Yes - Get next character
2659   133E E3          	EX      (SP),HL         ; Starting quote
2660   133F 23          	INC     HL              ; First byte of string
2661   1340 EB          	EX      DE,HL           ; To DE
2662   1341 79          	LD      A,C             ; Get length
2663   1342 CD 17 13    	CALL    CRTMST          ; Create string entry
2664   1345 11 4F 23    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2665   1348 2A 41 23    	LD      HL,(TMSTPT)     ; Temporary string pool pointer
2666   134B 22 74 23    	LD      (FPREG),HL      ; Save address of string ptr
2667   134E 3E 01       	LD      A,1
2668   1350 32 3D 23    	LD      (TYPE),A        ; Set type to string
2669   1353 CD C9 18    	CALL    DETHL4          ; Move string to pool
2670   1356 CD 60 08    	CALL    CPDEHL          ; Out of string pool?
2671   1359 22 41 23    	LD      (TMSTPT),HL     ; Save new pointer
2672   135C E1          	POP     HL              ; Restore code string address
2673   135D 7E          	LD      A,(HL)          ; Get next code byte
2674   135E C0          	RET     NZ              ; Return if pool OK
2675   135F 1E 1E       	LD      E,ST            ; ?ST Error
2676   1361 C3 A6 05    	JP      ERROR           ; String pool overflow
2677   1364             
2678   1364 23          PRNUMS: INC     HL              ; Skip leading space
2679   1365 CD 23 13    PRS:    CALL    CRTST           ; Create string entry for it
2680   1368 CD A8 14    PRS1:   CALL    GSTRCU          ; Current string to pool
2681   136B CD BD 18    	CALL    LOADFP          ; Move string block to BCDE
2682   136E 1C          	INC     E               ; Length + 1
2683   136F 1D          PRSLP:  DEC     E               ; Count characters
2684   1370 C8          	RET     Z               ; End of string
2685   1371 0A          	LD      A,(BC)          ; Get byte to output
2686   1372 CD 71 08    	CALL    OUTC            ; Output character in A
2687   1375 FE 0D       	CP      CR              ; Return?
2688   1377 CC D1 0C    	CALL    Z,DONULL        ; Yes - Do nulls
2689   137A 03          	INC     BC              ; Next byte in string
2690   137B C3 6F 13    	JP      PRSLP           ; More characters to output
2691   137E             
2692   137E B7          TESTR:  OR      A               ; Test if enough room
2693   137F 0E          	.BYTE      0EH             ; No garbage collection done
2694   1380 F1          GRBDON: POP     AF              ; Garbage collection done
2695   1381 F5          	PUSH    AF              ; Save status
2696   1382 2A EA 22    	LD      HL,(STRSPC)     ; Bottom of string space in use
2697   1385 EB          	EX      DE,HL           ; To DE
2698   1386 2A 53 23    	LD      HL,(STRBOT)     ; Bottom of string area
2699   1389 2F          	CPL                     ; Negate length (Top down)
2700   138A 4F          	LD      C,A             ; -Length to BC
2701   138B 06 FF       	LD      B,-1            ; BC = -ve length of string
2702   138D 09          	ADD     HL,BC           ; Add to bottom of space in use
2703   138E 23          	INC     HL              ; Plus one for 2's complement
2704   138F CD 60 08    	CALL    CPDEHL          ; Below string RAM area?
2705   1392 DA 9C 13    	JP      C,TESTOS        ; Tidy up if not done else err
2706   1395 22 53 23    	LD      (STRBOT),HL     ; Save new bottom of area
2707   1398 23          	INC     HL              ; Point to first byte of string
2708   1399 EB          	EX      DE,HL           ; Address to DE
2709   139A F1          POPAF:  POP     AF              ; Throw away status push
2710   139B C9          	RET
2711   139C             
2712   139C F1          TESTOS: POP     AF              ; Garbage collect been done?
2713   139D 1E 1A       	LD      E,OS            ; ?OS Error
2714   139F CA A6 05    	JP      Z,ERROR         ; Yes - Not enough string apace
2715   13A2 BF          	CP      A               ; Flag garbage collect done
2716   13A3 F5          	PUSH    AF              ; Save status
2717   13A4 01 80 13    	LD      BC,GRBDON       ; Garbage collection done
2718   13A7 C5          	PUSH    BC              ; Save for RETurn
2719   13A8 2A 3F 23    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2720   13AB 22 53 23    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2721   13AE 21 00 00    	LD      HL,0
2722   13B1 E5          	PUSH    HL              ; Flag no string found
2723   13B2 2A EA 22    	LD      HL,(STRSPC)     ; Get bottom of string space
2724   13B5 E5          	PUSH    HL              ; Save bottom of string space
2725   13B6 21 43 23    	LD      HL,TMSTPL       ; Temporary string pool
2726   13B9 EB          GRBLP:  EX      DE,HL
2727   13BA 2A 41 23    	LD      HL,(TMSTPT)     ; Temporary string pool pointer
2728   13BD EB          	EX      DE,HL
2729   13BE CD 60 08    	CALL    CPDEHL          ; Temporary string pool done?
2730   13C1 01 B9 13    	LD      BC,GRBLP        ; Loop until string pool done
2731   13C4 C2 0D 14    	JP      NZ,STPOOL       ; No - See if in string area
2732   13C7 2A 66 23    	LD      HL,(PROGND)     ; Start of simple variables
2733   13CA EB          SMPVAR: EX      DE,HL
2734   13CB 2A 68 23    	LD      HL,(VAREND)     ; End of simple variables
2735   13CE EB          	EX      DE,HL
2736   13CF CD 60 08    	CALL    CPDEHL          ; All simple strings done?
2737   13D2 CA E0 13    	JP      Z,ARRLP         ; Yes - Do string arrays
2738   13D5 7E          	LD      A,(HL)          ; Get type of variable
2739   13D6 23          	INC     HL
2740   13D7 23          	INC     HL
2741   13D8 B7          	OR      A               ; "S" flag set if string
2742   13D9 CD 10 14    	CALL    STRADD          ; See if string in string area
2743   13DC C3 CA 13    	JP      SMPVAR          ; Loop until simple ones done
2744   13DF             
2745   13DF C1          GNXARY: POP     BC              ; Scrap address of this array
2746   13E0 EB          ARRLP:  EX      DE,HL
2747   13E1 2A 6A 23    	LD      HL,(ARREND)     ; End of string arrays
2748   13E4 EB          	EX      DE,HL
2749   13E5 CD 60 08    	CALL    CPDEHL          ; All string arrays done?
2750   13E8 CA 36 14    	JP      Z,SCNEND        ; Yes - Move string if found
2751   13EB CD BD 18    	CALL    LOADFP          ; Get array name to BCDE
2752   13EE 7B          	LD      A,E             ; Get type of array
2753   13EF E5          	PUSH    HL              ; Save address of num of dim'ns
2754   13F0 09          	ADD     HL,BC           ; Start of next array
2755   13F1 B7          	OR      A               ; Test type of array
2756   13F2 F2 DF 13    	JP      P,GNXARY        ; Numeric array - Ignore it
2757   13F5 22 55 23    	LD      (CUROPR),HL     ; Save address of next array
2758   13F8 E1          	POP     HL              ; Get address of num of dim'ns
2759   13F9 4E          	LD      C,(HL)          ; BC = Number of dimensions
2760   13FA 06 00       	LD      B,0
2761   13FC 09          	ADD     HL,BC           ; Two bytes per dimension size
2762   13FD 09          	ADD     HL,BC
2763   13FE 23          	INC     HL              ; Plus one for number of dim'ns
2764   13FF EB          GRBARY: EX      DE,HL
2765   1400 2A 55 23    	LD      HL,(CUROPR)     ; Get address of next array
2766   1403 EB          	EX      DE,HL
2767   1404 CD 60 08    	CALL    CPDEHL          ; Is this array finished?
2768   1407 CA E0 13    	JP      Z,ARRLP         ; Yes - Get next one
2769   140A 01 FF 13    	LD      BC,GRBARY       ; Loop until array all done
2770   140D C5          STPOOL: PUSH    BC              ; Save return address
2771   140E F6 80       	OR      80H             ; Flag string type
2772   1410 7E          STRADD: LD      A,(HL)          ; Get string length
2773   1411 23          	INC     HL
2774   1412 23          	INC     HL
2775   1413 5E          	LD      E,(HL)          ; Get LSB of string address
2776   1414 23          	INC     HL
2777   1415 56          	LD      D,(HL)          ; Get MSB of string address
2778   1416 23          	INC     HL
2779   1417 F0          	RET     P               ; Not a string - Return
2780   1418 B7          	OR      A               ; Set flags on string length
2781   1419 C8          	RET     Z               ; Null string - Return
2782   141A 44          	LD      B,H             ; Save variable pointer
2783   141B 4D          	LD      C,L
2784   141C 2A 53 23    	LD      HL,(STRBOT)     ; Bottom of new area
2785   141F CD 60 08    	CALL    CPDEHL          ; String been done?
2786   1422 60          	LD      H,B             ; Restore variable pointer
2787   1423 69          	LD      L,C
2788   1424 D8          	RET     C               ; String done - Ignore
2789   1425 E1          	POP     HL              ; Return address
2790   1426 E3          	EX      (SP),HL         ; Lowest available string area
2791   1427 CD 60 08    	CALL    CPDEHL          ; String within string area?
2792   142A E3          	EX      (SP),HL         ; Lowest available string area
2793   142B E5          	PUSH    HL              ; Re-save return address
2794   142C 60          	LD      H,B             ; Restore variable pointer
2795   142D 69          	LD      L,C
2796   142E D0          	RET     NC              ; Outside string area - Ignore
2797   142F C1          	POP     BC              ; Get return , Throw 2 away
2798   1430 F1          	POP     AF              ;
2799   1431 F1          	POP     AF              ;
2800   1432 E5          	PUSH    HL              ; Save variable pointer
2801   1433 D5          	PUSH    DE              ; Save address of current
2802   1434 C5          	PUSH    BC              ; Put back return address
2803   1435 C9          	RET                     ; Go to it
2804   1436             
2805   1436 D1          SCNEND: POP     DE              ; Addresses of strings
2806   1437 E1          	POP     HL              ;
2807   1438 7D          	LD      A,L             ; HL = 0 if no more to do
2808   1439 B4          	OR      H
2809   143A C8          	RET     Z               ; No more to do - Return
2810   143B 2B          	DEC     HL
2811   143C 46          	LD      B,(HL)          ; MSB of address of string
2812   143D 2B          	DEC     HL
2813   143E 4E          	LD      C,(HL)          ; LSB of address of string
2814   143F E5          	PUSH    HL              ; Save variable address
2815   1440 2B          	DEC     HL
2816   1441 2B          	DEC     HL
2817   1442 6E          	LD      L,(HL)          ; HL = Length of string
2818   1443 26 00       	LD      H,0
2819   1445 09          	ADD     HL,BC           ; Address of end of string+1
2820   1446 50          	LD      D,B             ; String address to DE
2821   1447 59          	LD      E,C
2822   1448 2B          	DEC     HL              ; Last byte in string
2823   1449 44          	LD      B,H             ; Address to BC
2824   144A 4D          	LD      C,L
2825   144B 2A 53 23    	LD      HL,(STRBOT)     ; Current bottom of string area
2826   144E CD 61 05    	CALL    MOVSTR          ; Move string to new address
2827   1451 E1          	POP     HL              ; Restore variable address
2828   1452 71          	LD      (HL),C          ; Save new LSB of address
2829   1453 23          	INC     HL
2830   1454 70          	LD      (HL),B          ; Save new MSB of address
2831   1455 69          	LD      L,C             ; Next string area+1 to HL
2832   1456 60          	LD      H,B
2833   1457 2B          	DEC     HL              ; Next string area address
2834   1458 C3 AB 13    	JP      GARBLP          ; Look for more strings
2835   145B             
2836   145B C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2837   145C E5          	PUSH    HL              ;
2838   145D 2A 74 23    	LD      HL,(FPREG)      ; Get first string
2839   1460 E3          	EX      (SP),HL         ; Save first string
2840   1461 CD 15 0F    	CALL    OPRND           ; Get second string
2841   1464 E3          	EX      (SP),HL         ; Restore first string
2842   1465 CD 90 0E    	CALL    TSTSTR          ; Make sure it's a string
2843   1468 7E          	LD      A,(HL)          ; Get length of second string
2844   1469 E5          	PUSH    HL              ; Save first string
2845   146A 2A 74 23    	LD      HL,(FPREG)      ; Get second string
2846   146D E5          	PUSH    HL              ; Save second string
2847   146E 86          	ADD     A,(HL)          ; Add length of second string
2848   146F 1E 1C       	LD      E,LS            ; ?LS Error
2849   1471 DA A6 05    	JP      C,ERROR         ; String too long - Error
2850   1474 CD 14 13    	CALL    MKTMST          ; Make temporary string
2851   1477 D1          	POP     DE              ; Get second string to DE
2852   1478 CD AC 14    	CALL    GSTRDE          ; Move to string pool if needed
2853   147B E3          	EX      (SP),HL         ; Get first string
2854   147C CD AB 14    	CALL    GSTRHL          ; Move to string pool if needed
2855   147F E5          	PUSH    HL              ; Save first string
2856   1480 2A 51 23    	LD      HL,(TMPSTR+2)   ; Temporary string address
2857   1483 EB          	EX      DE,HL           ; To DE
2858   1484 CD 92 14    	CALL    SSTSA           ; First string to string area
2859   1487 CD 92 14    	CALL    SSTSA           ; Second string to string area
2860   148A 21 AA 0E    	LD      HL,EVAL2        ; Return to evaluation loop
2861   148D E3          	EX      (SP),HL         ; Save return,get code string
2862   148E E5          	PUSH    HL              ; Save code string address
2863   148F C3 45 13    	JP      TSTOPL          ; To temporary string to pool
2864   1492             
2865   1492 E1          SSTSA:  POP     HL              ; Return address
2866   1493 E3          	EX      (SP),HL         ; Get string block,save return
2867   1494 7E          	LD      A,(HL)          ; Get length of string
2868   1495 23          	INC     HL
2869   1496 23          	INC     HL
2870   1497 4E          	LD      C,(HL)          ; Get LSB of string address
2871   1498 23          	INC     HL
2872   1499 46          	LD      B,(HL)          ; Get MSB of string address
2873   149A 6F          	LD      L,A             ; Length to L
2874   149B 2C          TOSTRA: INC     L               ; INC - DECed after
2875   149C 2D          TSALP:  DEC     L               ; Count bytes moved
2876   149D C8          	RET     Z               ; End of string - Return
2877   149E 0A          	LD      A,(BC)          ; Get source
2878   149F 12          	LD      (DE),A          ; Save destination
2879   14A0 03          	INC     BC              ; Next source
2880   14A1 13          	INC     DE              ; Next destination
2881   14A2 C3 9C 14    	JP      TSALP           ; Loop until string moved
2882   14A5             
2883   14A5 CD 90 0E    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2884   14A8 2A 74 23    GSTRCU: LD      HL,(FPREG)      ; Get current string
2885   14AB EB          GSTRHL: EX      DE,HL           ; Save DE
2886   14AC CD C6 14    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2887   14AF EB          	EX      DE,HL           ; Restore DE
2888   14B0 C0          	RET     NZ              ; No - Return
2889   14B1 D5          	PUSH    DE              ; Save string
2890   14B2 50          	LD      D,B             ; String block address to DE
2891   14B3 59          	LD      E,C
2892   14B4 1B          	DEC     DE              ; Point to length
2893   14B5 4E          	LD      C,(HL)          ; Get string length
2894   14B6 2A 53 23    	LD      HL,(STRBOT)     ; Current bottom of string area
2895   14B9 CD 60 08    	CALL    CPDEHL          ; Last one in string area?
2896   14BC C2 C4 14    	JP      NZ,POPHL        ; No - Return
2897   14BF 47          	LD      B,A             ; Clear B (A=0)
2898   14C0 09          	ADD     HL,BC           ; Remove string from str' area
2899   14C1 22 53 23    	LD      (STRBOT),HL     ; Save new bottom of str' area
2900   14C4 E1          POPHL:  POP     HL              ; Restore string
2901   14C5 C9          	RET
2902   14C6             
2903   14C6 2A 41 23    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2904   14C9 2B          	DEC     HL              ; Back
2905   14CA 46          	LD      B,(HL)          ; Get MSB of address
2906   14CB 2B          	DEC     HL              ; Back
2907   14CC 4E          	LD      C,(HL)          ; Get LSB of address
2908   14CD 2B          	DEC     HL              ; Back
2909   14CE 2B          	DEC     HL              ; Back
2910   14CF CD 60 08    	CALL    CPDEHL          ; String last in string pool?
2911   14D2 C0          	RET     NZ              ; Yes - Leave it
2912   14D3 22 41 23    	LD      (TMSTPT),HL     ; Save new string pool top
2913   14D6 C9          	RET
2914   14D7             
2915   14D7 01 56 12    LEN:    LD      BC,PASSA        ; To return integer A
2916   14DA C5          	PUSH    BC              ; Save address
2917   14DB CD A5 14    GETLEN: CALL    GETSTR          ; Get string and its length
2918   14DE AF          	XOR     A
2919   14DF 57          	LD      D,A             ; Clear D
2920   14E0 32 3D 23    	LD      (TYPE),A        ; Set type to numeric
2921   14E3 7E          	LD      A,(HL)          ; Get length of string
2922   14E4 B7          	OR      A               ; Set status flags
2923   14E5 C9          	RET
2924   14E6             
2925   14E6 01 56 12    ASC:    LD      BC,PASSA        ; To return integer A
2926   14E9 C5          	PUSH    BC              ; Save address
2927   14EA CD DB 14    GTFLNM: CALL    GETLEN          ; Get length of string
2928   14ED CA E6 0A    	JP      Z,FCERR         ; Null string - Error
2929   14F0 23          	INC     HL
2930   14F1 23          	INC     HL
2931   14F2 5E          	LD      E,(HL)          ; Get LSB of address
2932   14F3 23          	INC     HL
2933   14F4 56          	LD      D,(HL)          ; Get MSB of address
2934   14F5 1A          	LD      A,(DE)          ; Get first byte of string
2935   14F6 C9          	RET
2936   14F7             
2937   14F7 3E 01       CHR:    LD      A,1             ; One character string
2938   14F9 CD 14 13    	CALL    MKTMST          ; Make a temporary string
2939   14FC CD F0 15    	CALL    MAKINT          ; Make it integer A
2940   14FF 2A 51 23    	LD      HL,(TMPSTR+2)   ; Get address of string
2941   1502 73          	LD      (HL),E          ; Save character
2942   1503 C1          TOPOOL: POP     BC              ; Clean up stack
2943   1504 C3 45 13    	JP      TSTOPL          ; Temporary string to pool
2944   1507             
2945   1507 CD A0 15    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2946   150A AF          	XOR     A               ; Start at first byte in string
2947   150B E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2948   150C 4F          	LD      C,A             ; Starting position in string
2949   150D E5          MID1:   PUSH    HL              ; Save string block address
2950   150E 7E          	LD      A,(HL)          ; Get length of string
2951   150F B8          	CP      B               ; Compare with number given
2952   1510 DA 15 15    	JP      C,ALLFOL        ; All following bytes required
2953   1513 78          	LD      A,B             ; Get new length
2954   1514 11          	.BYTE      11H             ; Skip "LD C,0"
2955   1515 0E 00       ALLFOL: LD      C,0             ; First byte of string
2956   1517 C5          	PUSH    BC              ; Save position in string
2957   1518 CD 7E 13    	CALL    TESTR           ; See if enough string space
2958   151B C1          	POP     BC              ; Get position in string
2959   151C E1          	POP     HL              ; Restore string block address
2960   151D E5          	PUSH    HL              ; And re-save it
2961   151E 23          	INC     HL
2962   151F 23          	INC     HL
2963   1520 46          	LD      B,(HL)          ; Get LSB of address
2964   1521 23          	INC     HL
2965   1522 66          	LD      H,(HL)          ; Get MSB of address
2966   1523 68          	LD      L,B             ; HL = address of string
2967   1524 06 00       	LD      B,0             ; BC = starting address
2968   1526 09          	ADD     HL,BC           ; Point to that byte
2969   1527 44          	LD      B,H             ; BC = source string
2970   1528 4D          	LD      C,L
2971   1529 CD 17 13    	CALL    CRTMST          ; Create a string entry
2972   152C 6F          	LD      L,A             ; Length of new string
2973   152D CD 9B 14    	CALL    TOSTRA          ; Move string to string area
2974   1530 D1          	POP     DE              ; Clear stack
2975   1531 CD AC 14    	CALL    GSTRDE          ; Move to string pool if needed
2976   1534 C3 45 13    	JP      TSTOPL          ; Temporary string to pool
2977   1537             
2978   1537 CD A0 15    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2979   153A D1          	POP     DE              ; Get string length
2980   153B D5          	PUSH    DE              ; And re-save
2981   153C 1A          	LD      A,(DE)          ; Get length
2982   153D 90          	SUB     B               ; Move back N bytes
2983   153E C3 0B 15    	JP      RIGHT1          ; Go and get sub-string
2984   1541             
2985   1541 EB          MID:    EX      DE,HL           ; Get code string address
2986   1542 7E          	LD      A,(HL)          ; Get next byte ',' or ")"
2987   1543 CD A5 15    	CALL    MIDNUM          ; Get number supplied
2988   1546 04          	INC     B               ; Is it character zero?
2989   1547 05          	DEC     B
2990   1548 CA E6 0A    	JP      Z,FCERR         ; Yes - Error
2991   154B C5          	PUSH    BC              ; Save starting position
2992   154C 1E FF       	LD      E,255           ; All of string
2993   154E FE 29       	CP      ')'             ; Any length given?
2994   1550 CA 5A 15    	JP      Z,RSTSTR        ; No - Rest of string
2995   1553 CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
2996   1556 2C          	.BYTE      ','
2997   1557 CD ED 15    	CALL    GETINT          ; Get integer 0-255
2998   155A CD 66 08    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2999   155D 29          	.BYTE      ")"
3000   155E F1          	POP     AF              ; Restore starting position
3001   155F E3          	EX      (SP),HL         ; Get string,8ave code string
3002   1560 01 0D 15    	LD      BC,MID1         ; Continuation of MID$ routine
3003   1563 C5          	PUSH    BC              ; Save for return
3004   1564 3D          	DEC     A               ; Starting position-1
3005   1565 BE          	CP      (HL)            ; Compare with length
3006   1566 06 00       	LD      B,0             ; Zero bytes length
3007   1568 D0          	RET     NC              ; Null string if start past end
3008   1569 4F          	LD      C,A             ; Save starting position-1
3009   156A 7E          	LD      A,(HL)          ; Get length of string
3010   156B 91          	SUB     C               ; Subtract start
3011   156C BB          	CP      E               ; Enough string for it?
3012   156D 47          	LD      B,A             ; Save maximum length available
3013   156E D8          	RET     C               ; Truncate string if needed
3014   156F 43          	LD      B,E             ; Set specified length
3015   1570 C9          	RET                     ; Go and create string
3016   1571             
3017   1571 CD DB 14    VAL:    CALL    GETLEN          ; Get length of string
3018   1574 CA 8E 16    	JP      Z,RESZER        ; Result zero
3019   1577 5F          	LD      E,A             ; Save length
3020   1578 23          	INC     HL
3021   1579 23          	INC     HL
3022   157A 7E          	LD      A,(HL)          ; Get LSB of address
3023   157B 23          	INC     HL
3024   157C 66          	LD      H,(HL)          ; Get MSB of address
3025   157D 6F          	LD      L,A             ; HL = String address
3026   157E E5          	PUSH    HL              ; Save string address
3027   157F 19          	ADD     HL,DE
3028   1580 46          	LD      B,(HL)          ; Get end of string+1 byte
3029   1581 72          	LD      (HL),D          ; Zero it to terminate
3030   1582 E3          	EX      (SP),HL         ; Save string end,get start
3031   1583 C5          	PUSH    BC              ; Save end+1 byte
3032   1584 7E          	LD      A,(HL)          ; Get starting byte
3033   1585 FE 24       	CP      '$'             ; Hex number indicated? [function added]
3034   1587 C2 8F 15    	JP      NZ,VAL1
3035   158A CD D3 1D    	CALL    HEXTFP          ; Convert Hex to FPREG
3036   158D 18 0D       	JR      VAL3
3037   158F FE 25       VAL1:   CP      '%'             ; Binary number indicated? [function added]
3038   1591 C2 99 15    	JP      NZ,VAL2
3039   1594 CD 43 1E    	CALL    BINTFP          ; Convert Bin to FPREG
3040   1597 18 03       	JR      VAL3
3041   1599 CD 75 19    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3042   159C C1          VAL3:   POP     BC              ; Restore end+1 byte
3043   159D E1          	POP     HL              ; Restore end+1 address
3044   159E 70          	LD      (HL),B          ; Put back original byte
3045   159F C9          	RET
3046   15A0             
3047   15A0 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
3048   15A1 CD 66 08    	CALL    CHKSYN          ; Make sure ")" follows
3049   15A4 29          	.BYTE      ")"
3050   15A5 C1          MIDNUM: POP     BC              ; Get return address
3051   15A6 D1          	POP     DE              ; Get number supplied
3052   15A7 C5          	PUSH    BC              ; Re-save return address
3053   15A8 43          	LD      B,E             ; Number to B
3054   15A9 C9          	RET
3055   15AA             
3056   15AA CD F0 15    INP:    CALL    MAKINT          ; Make it integer A
3057   15AD 32 CF 22    	LD      (INPORT),A      ; Set input port
3058   15B0 CD CE 22    	CALL    INPSUB          ; Get input from port
3059   15B3 C3 56 12    	JP      PASSA           ; Return integer A
3060   15B6             
3061   15B6 CD DA 15    POUT:   CALL    SETIO           ; Set up port number
3062   15B9 C3 96 22    	JP      OUTSUB          ; Output data and return
3063   15BC             
3064   15BC CD DA 15    WAIT:   CALL    SETIO           ; Set up port number
3065   15BF F5          	PUSH    AF              ; Save AND mask
3066   15C0 1E 00       	LD      E,0             ; Assume zero if none given
3067   15C2 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
3068   15C3 CD 00 0A    	CALL    GETCHR          ; Get next character
3069   15C6 CA D0 15    	JP      Z,NOXOR         ; No XOR byte given
3070   15C9 CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
3071   15CC 2C          	.BYTE      ','
3072   15CD CD ED 15    	CALL    GETINT          ; Get integer 0-255 to XOR with
3073   15D0 C1          NOXOR:  POP     BC              ; Restore AND mask
3074   15D1 CD CE 22    WAITLP: CALL    INPSUB          ; Get input
3075   15D4 AB          	XOR     E               ; Flip selected bits
3076   15D5 A0          	AND     B               ; Result non-zero?
3077   15D6 CA D1 15    	JP      Z,WAITLP        ; No = keep waiting
3078   15D9 C9          	RET
3079   15DA             
3080   15DA CD ED 15    SETIO:  CALL    GETINT          ; Get integer 0-255
3081   15DD 32 CF 22    	LD      (INPORT),A      ; Set input port
3082   15E0 32 97 22    	LD      (OTPORT),A      ; Set output port
3083   15E3 CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
3084   15E6 2C          	.BYTE      ','
3085   15E7 C3 ED 15    	JP      GETINT          ; Get integer 0-255 and return
3086   15EA             
3087   15EA CD 00 0A    FNDNUM: CALL    GETCHR          ; Get next character
3088   15ED CD 8C 0E    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3089   15F0 CD CB 0A    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3090   15F3 7A          	LD      A,D             ; Get MSB of number
3091   15F4 B7          	OR      A               ; Zero?
3092   15F5 C2 E6 0A    	JP      NZ,FCERR        ; No - Error
3093   15F8 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
3094   15F9 CD 00 0A    	CALL    GETCHR          ; Get next character
3095   15FC 7B          	LD      A,E             ; Get number to A
3096   15FD C9          	RET
3097   15FE             
3098   15FE CD D1 0A    PEEK:   CALL    DEINT           ; Get memory address
3099   1601 1A          	LD      A,(DE)          ; Get byte in memory
3100   1602 C3 56 12    	JP      PASSA           ; Return integer A
3101   1605             
3102   1605 CD 8C 0E    POKE:   CALL    GETNUM          ; Get memory address
3103   1608 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 3276
3104   160B D5          	PUSH    DE              ; Save memory address
3105   160C CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
3106   160F 2C          	.BYTE   ','
3107   1610 CD ED 15    	CALL    GETINT          ; Get integer 0-255
3108   1613 D1          	POP     DE              ; Restore memory address
3109   1614 12          	LD      (DE),A          ; Load it into memory
3110   1615 C9          	RET
3111   1616             
3112   1616 21 EC 1A    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3113   1619 CD BD 18    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3114   161C C3 28 16    	JP      FPADD           ; Add BCDE to FPREG
3115   161F             
3116   161F CD BD 18    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3117   1622 21          	.BYTE      21H             ; Skip "POP BC" and "POP DE"
3118   1623 C1          PSUB:   POP     BC              ; Get FP number from stack
3119   1624 D1          	POP     DE
3120   1625 CD 97 18    SUBCDE: CALL    INVSGN          ; Negate FPREG
3121   1628 78          FPADD:  LD      A,B             ; Get FP exponent
3122   1629 B7          	OR      A               ; Is number zero?
3123   162A C8          	RET     Z               ; Yes - Nothing to add
3124   162B 3A 77 23    	LD      A,(FPEXP)       ; Get FPREG exponent
3125   162E B7          	OR      A               ; Is this number zero?
3126   162F CA AF 18    	JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3127   1632 90          	SUB     B               ; BCDE number larger?
3128   1633 D2 42 16    	JP      NC,NOSWAP       ; No - Don't swap them
3129   1636 2F          	CPL                     ; Two's complement
3130   1637 3C          	INC     A               ;  FP exponent
3131   1638 EB          	EX      DE,HL
3132   1639 CD 9F 18    	CALL    STAKFP          ; Put FPREG on stack
3133   163C EB          	EX      DE,HL
3134   163D CD AF 18    	CALL    FPBCDE          ; Move BCDE to FPREG
3135   1640 C1          	POP     BC              ; Restore number from stack
3136   1641 D1          	POP     DE
3137   1642 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3138   1644 D0          	RET     NC              ; Yes - First number is result
3139   1645 F5          	PUSH    AF              ; Save number of bits to scale
3140   1646 CD D4 18    	CALL    SIGNS           ; Set MSBs & sign of result
3141   1649 67          	LD      H,A             ; Save sign of result
3142   164A F1          	POP     AF              ; Restore scaling factor
3143   164B CD ED 16    	CALL    SCALE           ; Scale BCDE to same exponent
3144   164E B4          	OR      H               ; Result to be positive?
3145   164F 21 74 23    	LD      HL,FPREG        ; Point to FPREG
3146   1652 F2 68 16    	JP      P,MINCDE        ; No - Subtract FPREG from CDE
3147   1655 CD CD 16    	CALL    PLUCDE          ; Add FPREG to CDE
3148   1658 D2 AE 16    	JP      NC,RONDUP       ; No overflow - Round it up
3149   165B 23          	INC     HL              ; Point to exponent
3150   165C 34          	INC     (HL)            ; Increment it
3151   165D CA A1 05    	JP      Z,OVERR         ; Number overflowed - Error
3152   1660 2E 01       	LD      L,1             ; 1 bit to shift right
3153   1662 CD 03 17    	CALL    SHRT1           ; Shift result right
3154   1665 C3 AE 16    	JP      RONDUP          ; Round it up
3155   1668             
3156   1668 AF          MINCDE: XOR     A               ; Clear A and carry
3157   1669 90          	SUB     B               ; Negate exponent
3158   166A 47          	LD      B,A             ; Re-save exponent
3159   166B 7E          	LD      A,(HL)          ; Get LSB of FPREG
3160   166C 9B          	SBC     A, E            ; Subtract LSB of BCDE
3161   166D 5F          	LD      E,A             ; Save LSB of BCDE
3162   166E 23          	INC     HL
3163   166F 7E          	LD      A,(HL)          ; Get NMSB of FPREG
3164   1670 9A          	SBC     A,D             ; Subtract NMSB of BCDE
3165   1671 57          	LD      D,A             ; Save NMSB of BCDE
3166   1672 23          	INC     HL
3167   1673 7E          	LD      A,(HL)          ; Get MSB of FPREG
3168   1674 99          	SBC     A,C             ; Subtract MSB of BCDE
3169   1675 4F          	LD      C,A             ; Save MSB of BCDE
3170   1676 DC D9 16    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3171   1679             
3172   1679 68          BNORM:  LD      L,B             ; L = Exponent
3173   167A 63          	LD      H,E             ; H = LSB
3174   167B AF          	XOR     A
3175   167C 47          BNRMLP: LD      B,A             ; Save bit count
3176   167D 79          	LD      A,C             ; Get MSB
3177   167E B7          	OR      A               ; Is it zero?
3178   167F C2 9B 16    	JP      NZ,PNORM        ; No - Do it bit at a time
3179   1682 4A          	LD      C,D             ; MSB = NMSB
3180   1683 54          	LD      D,H             ; NMSB= LSB
3181   1684 65          	LD      H,L             ; LSB = VLSB
3182   1685 6F          	LD      L,A             ; VLSB= 0
3183   1686 78          	LD      A,B             ; Get exponent
3184   1687 D6 08       	SUB     8               ; Count 8 bits
3185   1689 FE E0       	CP      -24-8           ; Was number zero?
3186   168B C2 7C 16    	JP      NZ,BNRMLP       ; No - Keep normalising
3187   168E AF          RESZER: XOR     A               ; Result is zero
3188   168F 32 77 23    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3189   1692 C9          	RET
3190   1693             
3191   1693 05          NORMAL: DEC     B               ; Count bits
3192   1694 29          	ADD     HL,HL           ; Shift HL left
3193   1695 7A          	LD      A,D             ; Get NMSB
3194   1696 17          	RLA                     ; Shift left with last bit
3195   1697 57          	LD      D,A             ; Save NMSB
3196   1698 79          	LD      A,C             ; Get MSB
3197   1699 8F          	ADC     A,A             ; Shift left with last bit
3198   169A 4F          	LD      C,A             ; Save MSB
3199   169B F2 93 16    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3200   169E 78          	LD      A,B             ; Number of bits shifted
3201   169F 5C          	LD      E,H             ; Save HL in EB
3202   16A0 45          	LD      B,L
3203   16A1 B7          	OR      A               ; Any shifting done?
3204   16A2 CA AE 16    	JP      Z,RONDUP        ; No - Round it up
3205   16A5 21 77 23    	LD      HL,FPEXP        ; Point to exponent
3206   16A8 86          	ADD     A,(HL)          ; Add shifted bits
3207   16A9 77          	LD      (HL),A          ; Re-save exponent
3208   16AA D2 8E 16    	JP      NC,RESZER       ; Underflow - Result is zero
3209   16AD C8          	RET     Z               ; Result is zero
3210   16AE 78          RONDUP: LD      A,B             ; Get VLSB of number
3211   16AF 21 77 23    RONDB:  LD      HL,FPEXP        ; Point to exponent
3212   16B2 B7          	OR      A               ; Any rounding?
3213   16B3 FC C0 16    	CALL    M,FPROND        ; Yes - Round number up
3214   16B6 46          	LD      B,(HL)          ; B = Exponent
3215   16B7 23          	INC     HL
3216   16B8 7E          	LD      A,(HL)          ; Get sign of result
3217   16B9 E6 80       	AND     10000000B       ; Only bit 7 needed
3218   16BB A9          	XOR     C               ; Set correct sign
3219   16BC 4F          	LD      C,A             ; Save correct sign in number
3220   16BD C3 AF 18    	JP      FPBCDE          ; Move BCDE to FPREG
3221   16C0             
3222   16C0 1C          FPROND: INC     E               ; Round LSB
3223   16C1 C0          	RET     NZ              ; Return if ok
3224   16C2 14          	INC     D               ; Round NMSB
3225   16C3 C0          	RET     NZ              ; Return if ok
3226   16C4 0C          	INC     C               ; Round MSB
3227   16C5 C0          	RET     NZ              ; Return if ok
3228   16C6 0E 80       	LD      C,80H           ; Set normal value
3229   16C8 34          	INC     (HL)            ; Increment exponent
3230   16C9 C0          	RET     NZ              ; Return if ok
3231   16CA C3 A1 05    	JP      OVERR           ; Overflow error
3232   16CD             
3233   16CD 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3234   16CE 83          	ADD     A,E             ; Add LSB of BCDE
3235   16CF 5F          	LD      E,A             ; Save LSB of BCDE
3236   16D0 23          	INC     HL
3237   16D1 7E          	LD      A,(HL)          ; Get NMSB of FPREG
3238   16D2 8A          	ADC     A,D             ; Add NMSB of BCDE
3239   16D3 57          	LD      D,A             ; Save NMSB of BCDE
3240   16D4 23          	INC     HL
3241   16D5 7E          	LD      A,(HL)          ; Get MSB of FPREG
3242   16D6 89          	ADC     A,C             ; Add MSB of BCDE
3243   16D7 4F          	LD      C,A             ; Save MSB of BCDE
3244   16D8 C9          	RET
3245   16D9             
3246   16D9 21 78 23    COMPL:  LD      HL,SGNRES       ; Sign of result
3247   16DC 7E          	LD      A,(HL)          ; Get sign of result
3248   16DD 2F          	CPL                     ; Negate it
3249   16DE 77          	LD      (HL),A          ; Put it back
3250   16DF AF          	XOR     A
3251   16E0 6F          	LD      L,A             ; Set L to zero
3252   16E1 90          	SUB     B               ; Negate exponent,set carry
3253   16E2 47          	LD      B,A             ; Re-save exponent
3254   16E3 7D          	LD      A,L             ; Load zero
3255   16E4 9B          	SBC     A,E             ; Negate LSB
3256   16E5 5F          	LD      E,A             ; Re-save LSB
3257   16E6 7D          	LD      A,L             ; Load zero
3258   16E7 9A          	SBC     A,D             ; Negate NMSB
3259   16E8 57          	LD      D,A             ; Re-save NMSB
3260   16E9 7D          	LD      A,L             ; Load zero
3261   16EA 99          	SBC     A,C             ; Negate MSB
3262   16EB 4F          	LD      C,A             ; Re-save MSB
3263   16EC C9          	RET
3264   16ED             
3265   16ED 06 00       SCALE:  LD      B,0             ; Clear underflow
3266   16EF D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3267   16F1 DA FC 16    	JP      C,SHRITE        ; No - Shift right A bits
3268   16F4 43          	LD      B,E             ; <- Shift
3269   16F5 5A          	LD      E,D             ; <- right
3270   16F6 51          	LD      D,C             ; <- eight
3271   16F7 0E 00       	LD      C,0             ; <- bits
3272   16F9 C3 EF 16    	JP      SCALLP          ; More bits to shift
3273   16FC             
3274   16FC C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3275   16FE 6F          	LD      L,A             ; Save bits to shift
3276   16FF AF          SHRLP:  XOR     A               ; Flag for all done
3277   1700 2D          	DEC     L               ; All shifting done?
3278   1701 C8          	RET     Z               ; Yes - Return
3279   1702 79          	LD      A,C             ; Get MSB
3280   1703 1F          SHRT1:  RRA                     ; Shift it right
3281   1704 4F          	LD      C,A             ; Re-save
3282   1705 7A          	LD      A,D             ; Get NMSB
3283   1706 1F          	RRA                     ; Shift right with last bit
3284   1707 57          	LD      D,A             ; Re-save it
3285   1708 7B          	LD      A,E             ; Get LSB
3286   1709 1F          	RRA                     ; Shift right with last bit
3287   170A 5F          	LD      E,A             ; Re-save it
3288   170B 78          	LD      A,B             ; Get underflow
3289   170C 1F          	RRA                     ; Shift right with last bit
3290   170D 47          	LD      B,A             ; Re-save underflow
3291   170E C3 FF 16    	JP      SHRLP           ; More bits to do
3292   1711             
3293   1711 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3294   1715             
3295   1715 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3296   1716 AA 56 19 80 	.BYTE      0AAH,056H,019H,080H     ; 0.59898
3297   171A F1 22 76 80 	.BYTE      0F1H,022H,076H,080H     ; 0.96147
3298   171E 45 AA 38 82 	.BYTE      045H,0AAH,038H,082H     ; 2.88539
3299   1722             
3300   1722 CD 6E 18    LOG:    CALL    TSTSGN          ; Test sign of value
3301   1725 B7          	OR      A
3302   1726 EA E6 0A    	JP      PE,FCERR        ; ?FC Error if <= zero
3303   1729 21 77 23    	LD      HL,FPEXP        ; Point to exponent
3304   172C 7E          	LD      A,(HL)          ; Get exponent
3305   172D 01 35 80    	LD      BC,8035H        ; BCDE = SQR(1/2)
3306   1730 11 F3 04    	LD      DE,04F3H
3307   1733 90          	SUB     B               ; Scale value to be < 1
3308   1734 F5          	PUSH    AF              ; Save scale factor
3309   1735 70          	LD      (HL),B          ; Save new exponent
3310   1736 D5          	PUSH    DE              ; Save SQR(1/2)
3311   1737 C5          	PUSH    BC
3312   1738 CD 28 16    	CALL    FPADD           ; Add SQR(1/2) to value
3313   173B C1          	POP     BC              ; Restore SQR(1/2)
3314   173C D1          	POP     DE
3315   173D 04          	INC     B               ; Make it SQR(2)
3316   173E CD C4 17    	CALL    DVBCDE          ; Divide by SQR(2)
3317   1741 21 11 17    	LD      HL,UNITY        ; Point to 1.
3318   1744 CD 1F 16    	CALL    SUBPHL          ; Subtract FPREG from 1
3319   1747 21 15 17    	LD      HL,LOGTAB       ; Coefficient table
3320   174A CD B6 1B    	CALL    SUMSER          ; Evaluate sum of series
3321   174D 01 80 80    	LD      BC,8080H        ; BCDE = -0.5
3322   1750 11 00 00    	LD      DE,0000H
3323   1753 CD 28 16    	CALL    FPADD           ; Subtract 0.5 from FPREG
3324   1756 F1          	POP     AF              ; Restore scale factor
3325   1757 CD E9 19    	CALL    RSCALE          ; Re-scale number
3326   175A 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3327   175D 11 18 72    	LD      DE,7218H
3328   1760 21          	.BYTE      21H             ; Skip "POP BC" and "POP DE"
3329   1761             
3330   1761 C1          MULT:   POP     BC              ; Get number from stack
3331   1762 D1          	POP     DE
3332   1763 CD 6E 18    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3333   1766 C8          	RET     Z               ; Return zero if zero
3334   1767 2E 00       	LD      L,0             ; Flag add exponents
3335   1769 CD 2C 18    	CALL    ADDEXP          ; Add exponents
3336   176C 79          	LD      A,C             ; Get MSB of multiplier
3337   176D 32 86 23    	LD      (MULVAL),A      ; Save MSB of multiplier
3338   1770 EB          	EX      DE,HL
3339   1771 22 87 23    	LD      (MULVAL+1),HL   ; Save rest of multiplier
3340   1774 01 00 00    	LD      BC,0            ; Partial product (BCDE) = zero
3341   1777 50          	LD      D,B
3342   1778 58          	LD      E,B
3343   1779 21 79 16    	LD      HL,BNORM        ; Address of normalise
3344   177C E5          	PUSH    HL              ; Save for return
3345   177D 21 85 17    	LD      HL,MULT8        ; Address of 8 bit multiply
3346   1780 E5          	PUSH    HL              ; Save for NMSB,MSB
3347   1781 E5          	PUSH    HL              ;
3348   1782 21 74 23    	LD      HL,FPREG        ; Point to number
3349   1785 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3350   1786 23          	INC     HL              ; Point to NMSB
3351   1787 B7          	OR      A               ; Test LSB
3352   1788 CA B1 17    	JP      Z,BYTSFT        ; Zero - shift to next byte
3353   178B E5          	PUSH    HL              ; Save address of number
3354   178C 2E 08       	LD      L,8             ; 8 bits to multiply by
3355   178E 1F          MUL8LP: RRA                     ; Shift LSB right
3356   178F 67          	LD      H,A             ; Save LSB
3357   1790 79          	LD      A,C             ; Get MSB
3358   1791 D2 9F 17    	JP      NC,NOMADD       ; Bit was zero - Don't add
3359   1794 E5          	PUSH    HL              ; Save LSB and count
3360   1795 2A 87 23    	LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3361   1798 19          	ADD     HL,DE           ; Add NMSB and LSB
3362   1799 EB          	EX      DE,HL           ; Leave sum in DE
3363   179A E1          	POP     HL              ; Restore MSB and count
3364   179B 3A 86 23    	LD      A,(MULVAL)      ; Get MSB of multiplier
3365   179E 89          	ADC     A,C             ; Add MSB
3366   179F 1F          NOMADD: RRA                     ; Shift MSB right
3367   17A0 4F          	LD      C,A             ; Re-save MSB
3368   17A1 7A          	LD      A,D             ; Get NMSB
3369   17A2 1F          	RRA                     ; Shift NMSB right
3370   17A3 57          	LD      D,A             ; Re-save NMSB
3371   17A4 7B          	LD      A,E             ; Get LSB
3372   17A5 1F          	RRA                     ; Shift LSB right
3373   17A6 5F          	LD      E,A             ; Re-save LSB
3374   17A7 78          	LD      A,B             ; Get VLSB
3375   17A8 1F          	RRA                     ; Shift VLSB right
3376   17A9 47          	LD      B,A             ; Re-save VLSB
3377   17AA 2D          	DEC     L               ; Count bits multiplied
3378   17AB 7C          	LD      A,H             ; Get LSB of multiplier
3379   17AC C2 8E 17    	JP      NZ,MUL8LP       ; More - Do it
3380   17AF E1          POPHRT: POP     HL              ; Restore address of number
3381   17B0 C9          	RET
3382   17B1             
3383   17B1 43          BYTSFT: LD      B,E             ; Shift partial product left
3384   17B2 5A          	LD      E,D
3385   17B3 51          	LD      D,C
3386   17B4 4F          	LD      C,A
3387   17B5 C9          	RET
3388   17B6             
3389   17B6 CD 9F 18    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3390   17B9 01 20 84    	LD      BC,8420H        ; BCDE = 10.
3391   17BC 11 00 00    	LD      DE,0000H
3392   17BF CD AF 18    	CALL    FPBCDE          ; Move 10 to FPREG
3393   17C2             
3394   17C2 C1          DIV:    POP     BC              ; Get number from stack
3395   17C3 D1          	POP     DE
3396   17C4 CD 6E 18    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3397   17C7 CA 95 05    	JP      Z,DZERR         ; Error if division by zero
3398   17CA 2E FF       	LD      L,-1            ; Flag subtract exponents
3399   17CC CD 2C 18    	CALL    ADDEXP          ; Subtract exponents
3400   17CF 34          	INC     (HL)            ; Add 2 to exponent to adjust
3401   17D0 34          	INC     (HL)
3402   17D1 2B          	DEC     HL              ; Point to MSB
3403   17D2 7E          	LD      A,(HL)          ; Get MSB of dividend
3404   17D3 32 A2 22    	LD      (DIV3),A        ; Save for subtraction
3405   17D6 2B          	DEC     HL
3406   17D7 7E          	LD      A,(HL)          ; Get NMSB of dividend
3407   17D8 32 9E 22    	LD      (DIV2),A        ; Save for subtraction
3408   17DB 2B          	DEC     HL
3409   17DC 7E          	LD      A,(HL)          ; Get MSB of dividend
3410   17DD 32 9A 22    	LD      (DIV1),A        ; Save for subtraction
3411   17E0 41          	LD      B,C             ; Get MSB
3412   17E1 EB          	EX      DE,HL           ; NMSB,LSB to HL
3413   17E2 AF          	XOR     A
3414   17E3 4F          	LD      C,A             ; Clear MSB of quotient
3415   17E4 57          	LD      D,A             ; Clear NMSB of quotient
3416   17E5 5F          	LD      E,A             ; Clear LSB of quotient
3417   17E6 32 A5 22    	LD      (DIV4),A        ; Clear overflow count
3418   17E9 E5          DIVLP:  PUSH    HL              ; Save divisor
3419   17EA C5          	PUSH    BC
3420   17EB 7D          	LD      A,L             ; Get LSB of number
3421   17EC CD 99 22    	CALL    DIVSUP          ; Subt' divisor from dividend
3422   17EF DE 00       	SBC     A,0             ; Count for overflows
3423   17F1 3F          	CCF
3424   17F2 D2 FC 17    	JP      NC,RESDIV       ; Restore divisor if borrow
3425   17F5 32 A5 22    	LD      (DIV4),A        ; Re-save overflow count
3426   17F8 F1          	POP     AF              ; Scrap divisor
3427   17F9 F1          	POP     AF
3428   17FA 37          	SCF                     ; Set carry to
3429   17FB D2          	.BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3430   17FC             
3431   17FC C1          RESDIV: POP     BC              ; Restore divisor
3432   17FD E1          	POP     HL
3433   17FE 79          	LD      A,C             ; Get MSB of quotient
3434   17FF 3C          	INC     A
3435   1800 3D          	DEC     A
3436   1801 1F          	RRA                     ; Bit 0 to bit 7
3437   1802 FA AF 16    	JP      M,RONDB         ; Done - Normalise result
3438   1805 17          	RLA                     ; Restore carry
3439   1806 7B          	LD      A,E             ; Get LSB of quotient
3440   1807 17          	RLA                     ; Double it
3441   1808 5F          	LD      E,A             ; Put it back
3442   1809 7A          	LD      A,D             ; Get NMSB of quotient
3443   180A 17          	RLA                     ; Double it
3444   180B 57          	LD      D,A             ; Put it back
3445   180C 79          	LD      A,C             ; Get MSB of quotient
3446   180D 17          	RLA                     ; Double it
3447   180E 4F          	LD      C,A             ; Put it back
3448   180F 29          	ADD     HL,HL           ; Double NMSB,LSB of divisor
3449   1810 78          	LD      A,B             ; Get MSB of divisor
3450   1811 17          	RLA                     ; Double it
3451   1812 47          	LD      B,A             ; Put it back
3452   1813 3A A5 22    	LD      A,(DIV4)        ; Get VLSB of quotient
3453   1816 17          	RLA                     ; Double it
3454   1817 32 A5 22    	LD      (DIV4),A        ; Put it back
3455   181A 79          	LD      A,C             ; Get MSB of quotient
3456   181B B2          	OR      D               ; Merge NMSB
3457   181C B3          	OR      E               ; Merge LSB
3458   181D C2 E9 17    	JP      NZ,DIVLP        ; Not done - Keep dividing
3459   1820 E5          	PUSH    HL              ; Save divisor
3460   1821 21 77 23    	LD      HL,FPEXP        ; Point to exponent
3461   1824 35          	DEC     (HL)            ; Divide by 2
3462   1825 E1          	POP     HL              ; Restore divisor
3463   1826 C2 E9 17    	JP      NZ,DIVLP        ; Ok - Keep going
3464   1829 C3 A1 05    	JP      OVERR           ; Overflow error
3465   182C             
3466   182C 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3467   182D B7          	OR      A               ; Test it
3468   182E CA 50 18    	JP      Z,OVTST3        ; Zero - Result zero
3469   1831 7D          	LD      A,L             ; Get add/subtract flag
3470   1832 21 77 23    	LD      HL,FPEXP        ; Point to exponent
3471   1835 AE          	XOR     (HL)            ; Add or subtract it
3472   1836 80          	ADD     A,B             ; Add the other exponent
3473   1837 47          	LD      B,A             ; Save new exponent
3474   1838 1F          	RRA                     ; Test exponent for overflow
3475   1839 A8          	XOR     B
3476   183A 78          	LD      A,B             ; Get exponent
3477   183B F2 4F 18    	JP      P,OVTST2        ; Positive - Test for overflow
3478   183E C6 80       	ADD     A,80H           ; Add excess 128
3479   1840 77          	LD      (HL),A          ; Save new exponent
3480   1841 CA AF 17    	JP      Z,POPHRT        ; Zero - Result zero
3481   1844 CD D4 18    	CALL    SIGNS           ; Set MSBs and sign of result
3482   1847 77          	LD      (HL),A          ; Save new exponent
3483   1848 2B          	DEC     HL              ; Point to MSB
3484   1849 C9          	RET
3485   184A             
3486   184A CD 6E 18    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3487   184D 2F          	CPL                     ; Invert sign
3488   184E E1          	POP     HL              ; Clean up stack
3489   184F B7          OVTST2: OR      A               ; Test if new exponent zero
3490   1850 E1          OVTST3: POP     HL              ; Clear off return address
3491   1851 F2 8E 16    	JP      P,RESZER        ; Result zero
3492   1854 C3 A1 05    	JP      OVERR           ; Overflow error
3493   1857             
3494   1857 CD BA 18    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3495   185A 78          	LD      A,B             ; Get exponent
3496   185B B7          	OR      A               ; Is it zero?
3497   185C C8          	RET     Z               ; Yes - Result is zero
3498   185D C6 02       	ADD     A,2             ; Multiply by 4
3499   185F DA A1 05    	JP      C,OVERR         ; Overflow - ?OV Error
3500   1862 47          	LD      B,A             ; Re-save exponent
3501   1863 CD 28 16    	CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3502   1866 21 77 23    	LD      HL,FPEXP        ; Point to exponent
3503   1869 34          	INC     (HL)            ; Double number (Times 10)
3504   186A C0          	RET     NZ              ; Ok - Return
3505   186B C3 A1 05    	JP      OVERR           ; Overflow error
3506   186E             
3507   186E 3A 77 23    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3508   1871 B7          	OR      A
3509   1872 C8          	RET     Z               ; RETurn if number is zero
3510   1873 3A 76 23    	LD      A,(FPREG+2)     ; Get MSB of FPREG
3511   1876 FE          	.BYTE      0FEH            ; Test sign
3512   1877 2F          RETREL: CPL                     ; Invert sign
3513   1878 17          	RLA                     ; Sign bit to carry
3514   1879 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3515   187A C0          	RET     NZ              ; Return -1 if negative
3516   187B 3C          	INC     A               ; Bump to +1
3517   187C C9          	RET                     ; Positive - Return +1
3518   187D             
3519   187D CD 6E 18    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3520   1880 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3521   1882 11 00 00    	LD      DE,0            ; Zero NMSB and LSB
3522   1885 21 77 23    RETINT: LD      HL,FPEXP        ; Point to exponent
3523   1888 4F          	LD      C,A             ; CDE = MSB,NMSB and LSB
3524   1889 70          	LD      (HL),B          ; Save exponent
3525   188A 06 00       	LD      B,0             ; CDE = integer to normalise
3526   188C 23          	INC     HL              ; Point to sign of result
3527   188D 36 80       	LD      (HL),80H        ; Set sign of result
3528   188F 17          	RLA                     ; Carry = sign of integer
3529   1890 C3 76 16    	JP      CONPOS          ; Set sign of result
3530   1893             
3531   1893 CD 6E 18    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3532   1896 F0          	RET     P               ; Return if positive
3533   1897 21 76 23    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3534   189A 7E          	LD      A,(HL)          ; Get sign of mantissa
3535   189B EE 80       	XOR     80H             ; Invert sign of mantissa
3536   189D 77          	LD      (HL),A          ; Re-save sign of mantissa
3537   189E C9          	RET
3538   189F             
3539   189F EB          STAKFP: EX      DE,HL           ; Save code string address
3540   18A0 2A 74 23    	LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3541   18A3 E3          	EX      (SP),HL         ; Stack them,get return
3542   18A4 E5          	PUSH    HL              ; Re-save return
3543   18A5 2A 76 23    	LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3544   18A8 E3          	EX      (SP),HL         ; Stack them,get return
3545   18A9 E5          	PUSH    HL              ; Re-save return
3546   18AA EB          	EX      DE,HL           ; Restore code string address
3547   18AB C9          	RET
3548   18AC             
3549   18AC CD BD 18    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3550   18AF EB          FPBCDE: EX      DE,HL           ; Save code string address
3551   18B0 22 74 23    	LD      (FPREG),HL      ; Save LSB,NLSB of number
3552   18B3 60          	LD      H,B             ; Exponent of number
3553   18B4 69          	LD      L,C             ; MSB of number
3554   18B5 22 76 23    	LD      (FPREG+2),HL    ; Save MSB and exponent
3555   18B8 EB          	EX      DE,HL           ; Restore code string address
3556   18B9 C9          	RET
3557   18BA             
3558   18BA 21 74 23    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3559   18BD 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3560   18BE 23          	INC     HL
3561   18BF 56          	LD      D,(HL)          ; Get NMSB of number
3562   18C0 23          	INC     HL
3563   18C1 4E          	LD      C,(HL)          ; Get MSB of number
3564   18C2 23          	INC     HL
3565   18C3 46          	LD      B,(HL)          ; Get exponent of number
3566   18C4 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3567   18C5 C9          	RET
3568   18C6             
3569   18C6 11 74 23    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3570   18C9 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3571   18CB 1A          DETHLB: LD      A,(DE)          ; Get source
3572   18CC 77          	LD      (HL),A          ; Save destination
3573   18CD 13          	INC     DE              ; Next source
3574   18CE 23          	INC     HL              ; Next destination
3575   18CF 05          	DEC     B               ; Count bytes
3576   18D0 C2 CB 18    	JP      NZ,DETHLB       ; Loop if more
3577   18D3 C9          	RET
3578   18D4             
3579   18D4 21 76 23    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3580   18D7 7E          	LD      A,(HL)          ; Get MSB
3581   18D8 07          	RLCA                    ; Old sign to carry
3582   18D9 37          	SCF                     ; Set MSBit
3583   18DA 1F          	RRA                     ; Set MSBit of MSB
3584   18DB 77          	LD      (HL),A          ; Save new MSB
3585   18DC 3F          	CCF                     ; Complement sign
3586   18DD 1F          	RRA                     ; Old sign to carry
3587   18DE 23          	INC     HL
3588   18DF 23          	INC     HL
3589   18E0 77          	LD      (HL),A          ; Set sign of result
3590   18E1 79          	LD      A,C             ; Get MSB
3591   18E2 07          	RLCA                    ; Old sign to carry
3592   18E3 37          	SCF                     ; Set MSBit
3593   18E4 1F          	RRA                     ; Set MSBit of MSB
3594   18E5 4F          	LD      C,A             ; Save MSB
3595   18E6 1F          	RRA
3596   18E7 AE          	XOR     (HL)            ; New sign of result
3597   18E8 C9          	RET
3598   18E9             
3599   18E9 78          CMPNUM: LD      A,B             ; Get exponent of number
3600   18EA B7          	OR      A
3601   18EB CA 6E 18    	JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3602   18EE 21 77 18    	LD      HL,RETREL       ; Return relation routine
3603   18F1 E5          	PUSH    HL              ; Save for return
3604   18F2 CD 6E 18    	CALL    TSTSGN          ; Test sign of FPREG
3605   18F5 79          	LD      A,C             ; Get MSB of number
3606   18F6 C8          	RET     Z               ; FPREG zero - Number's MSB
3607   18F7 21 76 23    	LD      HL,FPREG+2      ; MSB of FPREG
3608   18FA AE          	XOR     (HL)            ; Combine signs
3609   18FB 79          	LD      A,C             ; Get MSB of number
3610   18FC F8          	RET     M               ; Exit if signs different
3611   18FD CD 03 19    	CALL    CMPFP           ; Compare FP numbers
3612   1900 1F          	RRA                     ; Get carry to sign
3613   1901 A9          	XOR     C               ; Combine with MSB of number
3614   1902 C9          	RET
3615   1903             
3616   1903 23          CMPFP:  INC     HL              ; Point to exponent
3617   1904 78          	LD      A,B             ; Get exponent
3618   1905 BE          	CP      (HL)            ; Compare exponents
3619   1906 C0          	RET     NZ              ; Different
3620   1907 2B          	DEC     HL              ; Point to MBS
3621   1908 79          	LD      A,C             ; Get MSB
3622   1909 BE          	CP      (HL)            ; Compare MSBs
3623   190A C0          	RET     NZ              ; Different
3624   190B 2B          	DEC     HL              ; Point to NMSB
3625   190C 7A          	LD      A,D             ; Get NMSB
3626   190D BE          	CP      (HL)            ; Compare NMSBs
3627   190E C0          	RET     NZ              ; Different
3628   190F 2B          	DEC     HL              ; Point to LSB
3629   1910 7B          	LD      A,E             ; Get LSB
3630   1911 96          	SUB     (HL)            ; Compare LSBs
3631   1912 C0          	RET     NZ              ; Different
3632   1913 E1          	POP     HL              ; Drop RETurn
3633   1914 E1          	POP     HL              ; Drop another RETurn
3634   1915 C9          	RET
3635   1916             
3636   1916 47          FPINT:  LD      B,A             ; <- Move
3637   1917 4F          	LD      C,A             ; <- exponent
3638   1918 57          	LD      D,A             ; <- to all
3639   1919 5F          	LD      E,A             ; <- bits
3640   191A B7          	OR      A               ; Test exponent
3641   191B C8          	RET     Z               ; Zero - Return zero
3642   191C E5          	PUSH    HL              ; Save pointer to number
3643   191D CD BA 18    	CALL    BCDEFP          ; Move FPREG to BCDE
3644   1920 CD D4 18    	CALL    SIGNS           ; Set MSBs & sign of result
3645   1923 AE          	XOR     (HL)            ; Combine with sign of FPREG
3646   1924 67          	LD      H,A             ; Save combined signs
3647   1925 FC 3A 19    	CALL    M,DCBCDE        ; Negative - Decrement BCDE
3648   1928 3E 98       	LD      A,80H+24        ; 24 bits
3649   192A 90          	SUB     B               ; Bits to shift
3650   192B CD ED 16    	CALL    SCALE           ; Shift BCDE
3651   192E 7C          	LD      A,H             ; Get combined sign
3652   192F 17          	RLA                     ; Sign to carry
3653   1930 DC C0 16    	CALL    C,FPROND        ; Negative - Round number up
3654   1933 06 00       	LD      B,0             ; Zero exponent
3655   1935 DC D9 16    	CALL    C,COMPL         ; If negative make positive
3656   1938 E1          	POP     HL              ; Restore pointer to number
3657   1939 C9          	RET
3658   193A             
3659   193A 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3660   193B 7A          	LD      A,D             ; Test LSBs
3661   193C A3          	AND     E
3662   193D 3C          	INC     A
3663   193E C0          	RET     NZ              ; Exit if LSBs not FFFF
3664   193F 0B          	DEC     BC              ; Decrement MSBs
3665   1940 C9          	RET
3666   1941             
3667   1941 21 77 23    INT:    LD      HL,FPEXP        ; Point to exponent
3668   1944 7E          	LD      A,(HL)          ; Get exponent
3669   1945 FE 98       	CP      80H+24          ; Integer accuracy only?
3670   1947 3A 74 23    	LD      A,(FPREG)       ; Get LSB
3671   194A D0          	RET     NC              ; Yes - Already integer
3672   194B 7E          	LD      A,(HL)          ; Get exponent
3673   194C CD 16 19    	CALL    FPINT           ; F.P to integer
3674   194F 36 98       	LD      (HL),80H+24     ; Save 24 bit integer
3675   1951 7B          	LD      A,E             ; Get LSB of number
3676   1952 F5          	PUSH    AF              ; Save LSB
3677   1953 79          	LD      A,C             ; Get MSB of number
3678   1954 17          	RLA                     ; Sign to carry
3679   1955 CD 76 16    	CALL    CONPOS          ; Set sign of result
3680   1958 F1          	POP     AF              ; Restore LSB of number
3681   1959 C9          	RET
3682   195A             
3683   195A 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3684   195D 78          	LD      A,B             ; Test multiplier
3685   195E B1          	OR      C
3686   195F C8          	RET     Z               ; Return zero if zero
3687   1960 3E 10       	LD      A,16            ; 16 bits
3688   1962 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3689   1963 DA 9A 11    	JP      C,BSERR         ; ?BS Error if overflow
3690   1966 EB          	EX      DE,HL
3691   1967 29          	ADD     HL,HL           ; Shift multiplier left
3692   1968 EB          	EX      DE,HL
3693   1969 D2 70 19    	JP      NC,NOMLAD       ; Bit was zero - No add
3694   196C 09          	ADD     HL,BC           ; Add multiplicand
3695   196D DA 9A 11    	JP      C,BSERR         ; ?BS Error if overflow
3696   1970 3D          NOMLAD: DEC     A               ; Count bits
3697   1971 C2 62 19    	JP      NZ,MLDBLP       ; More
3698   1974 C9          	RET
3699   1975             
3700   1975 FE 2D       ASCTFP: CP      '-'             ; Negative?
3701   1977 F5          	PUSH    AF              ; Save it and flags
3702   1978 CA 81 19    	JP      Z,CNVNUM        ; Yes - Convert number
3703   197B FE 2B       	CP      '+'             ; Positive?
3704   197D CA 81 19    	JP      Z,CNVNUM        ; Yes - Convert number
3705   1980 2B          	DEC     HL              ; DEC 'cos GETCHR INCs
3706   1981 CD 8E 16    CNVNUM: CALL    RESZER          ; Set result to zero
3707   1984 47          	LD      B,A             ; Digits after point counter
3708   1985 57          	LD      D,A             ; Sign of exponent
3709   1986 5F          	LD      E,A             ; Exponent of ten
3710   1987 2F          	CPL
3711   1988 4F          	LD      C,A             ; Before or after point flag
3712   1989 CD 00 0A    MANLP:  CALL    GETCHR          ; Get next character
3713   198C DA D2 19    	JP      C,ADDIG         ; Digit - Add to number
3714   198F FE 2E       	CP      '.'
3715   1991 CA AD 19    	JP      Z,DPOINT        ; '.' - Flag point
3716   1994 FE 45       	CP      'E'
3717   1996 C2 B1 19    	JP      NZ,CONEXP       ; Not 'E' - Scale number
3718   1999 CD 00 0A    	CALL    GETCHR          ; Get next character
3719   199C CD C5 0F    	CALL    SGNEXP          ; Get sign of exponent
3720   199F CD 00 0A    EXPLP:  CALL    GETCHR          ; Get next character
3721   19A2 DA F4 19    	JP      C,EDIGIT        ; Digit - Add to exponent
3722   19A5 14          	INC     D               ; Is sign negative?
3723   19A6 C2 B1 19    	JP      NZ,CONEXP       ; No - Scale number
3724   19A9 AF          	XOR     A
3725   19AA 93          	SUB     E               ; Negate exponent
3726   19AB 5F          	LD      E,A             ; And re-save it
3727   19AC 0C          	INC     C               ; Flag end of number
3728   19AD 0C          DPOINT: INC     C               ; Flag point passed
3729   19AE CA 89 19    	JP      Z,MANLP         ; Zero - Get another digit
3730   19B1 E5          CONEXP: PUSH    HL              ; Save code string address
3731   19B2 7B          	LD      A,E             ; Get exponent
3732   19B3 90          	SUB     B               ; Subtract digits after point
3733   19B4 F4 CA 19    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3734   19B7 F2 C0 19    	JP      P,ENDCON        ; Positive - All done
3735   19BA F5          	PUSH    AF              ; Save number of times to /10
3736   19BB CD B6 17    	CALL    DIV10           ; Divide by 10
3737   19BE F1          	POP     AF              ; Restore count
3738   19BF 3C          	INC     A               ; Count divides
3739   19C0             
3740   19C0 C2 B4 19    ENDCON: JP      NZ,SCALMI       ; More to do
3741   19C3 D1          	POP     DE              ; Restore code string address
3742   19C4 F1          	POP     AF              ; Restore sign of number
3743   19C5 CC 97 18    	CALL    Z,INVSGN        ; Negative - Negate number
3744   19C8 EB          	EX      DE,HL           ; Code string address to HL
3745   19C9 C9          	RET
3746   19CA             
3747   19CA C8          SCALPL: RET     Z               ; Exit if no scaling needed
3748   19CB F5          MULTEN: PUSH    AF              ; Save count
3749   19CC CD 57 18    	CALL    MLSP10          ; Multiply number by 10
3750   19CF F1          	POP     AF              ; Restore count
3751   19D0 3D          	DEC     A               ; Count multiplies
3752   19D1 C9          	RET
3753   19D2             
3754   19D2 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3755   19D3 57          	LD      D,A             ; Save digit
3756   19D4 78          	LD      A,B             ; Get digits after point
3757   19D5 89          	ADC     A,C             ; Add one if after point
3758   19D6 47          	LD      B,A             ; Re-save counter
3759   19D7 C5          	PUSH    BC              ; Save point flags
3760   19D8 E5          	PUSH    HL              ; Save code string address
3761   19D9 D5          	PUSH    DE              ; Save digit
3762   19DA CD 57 18    	CALL    MLSP10          ; Multiply number by 10
3763   19DD F1          	POP     AF              ; Restore digit
3764   19DE D6 30       	SUB     '0'             ; Make it absolute
3765   19E0 CD E9 19    	CALL    RSCALE          ; Re-scale number
3766   19E3 E1          	POP     HL              ; Restore code string address
3767   19E4 C1          	POP     BC              ; Restore point flags
3768   19E5 D1          	POP     DE              ; Restore sign of exponent
3769   19E6 C3 89 19    	JP      MANLP           ; Get another digit
3770   19E9             
3771   19E9 CD 9F 18    RSCALE: CALL    STAKFP          ; Put number on stack
3772   19EC CD 80 18    	CALL    FLGREL          ; Digit to add to FPREG
3773   19EF C1          PADD:   POP     BC              ; Restore number
3774   19F0 D1          	POP     DE
3775   19F1 C3 28 16    	JP      FPADD           ; Add BCDE to FPREG and return
3776   19F4             
3777   19F4 7B          EDIGIT: LD      A,E             ; Get digit
3778   19F5 07          	RLCA                    ; Times 2
3779   19F6 07          	RLCA                    ; Times 4
3780   19F7 83          	ADD     A,E             ; Times 5
3781   19F8 07          	RLCA                    ; Times 10
3782   19F9 86          	ADD     A,(HL)          ; Add next digit
3783   19FA D6 30       	SUB     '0'             ; Make it absolute
3784   19FC 5F          	LD      E,A             ; Save new digit
3785   19FD C3 9F 19    	JP      EXPLP           ; Look for another digit
3786   1A00             
3787   1A00 E5          LINEIN: PUSH    HL              ; Save code string address
3788   1A01 21 2A 05    	LD      HL,INMSG        ; Output " in "
3789   1A04 CD 65 13    	CALL    PRS             ; Output string at HL
3790   1A07 E1          	POP     HL              ; Restore code string address
3791   1A08 EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3792   1A09 AF          	XOR     A
3793   1A0A 06 98       	LD      B,80H+24        ; 24 bits
3794   1A0C CD 85 18    	CALL    RETINT          ; Return the integer
3795   1A0F 21 64 13    	LD      HL,PRNUMS       ; Print number string
3796   1A12 E5          	PUSH    HL              ; Save for return
3797   1A13 21 79 23    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3798   1A16 E5          	PUSH    HL              ; Save for return
3799   1A17 CD 6E 18    	CALL    TSTSGN          ; Test sign of FPREG
3800   1A1A 36 20       	LD      (HL),' '        ; Space at start
3801   1A1C F2 21 1A    	JP      P,SPCFST        ; Positive - Space to start
3802   1A1F 36 2D       	LD      (HL),'-'        ; '-' sign at start
3803   1A21 23          SPCFST: INC     HL              ; First byte of number
3804   1A22 36 30       	LD      (HL),'0'        ; '0' if zero
3805   1A24 CA D7 1A    	JP      Z,JSTZER        ; Return '0' if zero
3806   1A27 E5          	PUSH    HL              ; Save buffer address
3807   1A28 FC 97 18    	CALL    M,INVSGN        ; Negate FPREG if negative
3808   1A2B AF          	XOR     A               ; Zero A
3809   1A2C F5          	PUSH    AF              ; Save it
3810   1A2D CD DD 1A    	CALL    RNGTST          ; Test number is in range
3811   1A30 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3812   1A33 11 F8 4F    	LD      DE,4FF8H
3813   1A36 CD E9 18    	CALL    CMPNUM          ; Compare numbers
3814   1A39 B7          	OR      A
3815   1A3A E2 4E 1A    	JP      PO,INRNG        ; > 99999.9 - Sort it out
3816   1A3D F1          	POP     AF              ; Restore count
3817   1A3E CD CB 19    	CALL    MULTEN          ; Multiply by ten
3818   1A41 F5          	PUSH    AF              ; Re-save count
3819   1A42 C3 30 1A    	JP      SIXDIG          ; Test it again
3820   1A45             
3821   1A45 CD B6 17    GTSIXD: CALL    DIV10           ; Divide by 10
3822   1A48 F1          	POP     AF              ; Get count
3823   1A49 3C          	INC     A               ; Count divides
3824   1A4A F5          	PUSH    AF              ; Re-save count
3825   1A4B CD DD 1A    	CALL    RNGTST          ; Test number is in range
3826   1A4E CD 16 16    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3827   1A51 3C          	INC     A
3828   1A52 CD 16 19    	CALL    FPINT           ; F.P to integer
3829   1A55 CD AF 18    	CALL    FPBCDE          ; Move BCDE to FPREG
3830   1A58 01 06 03    	LD      BC,0306H        ; 1E+06 to 1E-03 range
3831   1A5B F1          	POP     AF              ; Restore count
3832   1A5C 81          	ADD     A,C             ; 6 digits before point
3833   1A5D 3C          	INC     A               ; Add one
3834   1A5E FA 6A 1A    	JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3835   1A61 FE 08       	CP      6+1+1           ; More than 999999 ?
3836   1A63 D2 6A 1A    	JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3837   1A66 3C          	INC     A               ; Adjust for exponent
3838   1A67 47          	LD      B,A             ; Exponent of number
3839   1A68 3E 02       	LD      A,2             ; Make it zero after
3840   1A6A             
3841   1A6A 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3842   1A6B 3D          	DEC     A
3843   1A6C E1          	POP     HL              ; Restore buffer address
3844   1A6D F5          	PUSH    AF              ; Save count
3845   1A6E 11 F0 1A    	LD      DE,POWERS       ; Powers of ten
3846   1A71 05          	DEC     B               ; Count digits before point
3847   1A72 C2 7B 1A    	JP      NZ,DIGTXT       ; Not zero - Do number
3848   1A75 36 2E       	LD      (HL),'.'        ; Save point
3849   1A77 23          	INC     HL              ; Move on
3850   1A78 36 30       	LD      (HL),'0'        ; Save zero
3851   1A7A 23          	INC     HL              ; Move on
3852   1A7B 05          DIGTXT: DEC     B               ; Count digits before point
3853   1A7C 36 2E       	LD      (HL),'.'        ; Save point in case
3854   1A7E CC C4 18    	CALL    Z,INCHL         ; Last digit - move on
3855   1A81 C5          	PUSH    BC              ; Save digits before point
3856   1A82 E5          	PUSH    HL              ; Save buffer address
3857   1A83 D5          	PUSH    DE              ; Save powers of ten
3858   1A84 CD BA 18    	CALL    BCDEFP          ; Move FPREG to BCDE
3859   1A87 E1          	POP     HL              ; Powers of ten table
3860   1A88 06 2F       	LD      B, '0'-1        ; ASCII '0' - 1
3861   1A8A 04          TRYAGN: INC     B               ; Count subtractions
3862   1A8B 7B          	LD      A,E             ; Get LSB
3863   1A8C 96          	SUB     (HL)            ; Subtract LSB
3864   1A8D 5F          	LD      E,A             ; Save LSB
3865   1A8E 23          	INC     HL
3866   1A8F 7A          	LD      A,D             ; Get NMSB
3867   1A90 9E          	SBC     A,(HL)          ; Subtract NMSB
3868   1A91 57          	LD      D,A             ; Save NMSB
3869   1A92 23          	INC     HL
3870   1A93 79          	LD      A,C             ; Get MSB
3871   1A94 9E          	SBC     A,(HL)          ; Subtract MSB
3872   1A95 4F          	LD      C,A             ; Save MSB
3873   1A96 2B          	DEC     HL              ; Point back to start
3874   1A97 2B          	DEC     HL
3875   1A98 D2 8A 1A    	JP      NC,TRYAGN       ; No overflow - Try again
3876   1A9B CD CD 16    	CALL    PLUCDE          ; Restore number
3877   1A9E 23          	INC     HL              ; Start of next number
3878   1A9F CD AF 18    	CALL    FPBCDE          ; Move BCDE to FPREG
3879   1AA2 EB          	EX      DE,HL           ; Save point in table
3880   1AA3 E1          	POP     HL              ; Restore buffer address
3881   1AA4 70          	LD      (HL),B          ; Save digit in buffer
3882   1AA5 23          	INC     HL              ; And move on
3883   1AA6 C1          	POP     BC              ; Restore digit count
3884   1AA7 0D          	DEC     C               ; Count digits
3885   1AA8 C2 7B 1A    	JP      NZ,DIGTXT       ; More - Do them
3886   1AAB 05          	DEC     B               ; Any decimal part?
3887   1AAC CA BB 1A    	JP      Z,DOEBIT        ; No - Do 'E' bit
3888   1AAF 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3889   1AB0 7E          	LD      A,(HL)          ; Get character
3890   1AB1 FE 30       	CP      '0'             ; '0' character?
3891   1AB3 CA AF 1A    	JP      Z,SUPTLZ        ; Yes - Look back for more
3892   1AB6 FE 2E       	CP      '.'             ; A decimal point?
3893   1AB8 C4 C4 18    	CALL    NZ,INCHL        ; Move back over digit
3894   1ABB             
3895   1ABB F1          DOEBIT: POP     AF              ; Get 'E' flag
3896   1ABC CA DA 1A    	JP      Z,NOENED        ; No 'E' needed - End buffer
3897   1ABF 36 45       	LD      (HL),'E'        ; Put 'E' in buffer
3898   1AC1 23          	INC     HL              ; And move on
3899   1AC2 36 2B       	LD      (HL),'+'        ; Put '+' in buffer
3900   1AC4 F2 CB 1A    	JP      P,OUTEXP        ; Positive - Output exponent
3901   1AC7 36 2D       	LD      (HL),'-'        ; Put '-' in buffer
3902   1AC9 2F          	CPL                     ; Negate exponent
3903   1ACA 3C          	INC     A
3904   1ACB 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3905   1ACD 04          EXPTEN: INC     B               ; Count subtractions
3906   1ACE D6 0A       	SUB     10              ; Tens digit
3907   1AD0 D2 CD 1A    	JP      NC,EXPTEN       ; More to do
3908   1AD3 C6 3A       	ADD     A,'0'+10        ; Restore and make ASCII
3909   1AD5 23          	INC     HL              ; Move on
3910   1AD6 70          	LD      (HL),B          ; Save MSB of exponent
3911   1AD7 23          JSTZER: INC     HL              ;
3912   1AD8 77          	LD      (HL),A          ; Save LSB of exponent
3913   1AD9 23          	INC     HL
3914   1ADA 71          NOENED: LD      (HL),C          ; Mark end of buffer
3915   1ADB E1          	POP     HL              ; Restore code string address
3916   1ADC C9          	RET
3917   1ADD             
3918   1ADD 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3919   1AE0 11 F7 23    	LD      DE,23F7H
3920   1AE3 CD E9 18    	CALL    CMPNUM          ; Compare numbers
3921   1AE6 B7          	OR      A
3922   1AE7 E1          	POP     HL              ; Return address to HL
3923   1AE8 E2 45 1A    	JP      PO,GTSIXD       ; Too big - Divide by ten
3924   1AEB E9          	JP      (HL)            ; Otherwise return to caller
3925   1AEC             
3926   1AEC 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3927   1AF0             
3928   1AF0 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3929   1AF3 10 27 00    	.BYTE      010H,027H,000H  ;  10000
3930   1AF6 E8 03 00    	.BYTE      0E8H,003H,000H  ;   1000
3931   1AF9 64 00 00    	.BYTE      064H,000H,000H  ;    100
3932   1AFC 0A 00 00    	.BYTE      00AH,000H,000H  ;     10
3933   1AFF 01 00 00    	.BYTE      001H,000H,000H  ;      1
3934   1B02             
3935   1B02 21 97 18    NEGAFT: LD  HL,INVSGN           ; Negate result
3936   1B05 E3          	EX      (SP),HL         ; To be done after caller
3937   1B06 E9          	JP      (HL)            ; Return to caller
3938   1B07             
3939   1B07 CD 9F 18    SQR:    CALL    STAKFP          ; Put value on stack
3940   1B0A 21 EC 1A    	LD      HL,HALF         ; Set power to 1/2
3941   1B0D CD AC 18    	CALL    PHLTFP          ; Move 1/2 to FPREG
3942   1B10             
3943   1B10 C1          POWER:  POP     BC              ; Get base
3944   1B11 D1          	POP     DE
3945   1B12 CD 6E 18    	CALL    TSTSGN          ; Test sign of power
3946   1B15 78          	LD      A,B             ; Get exponent of base
3947   1B16 CA 55 1B    	JP      Z,EXP           ; Make result 1 if zero
3948   1B19 F2 20 1B    	JP      P,POWER1        ; Positive base - Ok
3949   1B1C B7          	OR      A               ; Zero to negative power?
3950   1B1D CA 95 05    	JP      Z,DZERR         ; Yes - ?/0 Error
3951   1B20 B7          POWER1: OR      A               ; Base zero?
3952   1B21 CA 8F 16    	JP      Z,SAVEXP        ; Yes - Return zero
3953   1B24 D5          	PUSH    DE              ; Save base
3954   1B25 C5          	PUSH    BC
3955   1B26 79          	LD      A,C             ; Get MSB of base
3956   1B27 F6 7F       	OR      01111111B       ; Get sign status
3957   1B29 CD BA 18    	CALL    BCDEFP          ; Move power to BCDE
3958   1B2C F2 3D 1B    	JP      P,POWER2        ; Positive base - Ok
3959   1B2F D5          	PUSH    DE              ; Save power
3960   1B30 C5          	PUSH    BC
3961   1B31 CD 41 19    	CALL    INT             ; Get integer of power
3962   1B34 C1          	POP     BC              ; Restore power
3963   1B35 D1          	POP     DE
3964   1B36 F5          	PUSH    AF              ; MSB of base
3965   1B37 CD E9 18    	CALL    CMPNUM          ; Power an integer?
3966   1B3A E1          	POP     HL              ; Restore MSB of base
3967   1B3B 7C          	LD      A,H             ; but don't affect flags
3968   1B3C 1F          	RRA                     ; Exponent odd or even?
3969   1B3D E1          POWER2: POP     HL              ; Restore MSB and exponent
3970   1B3E 22 76 23    	LD      (FPREG+2),HL    ; Save base in FPREG
3971   1B41 E1          	POP     HL              ; LSBs of base
3972   1B42 22 74 23    	LD      (FPREG),HL      ; Save in FPREG
3973   1B45 DC 02 1B    	CALL    C,NEGAFT        ; Odd power - Negate result
3974   1B48 CC 97 18    	CALL    Z,INVSGN        ; Negative base - Negate it
3975   1B4B D5          	PUSH    DE              ; Save power
3976   1B4C C5          	PUSH    BC
3977   1B4D CD 22 17    	CALL    LOG             ; Get LOG of base
3978   1B50 C1          	POP     BC              ; Restore power
3979   1B51 D1          	POP     DE
3980   1B52 CD 63 17    	CALL    FPMULT          ; Multiply LOG by power
3981   1B55             
3982   1B55 CD 9F 18    EXP:    CALL    STAKFP          ; Put value on stack
3983   1B58 01 38 81    	LD      BC,08138H       ; BCDE = 1/Ln(2)
3984   1B5B 11 3B AA    	LD      DE,0AA3BH
3985   1B5E CD 63 17    	CALL    FPMULT          ; Multiply value by 1/LN(2)
3986   1B61 3A 77 23    	LD      A,(FPEXP)       ; Get exponent
3987   1B64 FE 88       	CP      80H+8           ; Is it in range?
3988   1B66 D2 4A 18    	JP      NC,OVTST1       ; No - Test for overflow
3989   1B69 CD 41 19    	CALL    INT             ; Get INT of FPREG
3990   1B6C C6 80       	ADD     A,80H           ; For excess 128
3991   1B6E C6 02       	ADD     A,2             ; Exponent > 126?
3992   1B70 DA 4A 18    	JP      C,OVTST1        ; Yes - Test for overflow
3993   1B73 F5          	PUSH    AF              ; Save scaling factor
3994   1B74 21 11 17    	LD      HL,UNITY        ; Point to 1.
3995   1B77 CD 19 16    	CALL    ADDPHL          ; Add 1 to FPREG
3996   1B7A CD 5A 17    	CALL    MULLN2          ; Multiply by LN(2)
3997   1B7D F1          	POP     AF              ; Restore scaling factor
3998   1B7E C1          	POP     BC              ; Restore exponent
3999   1B7F D1          	POP     DE
4000   1B80 F5          	PUSH    AF              ; Save scaling factor
4001   1B81 CD 25 16    	CALL    SUBCDE          ; Subtract exponent from FPREG
4002   1B84 CD 97 18    	CALL    INVSGN          ; Negate result
4003   1B87 21 95 1B    	LD      HL,EXPTAB       ; Coefficient table
4004   1B8A CD C5 1B    	CALL    SMSER1          ; Sum the series
4005   1B8D 11 00 00    	LD      DE,0            ; Zero LSBs
4006   1B90 C1          	POP     BC              ; Scaling factor
4007   1B91 4A          	LD      C,D             ; Zero MSB
4008   1B92 C3 63 17    	JP      FPMULT          ; Scale result to correct value
4009   1B95             
4010   1B95 08          EXPTAB: .BYTE      8                       ; Table used by EXP
4011   1B96 40 2E 94 74 	.BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
4012   1B9A 70 4F 2E 77 	.BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
4013   1B9E 6E 02 88 7A 	.BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
4014   1BA2 E6 A0 2A 7C 	.BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
4015   1BA6 50 AA AA 7E 	.BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
4016   1BAA FF FF 7F 7F 	.BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
4017   1BAE 00 00 80 81 	.BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
4018   1BB2 00 00 00 81 	.BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
4019   1BB6             
4020   1BB6 CD 9F 18    SUMSER: CALL    STAKFP          ; Put FPREG on stack
4021   1BB9 11 61 17    	LD      DE,MULT         ; Multiply by "X"
4022   1BBC D5          	PUSH    DE              ; To be done after
4023   1BBD E5          	PUSH    HL              ; Save address of table
4024   1BBE CD BA 18    	CALL    BCDEFP          ; Move FPREG to BCDE
4025   1BC1 CD 63 17    	CALL    FPMULT          ; Square the value
4026   1BC4 E1          	POP     HL              ; Restore address of table
4027   1BC5 CD 9F 18    SMSER1: CALL    STAKFP          ; Put value on stack
4028   1BC8 7E          	LD      A,(HL)          ; Get number of coefficients
4029   1BC9 23          	INC     HL              ; Point to start of table
4030   1BCA CD AC 18    	CALL    PHLTFP          ; Move coefficient to FPREG
4031   1BCD 06          	.BYTE      06H             ; Skip "POP AF"
4032   1BCE F1          SUMLP:  POP     AF              ; Restore count
4033   1BCF C1          	POP     BC              ; Restore number
4034   1BD0 D1          	POP     DE
4035   1BD1 3D          	DEC     A               ; Cont coefficients
4036   1BD2 C8          	RET     Z               ; All done
4037   1BD3 D5          	PUSH    DE              ; Save number
4038   1BD4 C5          	PUSH    BC
4039   1BD5 F5          	PUSH    AF              ; Save count
4040   1BD6 E5          	PUSH    HL              ; Save address in table
4041   1BD7 CD 63 17    	CALL    FPMULT          ; Multiply FPREG by BCDE
4042   1BDA E1          	POP     HL              ; Restore address in table
4043   1BDB CD BD 18    	CALL    LOADFP          ; Number at HL to BCDE
4044   1BDE E5          	PUSH    HL              ; Save address in table
4045   1BDF CD 28 16    	CALL    FPADD           ; Add coefficient to FPREG
4046   1BE2 E1          	POP     HL              ; Restore address in table
4047   1BE3 C3 CE 1B    	JP      SUMLP           ; More coefficients
4048   1BE6             
4049   1BE6 CD 6E 18    RND:    CALL    TSTSGN          ; Test sign of FPREG
4050   1BE9 21 A9 22    	LD      HL,SEED+2       ; Random number seed
4051   1BEC FA 47 1C    	JP      M,RESEED        ; Negative - Re-seed
4052   1BEF 21 CA 22    	LD      HL,LSTRND       ; Last random number
4053   1BF2 CD AC 18    	CALL    PHLTFP          ; Move last RND to FPREG
4054   1BF5 21 A9 22    	LD      HL,SEED+2       ; Random number seed
4055   1BF8 C8          	RET     Z               ; Return if RND(0)
4056   1BF9 86          	ADD     A,(HL)          ; Add (SEED)+2)
4057   1BFA E6 07       	AND     00000111B       ; 0 to 7
4058   1BFC 06 00       	LD      B,0
4059   1BFE 77          	LD      (HL),A          ; Re-save seed
4060   1BFF 23          	INC     HL              ; Move to coefficient table
4061   1C00 87          	ADD     A,A             ; 4 bytes
4062   1C01 87          	ADD     A,A             ; per entry
4063   1C02 4F          	LD      C,A             ; BC = Offset into table
4064   1C03 09          	ADD     HL,BC           ; Point to coefficient
4065   1C04 CD BD 18    	CALL    LOADFP          ; Coefficient to BCDE
4066   1C07 CD 63 17    	CALL    FPMULT  ;       ; Multiply FPREG by coefficient
4067   1C0A 3A A8 22    	LD      A,(SEED+1)      ; Get (SEED+1)
4068   1C0D 3C          	INC     A               ; Add 1
4069   1C0E E6 03       	AND     00000011B       ; 0 to 3
4070   1C10 06 00       	LD      B,0
4071   1C12 FE 01       	CP      1               ; Is it zero?
4072   1C14 88          	ADC     A,B             ; Yes - Make it 1
4073   1C15 32 A8 22    	LD      (SEED+1),A      ; Re-save seed
4074   1C18 21 4B 1C    	LD      HL,RNDTAB-4     ; Addition table
4075   1C1B 87          	ADD     A,A             ; 4 bytes
4076   1C1C 87          	ADD     A,A             ; per entry
4077   1C1D 4F          	LD      C,A             ; BC = Offset into table
4078   1C1E 09          	ADD     HL,BC           ; Point to value
4079   1C1F CD 19 16    	CALL    ADDPHL          ; Add value to FPREG
4080   1C22 CD BA 18    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4081   1C25 7B          	LD      A,E             ; Get LSB
4082   1C26 59          	LD      E,C             ; LSB = MSB
4083   1C27 EE 4F       	XOR     01001111B       ; Fiddle around
4084   1C29 4F          	LD      C,A             ; New MSB
4085   1C2A 36 80       	LD      (HL),80H        ; Set exponent
4086   1C2C 2B          	DEC     HL              ; Point to MSB
4087   1C2D 46          	LD      B,(HL)          ; Get MSB
4088   1C2E 36 80       	LD      (HL),80H        ; Make value -0.5
4089   1C30 21 A7 22    	LD      HL,SEED         ; Random number seed
4090   1C33 34          	INC     (HL)            ; Count seed
4091   1C34 7E          	LD      A,(HL)          ; Get seed
4092   1C35 D6 AB       	SUB     171             ; Do it modulo 171
4093   1C37 C2 3E 1C    	JP      NZ,RND2         ; Non-zero - Ok
4094   1C3A 77          	LD      (HL),A          ; Zero seed
4095   1C3B 0C          	INC     C               ; Fillde about
4096   1C3C 15          	DEC     D               ; with the
4097   1C3D 1C          	INC     E               ; number
4098   1C3E CD 79 16    RND2:   CALL    BNORM           ; Normalise number
4099   1C41 21 CA 22    	LD      HL,LSTRND       ; Save random number
4100   1C44 C3 C6 18    	JP      FPTHL           ; Move FPREG to last and return
4101   1C47             
4102   1C47 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4103   1C48 2B          	DEC     HL
4104   1C49 77          	LD      (HL),A
4105   1C4A 2B          	DEC     HL
4106   1C4B 77          	LD      (HL),A
4107   1C4C C3 22 1C    	JP      RND1            ; Return RND seed
4108   1C4F             
4109   1C4F 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4110   1C53 99 E9 92 69 	.BYTE   099H,0E9H,092H,069H
4111   1C57 10 D1 75 68 	.BYTE   010H,0D1H,075H,068H
4112   1C5B             
4113   1C5B 21 A5 1C    COS:    LD      HL,HALFPI       ; Point to PI/2
4114   1C5E CD 19 16    	CALL    ADDPHL          ; Add it to PPREG
4115   1C61 CD 9F 18    SIN:    CALL    STAKFP          ; Put angle on stack
4116   1C64 01 49 83    	LD      BC,8349H        ; BCDE = 2 PI
4117   1C67 11 DB 0F    	LD      DE,0FDBH
4118   1C6A CD AF 18    	CALL    FPBCDE          ; Move 2 PI to FPREG
4119   1C6D C1          	POP     BC              ; Restore angle
4120   1C6E D1          	POP     DE
4121   1C6F CD C4 17    	CALL    DVBCDE          ; Divide angle by 2 PI
4122   1C72 CD 9F 18    	CALL    STAKFP          ; Put it on stack
4123   1C75 CD 41 19    	CALL    INT             ; Get INT of result
4124   1C78 C1          	POP     BC              ; Restore number
4125   1C79 D1          	POP     DE
4126   1C7A CD 25 16    	CALL    SUBCDE          ; Make it 0 <= value < 1
4127   1C7D 21 A9 1C    	LD      HL,QUARTR       ; Point to 0.25
4128   1C80 CD 1F 16    	CALL    SUBPHL          ; Subtract value from 0.25
4129   1C83 CD 6E 18    	CALL    TSTSGN          ; Test sign of value
4130   1C86 37          	SCF                     ; Flag positive
4131   1C87 F2 91 1C    	JP      P,SIN1          ; Positive - Ok
4132   1C8A CD 16 16    	CALL    ROUND           ; Add 0.5 to value
4133   1C8D CD 6E 18    	CALL    TSTSGN          ; Test sign of value
4134   1C90 B7          	OR      A               ; Flag negative
4135   1C91 F5          SIN1:   PUSH    AF              ; Save sign
4136   1C92 F4 97 18    	CALL    P,INVSGN        ; Negate value if positive
4137   1C95 21 A9 1C    	LD      HL,QUARTR       ; Point to 0.25
4138   1C98 CD 19 16    	CALL    ADDPHL          ; Add 0.25 to value
4139   1C9B F1          	POP     AF              ; Restore sign
4140   1C9C D4 97 18    	CALL    NC,INVSGN       ; Negative - Make positive
4141   1C9F 21 AD 1C    	LD      HL,SINTAB       ; Coefficient table
4142   1CA2 C3 B6 1B    	JP      SUMSER          ; Evaluate sum of series
4143   1CA5             
4144   1CA5 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4145   1CA9             
4146   1CA9 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4147   1CAD             
4148   1CAD 05          SINTAB: .BYTE   5                       ; Table used by SIN
4149   1CAE BA D7 1E 86 	.BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4150   1CB2 64 26 99 87 	.BYTE   064H,026H,099H,087H     ;-76.575
4151   1CB6 58 34 23 87 	.BYTE   058H,034H,023H,087H     ; 81.602
4152   1CBA E0 5D A5 86 	.BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4153   1CBE DA 0F 49 83 	.BYTE   0DAH,00FH,049H,083H     ;  6.2832
4154   1CC2             
4155   1CC2 CD 9F 18    TAN:    CALL    STAKFP          ; Put angle on stack
4156   1CC5 CD 61 1C    	CALL    SIN             ; Get SIN of angle
4157   1CC8 C1          	POP     BC              ; Restore angle
4158   1CC9 E1          	POP     HL
4159   1CCA CD 9F 18    	CALL    STAKFP          ; Save SIN of angle
4160   1CCD EB          	EX      DE,HL           ; BCDE = Angle
4161   1CCE CD AF 18    	CALL    FPBCDE          ; Angle to FPREG
4162   1CD1 CD 5B 1C    	CALL    COS             ; Get COS of angle
4163   1CD4 C3 C2 17    	JP      DIV             ; TAN = SIN / COS
4164   1CD7             
4165   1CD7 CD 6E 18    ATN:    CALL    TSTSGN          ; Test sign of value
4166   1CDA FC 02 1B    	CALL    M,NEGAFT        ; Negate result after if -ve
4167   1CDD FC 97 18    	CALL    M,INVSGN        ; Negate value if -ve
4168   1CE0 3A 77 23    	LD      A,(FPEXP)       ; Get exponent
4169   1CE3 FE 81       	CP      81H             ; Number less than 1?
4170   1CE5 DA F4 1C    	JP      C,ATN1          ; Yes - Get arc tangnt
4171   1CE8 01 00 81    	LD      BC,8100H        ; BCDE = 1
4172   1CEB 51          	LD      D,C
4173   1CEC 59          	LD      E,C
4174   1CED CD C4 17    	CALL    DVBCDE          ; Get reciprocal of number
4175   1CF0 21 1F 16    	LD      HL,SUBPHL       ; Sub angle from PI/2
4176   1CF3 E5          	PUSH    HL              ; Save for angle > 1
4177   1CF4 21 FE 1C    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4178   1CF7 CD B6 1B    	CALL    SUMSER          ; Evaluate sum of series
4179   1CFA 21 A5 1C    	LD      HL,HALFPI       ; PI/2 - angle in case > 1
4180   1CFD C9          	RET                     ; Number > 1 - Sub from PI/2
4181   1CFE             
4182   1CFE 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4183   1CFF 4A D7 3B 78 	.BYTE   04AH,0D7H,03BH,078H     ; 1/17
4184   1D03 02 6E 84 7B 	.BYTE   002H,06EH,084H,07BH     ;-1/15
4185   1D07 FE C1 2F 7C 	.BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4186   1D0B 74 31 9A 7D 	.BYTE   074H,031H,09AH,07DH     ;-1/11
4187   1D0F 84 3D 5A 7D 	.BYTE   084H,03DH,05AH,07DH     ; 1/9
4188   1D13 C8 7F 91 7E 	.BYTE   0C8H,07FH,091H,07EH     ;-1/7
4189   1D17 E4 BB 4C 7E 	.BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4190   1D1B 6C AA AA 7F 	.BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4191   1D1F 00 00 00 81 	.BYTE   000H,000H,000H,081H     ; 1/1
4192   1D23             
4193   1D23 C9          ARET:   RET                     ; A RETurn instruction
4194   1D24             
4195   1D24             ;       INPUT CHARACTER FROM CONSOLE VIA HBIOS
4196   1D24             
4197   1D24             GETINP:
4198   1D24 C5          	PUSH    BC
4199   1D25 D5          	PUSH    DE
4200   1D26 E5          	PUSH    HL
4201   1D27             
4202   1D27 0E D0       	LD      C,CIODEV_CONSOLE; CONSOLE UNIT TO C
4203   1D29 06 00       	LD      B,BF_CIOIN      ; HBIOS FUNC: INPUT CHAR
4204   1D2B CF          	RST     08              ; HBIOS READS CHARACTDR
4205   1D2C 7B          	LD      A,E             ; MOVE CHARACTER TO A FOR RETURN
4206   1D2D             
4207   1D2D E1          	POP     HL              ; RESTORE REGISTERS (AF IS OUTPUT)
4208   1D2E D1          	POP     DE
4209   1D2F C1          	POP     BC
4210   1D30 C9          	RET
4211   1D31             CLS:
4212   1D31             #IF     VT100
4213   1D31 21 0B 20    	LD      HL,VT_CLS       ; Output zero terminated
4214   1D34 7E          VT0OUT: LD      A,(HL)          ; VT100 escape sequence
4215   1D35 23          	INC     HL              ; directly to console.
4216   1D36 B7          	OR      A
4217   1D37 C4 7A 1E    	CALL    NZ,MONOUT       ; clear screen
4218   1D3A 20 F8       	JR      NZ,VT0OUT       ; and home cursor
4219   1D3C 11 B1 1E    	cpm.cWriteStr(HELLO)
4219   1D3F 0E 09       
4219   1D41 CD 05 00    
4220   1D44 C9          	RET
4221   1D45~            #ELSE
4222   1D45~                   LD      A,CS            ; ASCII Clear screen
4223   1D45~                   JP      MONOUT          ; Output character
4224   1D45             #ENDIF
4225   1D45             
4226   1D45 CD ED 15    WIDTH:  CALL    GETINT          ; Get integer 0-255
4227   1D48 7B          	LD      A,E             ; Width to A
4228   1D49 32 D2 22    	LD      (LWIDTH),A      ; Set width
4229   1D4C C9          	RET
4230   1D4D             
4231   1D4D CD 8C 0E    LINES:  CALL    GETNUM          ; Get a number
4232   1D50 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
4233   1D53 ED 53 D6 22 	LD      (LINESC),DE     ; Set lines counter
4234   1D57 ED 53 D8 22 	LD      (LINESN),DE     ; Set lines number
4235   1D5B C9          	RET
4236   1D5C             
4237   1D5C CD D1 0A    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4238   1D5F D5          	PUSH    DE              ; Save number
4239   1D60 E1          	POP     HL              ; Number to HL
4240   1D61 46          	LD      B,(HL)          ; Get LSB of contents
4241   1D62 23          	INC     HL
4242   1D63 7E          	LD      A,(HL)          ; Get MSB of contents
4243   1D64 C3 47 12    	JP      ABPASS          ; Return integer AB
4244   1D67             
4245   1D67 CD 8C 0E    DOKE:   CALL    GETNUM          ; Get a number
4246   1D6A CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
4247   1D6D D5          	PUSH    DE              ; Save address
4248   1D6E CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
4249   1D71 2C          	.BYTE      ','
4250   1D72 CD 8C 0E    	CALL    GETNUM          ; Get a number
4251   1D75 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
4252   1D78 E3          	EX      (SP),HL         ; Save value,get address
4253   1D79 73          	LD      (HL),E          ; Save LSB of value
4254   1D7A 23          	INC     HL
4255   1D7B 72          	LD      (HL),D          ; Save MSB of value
4256   1D7C E1          	POP     HL              ; Restore code string address
4257   1D7D C9          	RET
4258   1D7E             
4259   1D7E             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4260   1D7E             
4261   1D7E CD 8F 0E    HEX:    CALL    TSTNUM          ; Verify it's a number
4262   1D81 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
4263   1D84 C5          	PUSH    BC              ; Save contents of BC
4264   1D85 21 79 23    	LD      HL,PBUFF
4265   1D88 7A          	LD      A,D             ; Get high order into A
4266   1D89 FE 00       	CP      $0
4267   1D8B 28 0C       	JR      Z,HEX2          ; Skip output if both high digits are zero
4268   1D8D CD B6 1D    	CALL    BYT2ASC         ; Convert D to ASCII
4269   1D90 78          	LD      A,B
4270   1D91 FE 30       	CP      '0'
4271   1D93 28 02       	JR      Z,HEX1          ; Don't store high digit if zero
4272   1D95 70          	LD      (HL),B          ; Store it to PBUFF
4273   1D96 23          	INC     HL              ; Next location
4274   1D97 71          HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4275   1D98 23          	INC     HL              ; Next location
4276   1D99 7B          HEX2:   LD      A,E             ; Get lower byte
4277   1D9A CD B6 1D    	CALL    BYT2ASC         ; Convert E to ASCII
4278   1D9D 7A          	LD      A,D
4279   1D9E FE 00       	CP      $0
4280   1DA0 20 05       	JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4281   1DA2 78          	LD      A,B
4282   1DA3 FE 30       	CP      '0'             ; If high digit of lower byte is zero then don't print
4283   1DA5 28 02       	JR      Z,HEX4
4284   1DA7 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4285   1DA8 23          	INC     HL              ; Next location
4286   1DA9 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4287   1DAA 23          	INC     HL              ; PBUFF+4 to zero
4288   1DAB AF          	XOR     A               ; Terminating character
4289   1DAC 77          	LD      (HL),A          ; Store zero to terminate
4290   1DAD 23          	INC     HL              ; Make sure PBUFF is terminated
4291   1DAE 77          	LD      (HL),A          ; Store the double zero there
4292   1DAF C1          	POP     BC              ; Get BC back
4293   1DB0 21 79 23    	LD      HL,PBUFF        ; Reset to start of PBUFF
4294   1DB3 C3 F5 12    	JP      STR1            ; Convert the PBUFF to a string and return it
4295   1DB6             
4296   1DB6 47          BYT2ASC LD      B,A             ; Save original value
4297   1DB7 E6 0F       	AND     $0F             ; Strip off upper nybble
4298   1DB9 FE 0A       	CP      $0A             ; 0-9?
4299   1DBB 38 02       	JR      C,ADD30         ; If A-F, add 7 more
4300   1DBD C6 07       	ADD     A,$07           ; Bring value up to ASCII A-F
4301   1DBF C6 30       ADD30   ADD     A,$30           ; And make ASCII
4302   1DC1 4F          	LD      C,A             ; Save converted char to C
4303   1DC2 78          	LD      A,B             ; Retrieve original value
4304   1DC3 0F          	RRCA                    ; and Rotate it right
4305   1DC4 0F          	RRCA
4306   1DC5 0F          	RRCA
4307   1DC6 0F          	RRCA
4308   1DC7 E6 0F       	AND     $0F             ; Mask off upper nybble
4309   1DC9 FE 0A       	CP      $0A             ; 0-9? < A hex?
4310   1DCB 38 02       	JR      C,ADD301        ; Skip Add 7
4311   1DCD C6 07       	ADD     A,$07           ; Bring it up to ASCII A-F
4312   1DCF C6 30       ADD301  ADD     A,$30           ; And make it full ASCII
4313   1DD1 47          	LD      B,A             ; Store high order byte
4314   1DD2 C9          	RET
4315   1DD3             
4316   1DD3             ; Convert "&Hnnnn" to FPREG
4317   1DD3             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4318   1DD3             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4319   1DD3             ;
4320   1DD3 EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4321   1DD4 21 00 00    	LD      HL,$0000        ; Zero out the value
4322   1DD7 CD EC 1D    	CALL    GETHEX          ; Check the number for valid hex
4323   1DDA DA 0C 1E    	JP      C,HXERR         ; First value wasn't hex, HX error
4324   1DDD 18 05       	JR      HEXLP1          ; Convert first character
4325   1DDF CD EC 1D    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4326   1DE2 38 1F       	JR      C,HEXIT         ; Exit if not a hex character
4327   1DE4 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4328   1DE5 29          	ADD     HL,HL
4329   1DE6 29          	ADD     HL,HL
4330   1DE7 29          	ADD     HL,HL
4331   1DE8 B5          	OR      L               ; Add in D0-D3 into L
4332   1DE9 6F          	LD      L,A             ; Save new value
4333   1DEA 18 F3       	JR      HEXLP           ; And continue until all hex characters are in
4334   1DEC             
4335   1DEC 13          GETHEX  INC     DE              ; Next location
4336   1DED 1A          	LD      A,(DE)          ; Load character at pointer
4337   1DEE FE 20       	CP      ' '
4338   1DF0 CA EC 1D    	JP      Z,GETHEX        ; Skip spaces
4339   1DF3 D6 30       	SUB     $30             ; Get absolute value
4340   1DF5 D8          	RET     C               ; < "0", error
4341   1DF6 FE 0A       	CP      $0A
4342   1DF8 38 05       	JR      C,NOSUB7        ; Is already in the range 0-9
4343   1DFA D6 07       	SUB     $07             ; Reduce to A-F
4344   1DFC FE 0A       	CP      $0A             ; Value should be $0A-$0F at this point
4345   1DFE D8          	RET     C               ; CY set if was :            ; < = > ? @
4346   1DFF FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4347   1E01 3F          	CCF
4348   1E02 C9          	RET                     ; CY set if it wasn't valid hex
4349   1E03             
4350   1E03 EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4351   1E04 7A          	LD      A,D             ; Load DE into AC
4352   1E05 4B          	LD      C,E             ; For prep to
4353   1E06 E5          	PUSH    HL
4354   1E07 CD 46 12    	CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4355   1E0A E1          	POP     HL
4356   1E0B C9          	RET
4357   1E0C             
4358   1E0C 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4359   1E0E C3 A6 05    	JP      ERROR
4360   1E11             
4361   1E11             ; BIN$(NN) Convert integer to a 1-16 char binary string
4362   1E11 CD 8F 0E    BIN:    CALL    TSTNUM          ; Verify it's a number
4363   1E14 CD D1 0A    	CALL    DEINT           ; Get integer -32768 to 32767
4364   1E17 C5          BIN2:   PUSH    BC              ; Save contents of BC
4365   1E18 21 79 23    	LD      HL,PBUFF
4366   1E1B 06 11       	LD      B,17            ; One higher than max char count
4367   1E1D             ZEROSUP:                        ; Suppress leading zeros
4368   1E1D 05          	DEC     B               ; Max 16 chars
4369   1E1E 78          	LD      A,B
4370   1E1F FE 01       	CP      $01
4371   1E21 28 08       	JR      Z,BITOUT        ; Always output at least one character
4372   1E23 CB 13       	RL      E
4373   1E25 CB 12       	RL      D
4374   1E27 30 F4       	JR      NC,ZEROSUP
4375   1E29 18 04       	JR      BITOUT2
4376   1E2B             BITOUT:
4377   1E2B CB 13       	RL      E
4378   1E2D CB 12       	RL      D               ; Top bit now in carry
4379   1E2F             BITOUT2:
4380   1E2F 3E 30       	LD      A,'0'           ; Char for '0'
4381   1E31 CE 00       	ADC     A,0             ; If carry set then '0' --> '1'
4382   1E33 77          	LD      (HL),A
4383   1E34 23          	INC     HL
4384   1E35 05          	DEC     B
4385   1E36 20 F3       	JR      NZ,BITOUT
4386   1E38 AF          	XOR     A               ; Terminating character
4387   1E39 77          	LD      (HL),A          ; Store zero to terminate
4388   1E3A 23          	INC     HL              ; Make sure PBUFF is terminated
4389   1E3B 77          	LD      (HL),A          ; Store the double zero there
4390   1E3C C1          	POP     BC
4391   1E3D 21 79 23    	LD      HL,PBUFF
4392   1E40 C3 F5 12    	JP      STR1
4393   1E43             
4394   1E43             ; Convert "&Bnnnn" to FPREG
4395   1E43             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4396   1E43 EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4397   1E44 21 00 00    	LD      HL,$0000        ; Zero out the value
4398   1E47 CD 60 1E    	CALL    CHKBIN          ; Check the number for valid bin
4399   1E4A DA 6E 1E    	JP      C,BINERR        ; First value wasn't bin, HX error
4400   1E4D D6 30       BINIT:  SUB     '0'
4401   1E4F 29          	ADD     HL,HL           ; Rotate HL left
4402   1E50 B5          	OR      L
4403   1E51 6F          	LD      L,A
4404   1E52 CD 60 1E    	CALL    CHKBIN          ; Get second and addtional characters
4405   1E55 30 F6       	JR      NC,BINIT        ; Process if a bin character
4406   1E57 EB          	EX      DE,HL           ; Value into DE, Code string into HL
4407   1E58 7A          	LD      A,D             ; Load DE into AC
4408   1E59 4B          	LD      C,E             ; For prep to
4409   1E5A E5          	PUSH    HL
4410   1E5B CD 46 12    	CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4411   1E5E E1          	POP     HL
4412   1E5F C9          	RET
4413   1E60             
4414   1E60             ; Char is in A, NC if char is 0 or 1
4415   1E60 13          CHKBIN: INC     DE
4416   1E61 1A          	LD      A,(DE)
4417   1E62 FE 20       	CP      ' '
4418   1E64 CA 60 1E    	JP      Z,CHKBIN        ; Skip spaces
4419   1E67 FE 30       	CP      '0'             ; Set C if < '0'
4420   1E69 D8          	RET     C
4421   1E6A FE 32       	CP      '2'
4422   1E6C 3F          	CCF                     ; Set C if > '1'
4423   1E6D C9          	RET
4424   1E6E             
4425   1E6E 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4426   1E70 C3 A6 05    	JP      ERROR
4427   1E73             
4428   1E73             JJUMP1:
4429   1E73 DD 21 FF FF 	LD      IX,-1           ; Flag cold start
4430   1E77 C3 11 01    	JP      CSTART          ; Go and initialise
4431   1E7A             
4432   1E7A             ;       OUTPUT CHARACTER TO CONSOLE VIA HBIOS
4433   1E7A             
4434   1E7A             
4435   1E7A             
4436   1E7A             MONOUT:
4437   1E7A F5          	PUSH    AF              ; SAVE ALL INCOMING REGISTERS
4438   1E7B C5          	PUSH    BC
4439   1E7C D5          	PUSH    DE
4440   1E7D E5          	PUSH    HL
4441   1E7E             
4442   1E7E 5F          	LD      E,A             ; OUTPUT CHAR TO E
4443   1E7F CD C5 1F    	CALL 	CONOUT
4444   1E82             
4445   1E82 E1          	POP     HL              ; RESTORE ALL REGISTERS
4446   1E83 D1          	POP     DE
4447   1E84 C1          	POP     BC
4448   1E85 F1          	POP     AF
4449   1E86 C9          	RET
4450   1E87             
4451   1E87 C7          MONITR: cpm.pTerm()
4452   1E88             
4453   1E88 3E 00       INITST: LD      A,0             ; Clear break flag
4454   1E8A 32 DD 22    	LD      (BRKFLG),A
4455   1E8D CD 62 1F    	CALL    SET_DUR_TBL     ; SET UP SOUND TABLE
4456   1E90 C3 18 01    	JP      INIT
4457   1E93             
4458   1E93 ED 45       ARETN:  RETN                    ; Return from NMI
4459   1E95             
4460   1E95 F5          TSTBIT: PUSH    AF              ; Save bit mask
4461   1E96 A0          	AND     B               ; Get common bits
4462   1E97 C1          	POP     BC              ; Restore bit mask
4463   1E98 B8          	CP      B               ; Same bit set?
4464   1E99 3E 00       	LD      A,0             ; Return 0 in A
4465   1E9B C9          	RET
4466   1E9C             
4467   1E9C CD 71 08    OUTNCR: CALL    OUTC            ; Output character in A
4468   1E9F C3 C7 0C    	JP      PRNTCRLF        ; Output CRLF
4469   1EA2             
4470   1EA2             ; ---------------------------------------------------------------------------------------
4471   1EA2             
4472   1EA2 C5          SPIKE:  PUSH    BC
4473   1EA3 E5          	PUSH    HL
4474   1EA4 D5          	PUSH    DE
4475   1EA5 11 B1 1E    	cpm.cWriteStr(HELLO)
4475   1EA8 0E 09       
4475   1EAA CD 05 00    
4476   1EAD D1          	POP     DE
4477   1EAE E1          	POP     HL
4478   1EAF C1          	POP     BC
4479   1EB0 C9          	RET
4480   1EB1             
4481   1EB1 48 65 6C 6C HELLO: .BYTE   "Hello$"
4481   1EB5 6F 24 
4482   1EB7             
4483   1EB7             
4484   1EB7             ;       PLAY    O,N,D           ; PLAY OCTAVE 0-8, NOTE N (0-11), DURATION (1-8) [1/8 - 8/8 SECONDS]
4485   1EB7             
4486   1EB7 CD ED 15    PLAY:   CALL    GETINT          ; GET OCTAVE
4487   1EBA F5          	PUSH    AF              ; AND SAVE
4488   1EBB             
4489   1EBB CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
4490   1EBE 2C          	.BYTE   ','
4491   1EBF             
4492   1EBF CD ED 15    	CALL    GETINT          ; GET NOTE
4493   1EC2 E5          	PUSH    HL              ; SAVE SYNTAX POINTER
4494   1EC3 6F          	LD      L,A
4495   1EC4 26 00       	LD      H,0
4496   1EC6 29          	ADD     HL,HL           ; X2
4497   1EC7 29          	ADD     HL,HL           ; X4
4498   1EC8 11 DB 1F    	LD      DE,FRQDURTBL    ; POINT TO NOTE ENTRY
4499   1ECB 19          	ADD     HL,DE           ; ITS IN HL
4500   1ECC             
4501   1ECC E3          	EX      (SP),HL         ; RESTORE SYNTAX POINTER
4502   1ECD             				; IN HL. NOTE PTR ON STACK
4503   1ECD             
4504   1ECD CD 66 08    	CALL    CHKSYN          ; Make sure ',' follows
4505   1ED0 2C          	.BYTE   ','
4506   1ED1 CD ED 15    	CALL    GETINT          ; GET DURATION
4507   1ED4             
4508   1ED4 D1          	POP     DE              ; GET NOTE PTR IN DE
4509   1ED5 E3          	EX      (SP),HL         ; GET OCTAVE IN HL. SYNTAX POINTER ON STACK
4510   1ED6 EB          	EX      DE,HL           ; PUT NOTE PTR IN HL, OCTAVE IN DE
4511   1ED7             
4512   1ED7 C5          	PUSH    BC              ; SAVE SYNTAX POINTER
4513   1ED8 42          	LD      B,D             ; SAVE OCTAVE
4514   1ED9 F5          	PUSH    AF              ; SAVE DURATION
4515   1EDA             
4516   1EDA 7E          	LD      A,(HL)          ; LOAD 1ST ARG
4517   1EDB 23          	INC     HL              ; IN DE
4518   1EDC 5F          	LD      E,A             ; WHICH IS THE
4519   1EDD 7E          	LD      A,(HL)          ; FREQUENCY FOR
4520   1EDE 23          	INC     HL              ; THE EIGHTH
4521   1EDF 57          	LD      D,A             ; OCTAVE
4522   1EE0             
4523   1EE0 D5          	PUSH    DE
4524   1EE1             
4525   1EE1 7E          	LD      A,(HL)          ; LOAD 2ND ARG
4526   1EE2 23          	INC     HL              ; IN DE
4527   1EE3 5F          	LD      E,A             ; WHICH IS THE
4528   1EE4 7E          	LD      A,(HL)          ; PITCH
4529   1EE5 57          	LD      D,A
4530   1EE6             
4531   1EE6 D5          	PUSH    DE              ; SETUP ARGS IN HL
4532   1EE7 E1          	POP     HL              ; AND DE
4533   1EE8 D1          	POP     DE              ; DE = FREQUENCY
4534   1EE9             				; HL = PITCH
4535   1EE9 3E 08       	LD      A,8             ; DIVIDE THE
4536   1EEB 90          	SUB     B               ; FREQUENCY BASED
4537   1EEC 28 10       	JR      Z,SPK_OCTOK     ; ON THE OCTAVE
4538   1EEE 47          	LD      B,A
4539   1EEF             SPK_OCTDIV:
4540   1EEF CB 3A       	SRL     D       ; 0>D>C ; MULTIPLY THE
4541   1EF1 CB 1B       	RR      E       ; C>E>C ; DURATION EVERY
4542   1EF3 CB 25       	SLA     L       ; C<L<0 ; TIME WE DIVIDE
4543   1EF5 CB 14       	RL      H       ; C<H<C ; THE FREQUENCY
4544   1EF7 10 F6       	DJNZ    SPK_OCTDIV
4545   1EF9             
4546   1EF9 30 03       	JR      NC,SPK_OCTOK    ; SET TO MAXIMUM
4547   1EFB 21 FF FF    	LD      HL,$FFFF        ; IF OVERFLOW
4548   1EFE             
4549   1EFE             SPK_OCTOK:
4550   1EFE             
4551   1EFE C1          	POP     BC              ; MULTIPLY CHL X B
4552   1EFF E5          	PUSH    HL              ; SAVE
4553   1F00             
4554   1F00 0E 00       	LD      C,0
4555   1F02 61          	LD      H,C
4556   1F03 69          	LD      L,C
4557   1F04 3F          	CCF
4558   1F05 19          MULSKP: ADD     HL,DE
4559   1F06 30 01       	JR      NC,MULDLP
4560   1F08 0C          	INC     C
4561   1F09 10 FA       MULDLP: DJNZ    MULSKP          ; DIVIDE BY 8
4562   1F0B             
4563   1F0B CB 39       	SRL     C               ; 0>C>C ; BCHL = BCHL / 2
4564   1F0D CB 1C       	RR      H               ; C>H>C ;
4565   1F0F CB 1D       	RR      L               ; C>L>C ;
4566   1F11 CB 39       	SRL     C               ; 0>C>C ; BCHL = BCHL / 2
4567   1F13 CB 1C       	RR      H               ; C>H>C ;
4568   1F15 CB 1D       	RR      L               ; C>L>C ;
4569   1F17 CB 39       	SRL     C               ; 0>C>C ; BCHL = BCHL / 2
4570   1F19 CB 1C       	RR      H               ; C>H>C ;
4571   1F1B CB 1D       	RR      L               ; C>L>C ;
4572   1F1D             
4573   1F1D D1          	POP     DE
4574   1F1E EB          	EX      DE,HL
4575   1F1F             
4576   1F1F             ;       The following SPK_BEEPER routine is a modification of code from
4577   1F1F             ;       "The Complete SPECTRUM ROM DISSASSEMBLY" by Dr Ian Logan & Dr Frank O’Hara
4578   1F1F             ;       https://www.esocop.org/docs/CompleteSpectrumROMDisassemblyThe.pdf
4579   1F1F             ;
4580   1F1F             ;       DE      Number of passes to make through the sound generation loop
4581   1F1F             ;       HL      Loop delay parameter
4582   1F1F             
4583   1F1F DD E5       	PUSH    IX
4584   1F21 F3          	DI                      ; Disable the interrupt for the duration of a 'beep'.
4585   1F22 7D          	LD      A,L             ; Save L temporarily.
4586   1F23 CB 3D       	SRL     L               ; Each '1' in the L register is to count 4 T states, but take INT (L/4) and count 16 T states instead.
4587   1F25 CB 3D       	SRL     L
4588   1F27 2F          	CPL                     ; Go back to the original value in L and find how many were lost by taking 3-(A mod 4).
4589   1F28 E6 03       	AND     $03
4590   1F2A 4F          	LD      C,A
4591   1F2B 06 00       	LD      B,$00
4592   1F2D DD 21 36 1F 	LD      IX,SPK_DLYADJ   ; The base address of the timing loop.
4593   1F31 DD 09       	ADD     IX,BC           ; Alter the length of the timing loop. Use an earlier starting point for each '1' lost by taking INT (L/4).
4594   1F33 3A 61 1F    	LD      A,(RTCVAL)      ; Fetch the present border colour from BORDCR and move it to bits 2, 1 and 0 of the A register.
4595   1F36             ;
4596   1F36             ;       The HL register holds the 'length of the timing loop' with 16 T states being used for each '1' in the L register and 1024 T states for each '1' in the H register.
4597   1F36             ;
4598   1F36             SPK_DLYADJ:
4599   1F36 00          	NOP                     ; Add 4 T states for each earlier entry point that is used.
4600   1F37 00          	NOP
4601   1F38 00          	NOP
4602   1F39 04          	INC     B               ; The values in the B and C registers will come from the H and L registers - see below.
4603   1F3A 0C          	INC     C
4604   1F3B             BE_H_L_LP:
4605   1F3B 0D          	DEC     C               ; The 'timing loop', i.e. BC*4 T states. (But note that at the half-cycle point, C will be equal to L+1.)
4606   1F3C 20 FD       	JR      NZ,BE_H_L_LP
4607   1F3E 0E 3F       	LD      C,$3F
4608   1F40 05          	DEC     B
4609   1F41 C2 3B 1F    	JP      NZ,BE_H_L_LP
4610   1F44             ;
4611   1F44 EE 04       	XOR     %00000100       ; Flip bit 2. The loudspeaker is now alternately activated and deactivated.
4612   1F46 D3 C0       	OUT     (RTCIO),A       ; Perform the 'OUT' operation, leaving other bits unchanged.
4613   1F48 44          	LD      B,H             ; Reset the B register.
4614   1F49 4F          	LD      C,A             ; Save the A register.
4615   1F4A CB 67       	BIT     4,A             ; Jump if at the half-cycle point.
4616   1F4C 20 09       	JR      NZ,BE_AGAIN
4617   1F4E             ;
4618   1F4E 7A          	LD      A,D             ; After a full cycle the DE register pair is tested.
4619   1F4F B3          	OR      E
4620   1F50 28 09       	JR      Z,BE_END        ; Jump forward if the last complete pass has been made already.
4621   1F52 79          	LD      A,C             ; Fetch the saved value.
4622   1F53 4D          	LD      C,L             ; Reset the C register.
4623   1F54 1B          	DEC     DE              ; Decrease the pass counter.
4624   1F55 DD E9       	JP      (IX)            ; Jump back to the required starting location of the loop.
4625   1F57             ;
4626   1F57             BE_AGAIN:                       ; The parameters for the second half-cycle are set up.
4627   1F57 4D          	LD      C,L             ; Reset the C register.
4628   1F58 0C          	INC     C               ; Add 16 T states as this path is shorter.
4629   1F59 DD E9       	JP      (IX)            ; Jump back.
4630   1F5B             
4631   1F5B FB          BE_END: EI
4632   1F5C DD E1       	POP     IX
4633   1F5E C1          	POP     BC              ; RECALL SYNTAX POINTER
4634   1F5F E1          	POP     HL
4635   1F60 C9          	RET
4636   1F61             ;
4637   1F61 00          RTCVAL  .DB     0
4638   1F62             ;
4639   1F62             ;       SETUP THE ONE SECOND TONE DURATION TABLE BASED ON PROCESSOR SPEED AND TONE FREQUENCY
4640   1F62             ;
4641   1F62             ;       DURATION = (CPUMHZ / 8) / FREQUENCY
4642   1F62             ;       DURATION = (CPUKHZ * 1000 / 8 ) / FREQUENCY
4643   1F62             ;       DURATION = (CPUKHZ * 125 ) / FREQUENCY
4644   1F62             ;       DURATION = (CPUKHZ * 256 / 2 - CPUKHZ - (2 * CPUKHZ) ) / FREQUENCY
4645   1F62             
4646   1F62             SET_DUR_TBL:
4647   1F62 06 F8       	LD      B,BF_SYSGET             ; GET CPU SPEED
4648   1F64 0E F0       	LD      C,BF_SYSGET_CPUINFO     ; FROM HBIOS
4649   1F66 CF          	RST     08                      ; IN DE
4650   1F67             
4651   1F67 D5          	PUSH    DE                      ; SAVE FOR CALCULATION
4652   1F68 C1          	POP     BC                      ; - CPUKHZ - (2 * CPUKHZ)
4653   1F69             
4654   1F69 63          	LD      H,E                     ; DEHL = DE * 256
4655   1F6A 5A          	LD      E,D
4656   1F6B 16 00       	LD      D,0
4657   1F6D 6A          	LD      L,D
4658   1F6E             
4659   1F6E CB 3B       	SRL     E               ; 0>E>C ; DEHL = DEHL / 2
4660   1F70 CB 1C       	RR      H               ; C>H>C ;
4661   1F72 CB 1D       	RR      L               ; C>L>C ;
4662   1F74             
4663   1F74 ED 42       	SBC     HL,BC                   ; DEHL = DEHL - CPUKHZ
4664   1F76 30 01       	JR      NC,FRQ_AJ1
4665   1F78 1B          	DEC     DE
4666   1F79 CB 21       FRQ_AJ1:SLA     C               ; C<C<0 ; DEHL = DEHL - (2 * CPUKHZ)
4667   1F7B CB 10       	RL      B               ; C<B<C
4668   1F7D ED 42       	SBC     HL,BC
4669   1F7F 30 01       	JR      NC,FRQ_AJ2
4670   1F81 1B          	DEC     DE
4671   1F82             
4672   1F82             FRQ_AJ2:        ; AT THIS POINT DEHL = CPUKHZ * 125 E.G.  9982 KHZ * 125 = 0012:DE14
4673   1F82             
4674   1F82 E5          	PUSH    HL                      ; DEHL = CPUKHZ / 8) / FREQUENCY
4675   1F83 DD E1       	POP     IX                      ; HLIX = DENOMINATOR
4676   1F85 EB          	EX      DE,HL
4677   1F86             
4678   1F86 FD 21 DB 1F 	LD      IY,FRQDURTBL            ; POINT TO THE TABLE WE
4679   1F8A 06 0C       	LD      B,FDTBSIZ               ; WANT TO READ AND UPDATE
4680   1F8C C5          TBL_LP: PUSH    BC
4681   1F8D             
4682   1F8D FD 4E 00    	LD      C,(IY+0)                ; READ THE FREQUENCY
4683   1F90 FD 46 01    	LD      B,(IY+1)                ; FROM THE TABLE IN BC
4684   1F93             
4685   1F93 DD E5       	PUSH    IX                      ; STORE DENOMINATOR FOR NEXT LOOP
4686   1F95 E5          	PUSH    HL
4687   1F96             
4688   1F96 11 00 00    	LD      DE,0                    ; HLIX = HLIX / BC, DE = REMAINDER
4689   1F99 3E 20       	LD      A,32
4690   1F9B DD 29       DIV_LP: ADD     IX,IX
4691   1F9D ED 6A       	ADC     HL,HL
4692   1F9F EB          	EX      DE,HL
4693   1FA0 ED 6A       	ADC     HL,HL
4694   1FA2 B7          	OR      A
4695   1FA3 ED 42       	SBC     HL,BC
4696   1FA5 DD 23       	INC     IX
4697   1FA7 30 03       	JR      NC,DIV_CANSUB
4698   1FA9 09          	ADD     HL,BC
4699   1FAA DD 2B       	DEC     IX
4700   1FAC             DIV_CANSUB:
4701   1FAC EB          	EX      DE,HL
4702   1FAD 3D          	DEC     A
4703   1FAE 20 EB       	JR      NZ, DIV_LP              ; IX = RESULT
4704   1FB0             
4705   1FB0 DD E5       	PUSH    IX                      ; SAVE RESULT IN TABLE
4706   1FB2 D1          	POP     DE
4707   1FB3 FD 73 02    DUROVF: LD      (IY+2),E
4708   1FB6 FD 72 03    	LD      (IY+3),D
4709   1FB9             
4710   1FB9 11 04 00    	LD      DE,4                    ; POINT TO NEXT TABLE
4711   1FBC FD 19       	ADD     IY,DE                   ; ENTRY TO UPDATE
4712   1FBE             
4713   1FBE E1          	POP     HL                      ; RETREIVE THE DENOMINATOR
4714   1FBF DD E1       	POP     IX                      ; FOR THE NEXT LOOP
4715   1FC1             
4716   1FC1 C1          	POP     BC                      ; RETREIVE THE
4717   1FC2 10 C8       	DJNZ    TBL_LP                  ; LOOP COUNTER
4718   1FC4             
4719   1FC4 C9          	RET
4720   1FC5             
4721   1FC5             
4722   1FC5             #include "io.inc"
0001+  1FC5             
0002+  1FC5             ; Write a single char out to standard console
0003+  1FC5             ; E = chr
0004+  1FC5             CONOUT:
0005+  1FC5 0E 02       	cpm.cWrite()
0005+  1FC7 CD 05 00    
0006+  1FCA C9          	RET
4723   1FCB             #include "trace_strings.inc"
0001+  1FCB             
0002+  1FCB 31 31 31 24 MARKER1:  .TEXT  "111$"
0003+  1FCF 32 32 32 24 MARKER2:  .TEXT  "222$"
0004+  1FD3 33 33 33 24 MARKER3:  .TEXT  "333$"
0005+  1FD7 34 34 34 24 MARKER4:  .TEXT  "444$"
4724   1FDB             
4725   1FDB             ;
4726   1FDB             ;       ONE OCTAVE TONE TABLE IN FREQUENCY, DURATION FORMAT. TO COMPENSATE FOR DIFFERENT
4727   1FDB             ;       CPU FREQUENCIES THE DURATION IS CALCULATED AND POPULATED AT STARTUP. DIFFERENT OCTAVE
4728   1FDB             ;       AND DURATIONS ARE CALCULATE BY MODIFYING THE VALUES READ FROM THIS TABLE.
4729   1FDB             ;
4730   1FDB             FRQDURTBL:
4731   1FDB 5A 10 00 00 	.DW     $105A, $0, $1152, $0    ; C, C#
4731   1FDF 52 11 00 00 
4732   1FE3 5A 12 00 00 	.DW     $125A, $0, $1372, $0    ; D, D#
4732   1FE7 72 13 00 00 
4733   1FEB 9A 14 00 00 	.DW     $149A, $0               ; E
4734   1FEF D3 15 00 00 	.DW     $15D3, $0, $171F, $0    ; F, F#
4734   1FF3 1F 17 00 00 
4735   1FF7 75 18 00 00 	.DW     $1875, $0, $19F4, $0    ; G, G#
4735   1FFB F4 19 00 00 
4736   1FFF 80 1B 00 00 	.DW     $1B80, $0, $1D22, $0    ; A, A#
4736   2003 22 1D 00 00 
4737   2007 DE 1E 00 00 	.DW     $1EDE, $0               ; B
4738   200B             ;
4739   200B             FDTBSIZ .EQU    ($-FRQDURTBL)/4
4740   200B             ;
4741   200B             #IF VT100
4742   200B 1B 5B 32 4A VT_CLS  .BYTE   ESC,"[2J",ESC,"[H",0    ; vt100 clear screen & home
4742   200F 1B 5B 48 00 
4743   2013             #ENDIF
4744   2013             ;
4745   2013             SLACK   .EQU    (BAS_END - $)
4746   2013 00 00 00 00 	.FILL   SLACK,00H
4746   2017 00 00 00 00 
4746   201B 00 00 00 00 
4746   201F 00 00 00 00 
4746   2023 00 00 00 00 
4746   2027 00 00 00 00 
4746   202B 00 00 00 00 
4746   202F 00 00 00 00 
4746   2033 00 00 00 00 
4746   2037 00 00 00 00 
4746   203B 00 00 00 00 
4746   203F 00 00 00 00 
4746   2043 00 00 00 00 
4746   2047 00 00 00 00 
4746   204B 00 00 00 00 
4746   204F 00 00 00 00 
4746   2053 00 00 00 00 
4746   2057 00 00 00 00 
4746   205B 00 00 00 00 
4746   205F 00 00 00 00 
4746   2063 00 00 00 00 
4746   2067 00 00 00 00 
4746   206B 00 00 00 00 
4746   206F 00 00 00 00 
4746   2073 00 00 00 00 
4746   2077 00 00 00 00 
4746   207B 00 00 00 00 
4746   207F 00 00 00 00 
4746   2083 00 00 00 00 
4746   2087 00 00 00 00 
4746   208B 00 00 00 00 
4746   208F 00 00 00 00 
4746   2093 00 00 00 00 
4746   2097 00 00 00 00 
4746   209B 00 00 00 00 
4746   209F 00 00 00 00 
4746   20A3 00 00 00 00 
4746   20A7 00 00 00 00 
4746   20AB 00 00 00 00 
4746   20AF 00 00 00 00 
4746   20B3 00 00 00 00 
4746   20B7 00 00 00 00 
4746   20BB 00 00 00 00 
4746   20BF 00 00 00 00 
4746   20C3 00 00 00 00 
4746   20C7 00 00 00 00 
4746   20CB 00 00 00 00 
4746   20CF 00 00 00 00 
4746   20D3 00 00 00 00 
4746   20D7 00 00 00 00 
4746   20DB 00 00 00 00 
4746   20DF 00 00 00 00 
4746   20E3 00 00 00 00 
4746   20E7 00 00 00 00 
4746   20EB 00 00 00 00 
4746   20EF 00 00 00 00 
4746   20F3 00 00 00 00 
4746   20F7 00 00 00 00 
4746   20FB 00 00 00 00 
4746   20FF 00 00 00 00 
4746   2103 00 00 00 00 
4746   2107 00 00 00 00 
4746   210B 00 00 00 00 
4746   210F 00 00 00 00 
4746   2113 00 00 00 00 
4746   2117 00 00 00 00 
4746   211B 00 00 00 00 
4746   211F 00 00 00 00 
4746   2123 00 00 00 00 
4746   2127 00 00 00 00 
4746   212B 00 00 00 00 
4746   212F 00 00 00 00 
4746   2133 00 00 00 00 
4746   2137 00 00 00 00 
4746   213B 00 00 00 00 
4746   213F 00 00 00 00 
4746   2143 00 00 00 00 
4746   2147 00 00 00 00 
4746   214B 00 00 00 00 
4746   214F 00 00 00 00 
4746   2153 00 00 00 00 
4746   2157 00 00 00 00 
4746   215B 00 00 00 00 
4746   215F 00 00 00 00 
4746   2163 00 00 00 00 
4746   2167 00 00 00 00 
4746   216B 00 00 00 00 
4746   216F 00 00 00 00 
4746   2173 00 00 00 00 
4746   2177 00 00 00 00 
4746   217B 00 00 00 00 
4746   217F 00 00 00 00 
4746   2183 00 00 00 00 
4746   2187 00 00 00 00 
4746   218B 00 00 00 00 
4746   218F 00 00 00 00 
4746   2193 00 00 00 00 
4746   2197 00 00 00 00 
4746   219B 00 00 00 00 
4746   219F 00 00 00 00 
4746   21A3 00 00 00 00 
4746   21A7 00 00 00 00 
4746   21AB 00 00 00 00 
4746   21AF 00 00 00 00 
4746   21B3 00 00 00 00 
4746   21B7 00 00 00 00 
4746   21BB 00 00 00 00 
4746   21BF 00 00 00 00 
4746   21C3 00 00 00 00 
4746   21C7 00 00 00 00 
4746   21CB 00 00 00 00 
4746   21CF 00 00 00 00 
4746   21D3 00 00 00 00 
4746   21D7 00 00 00 00 
4746   21DB 00 00 00 00 
4746   21DF 00 00 00 00 
4746   21E3 00 00 00 00 
4746   21E7 00 00 00 00 
4746   21EB 00 00 00 00 
4746   21EF 00 00 00 00 
4746   21F3 00 00 00 00 
4746   21F7 00 00 00 00 
4746   21FB 00 00 00 00 
4746   21FF 00 
4747   2200             ;
4748   2200             	.ECHO   "BASIC space remaining: "
4749   2200             	.ECHO   SLACK
4750   2200             	.ECHO   " bytes.\n"
4751   2200             
4752   2200             .END
